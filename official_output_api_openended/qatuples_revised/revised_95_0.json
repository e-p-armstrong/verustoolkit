[
    "How does the `decryptdata` function in Verus work, and what are its components and options?",
    "The `decryptdata` function in Verus is used to decrypt a vdxf data descriptor, which is typically encrypted to a z-address. This function takes in a JSON object with several components and options.\n\nThe components of the JSON object are:\n\n* `datadescriptor`: This is a required object that contains the encrypted data descriptor to be decrypted. It uses the wallet keys included in the descriptor.\n* `evk`: This is an optional extended viewing key (Sapling extended full viewing key) that can be used for decoding. If it is known, it can be provided to assist with decryption.\n* `ivk`: This is an optional incoming viewing key (Sapling incoming viewing key hex) that can be used for decoding. If it is known, it can be provided to assist with decryption.\n* `txid`: This is an optional transaction ID (hex) that may be needed when the data is from a transaction and the `retrieve` option is set to true.\n* `retrieve`: This is an optional boolean value that defaults to false. If set to true, the function will retrieve the data from its reference and decrypt it if possible.\n\nThe function returns the decrypted data descriptor, with as much decryption as possible completed. If no decryption is possible, it returns an error.\n\nThe `decryptdata` function can be used to decrypt data that was previously encrypted using the `signdata` function. For example, if you encrypted some data using the command `verus signdata '{\"address\":\"Verus Coin Foundation.vrsc@\", \"createmmr\":true, \"data\":[{\"message\":\"hello world\", \"encrypttoaddress\":\"Sapling address\"}]}'`, you can then decrypt it using the command `verus decryptdata '{encrypteddatadescriptor}'`.",
    "decryptdata '{\n         \"datadescriptor\": {},\n         \"evk\":\"Optional Sapling extended full viewing key\",\n         \"ivk\":\"Optional hex incoming viewing key\",\n         \"txid\":\"hex\",\n         \"retrieve\": bool\n       }Decrypts a vdxf data descriptor, which is typically encrypted to a z-address. If the viewing key is present, it is decrypted, and any nested encryptions are attempted as well.\nIf either the viewing key or the ssk are correct, the object will be returned with as much decryption as possible completed.\nIf no decryption is possible, this function returns an error.Arguments:\n{\n  \"datadescriptor\": {}                      (object, required) Encrypted data descriptor to decrypt, uses wallet keys included in descriptor\n  \"evk\":\"Sapling extended full viewing key\"           (evk, optional) if known, an extended viewing key to use for decoding that may not be in the descriptor\n  \"ivk\":\"Sapling incoming viewing key hex\"            (ivk, optional) if known, an incoming viewing key to use for decoding\n  \"txid\":\"hex\",                         (txid, optional) if data is from a tx and retrieve is true, this may be needed when the data is on the same tx as the link\n  \"retrieve\": bool                        (bool, optional) Defaults to false. If true and the data passed is an encrypted or unencrypted reference\n                                             on this chain, it retrieves the data from its reference and decrypts if it can\n}Result:Examples:Encrypt data\n> verus signdata '{\"address\":\"Verus Coin Foundation.vrsc@\", \"createmmr\":true, \"data\":[{\"message\":\"hello world\", \"encrypttoaddress\":\"Sapling address\"}]}'Decrypt data\n> verus decryptdata '{encrypteddatadescriptor}'",
    "./raw_text_input_api_text/decryptdata"
]