[
    "What is the purpose of the `signdata` command in Verus, and how does it work?",
    "The `signdata` command in Verus is used to sign data with a specified address or identity. This command generates a hash of the provided data, and then signs that hash with the specified address or identity. The resulting signature can be used to verify the authenticity of the data.\n\nThe `signdata` command takes a JSON object as an argument, which contains various parameters that control how the data is signed. These parameters include:\n\n* `address`: The transparent address or identity to use for signing.\n* `prefixstring`: An extra string that is hashed during signature and must be supplied for verification.\n* `filename`, `message`, `messagehex`, `messagebase64`, or `datahash`: The data to be signed, which can be provided in various formats.\n* `mmrdata`: An array of data to be signed, which can be used to create a Merkle Mountain Range (MMR) of signed data.\n* `mmrsalt`: An array of salts to match the `mmrdata`.\n* `mmrhash`: The hash function to use for the MMR, which can be `sha256`, `sha256D`, `blake2b`, or `keccak256`.\n* `priormmr`: An array of MMR hashes prior to this data, which can be used to create a rev-linked MMR.\n* `vdxfkeys` and `vdxfkeynames`: Arrays of Verus Decentralized Data Exchange Format (VDXF) keys and key names, which can be used to encrypt and decrypt the data.\n* `boundhashes`: An array of hashes to be bound to the signature.\n* `hashtype`: The hash function to use, which can be `sha256`, `sha256D`, `blake2b`, or `keccak256`.\n* `encrypttoaddress`: A Sapling address to encrypt the data to, which allows for granular encryption and decryption.\n* `createmmr`: A boolean flag indicating whether to create an MMR of the signed data.\n* `signature`: The current signature to be updated.\n\nBy providing these parameters, the `signdata` command allows for flexible and granular control over the signing process, enabling a wide range of use cases for data signing and verification in Verus.",
    "signdata '{\"address\":\"i-address or friendly name to sign with (t-address will result in simple signature w/indicated hash and prefix, nothing else)\",\n      \"prefixstring\":\"extra string that is hashed during signature and must be supplied for verification\",\n       \"filename\":\"filepath/filename\" |\n       \"message\":\"any message\" |\n       \"vdxfdata\":\"vdxf encoded data\" |\n       \"messagehex\":\"hexdata\" |\n       \"messagebase64\":\"base64data\" |\n       \"datahash\":\"256bithex\" |\n       \"mmrdata\":[{\"filename | serializedhex | serializedbase64 | vdxfdata | message | datahash\":\"str\"} | \"strdata\"],\n       \"mmrsalt\":[array of \"salt\" to match the mmrdata],\n       \"mmrhash\":\"sha256\" | \"sha256D\" | \"blake2b\" | \"keccak256\",\n       \"priormmr\":\"[array of mmr hashes prior to this data and optional prior tx reference for rev-linked MMR data]\",      \"vdxfkeys\":[\"vdxfkey i-address\", ...],\n      \"vdxfkeynames\":[\"vdxfkeyname, object for getvdxfid API, or friendly name ID -- no i-addresses\", ...],\n      \"boundhashes\":[\"hexhash\", ...],\n      \"hashtype\": \"sha256\" | \"sha256D\" | \"blake2b\" | \"keccak256\",\n      \"encrypttoaddress\": \"sapling address\",       granularly encrypt all data, either all decryptable with viewing key or parts using unique, SSKs\n      \"createmmr\":\"bool\",                 if true, 1 or more objects will be put into a merkle mountain range and the root signed\n      \"signature\":\"currentsig\"}'Generates a hash (SHA256 default if \"hashtype\" not specified) of the data, returns the hash, and signs it with parameters specifiedArguments:\n{\n \"address\":\"t-addr or identity\"                (string, required) The transparent address or identity to use for signing.\n \"filename\" | \"message\" | \"messagehex\" | \"messagebase64\" | \"datahash\" (string, optional) Data to s",
    "./raw_text_input_api_text/signdata"
]