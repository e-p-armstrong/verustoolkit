[
    "## Conversation that answers the provided questions:\n**User:**\nI'm still a bit unsure about how VerusIDs work, especially when it comes to protecting funds. How do VerusIDs protect funds in case of private key compromise, and what are the different states a VerusID can be in?\n\n**AI Assistant:**\nI'd be happy to explain that in more detail. \n\nA VerusID can be in one of three states: locked indefinitely, locked and will unlock after a predetermined amount of time has elapsed, and unlocked. In the locked state, the spending power of the ID can still be revoked, and revocation overrides locking.\n\nTo secure funds in case of private key compromise, VerusIDs offer a powerful solution. For example, let's say Bob@ holds 1000 VRSC and the private key for Bob@ is compromised. To protect the funds, you can assign both revocation and recovery authority to another ID, such as Alice@. Then, you can lock Bob@ with the condition that it won't unlock for a certain amount of time (e.g., 24 hours) after unlocking is requested. This time lock is protected by the blockchain and cannot be changed.\n\nIf an attacker tries to access the funds, they will first have to request that Bob@ be unlocked. However, because of the time lock, they will have to wait for 24 hours before they can try to access the funds. During this time, you can use Alice@ to revoke primary authority for Bob@, preventing the attacker from withdrawing the funds. You can then create a new address and use Alice@ to recover primary authority to the new address, effectively swapping out the controlling address. The attacker will now have private keys for an address that used to control Bob@ but now controls nothing.\n\nTo stay informed about unlock requests, you can set an alert since requests are publicly published on the blockchain. This way, you can take action to safeguard your funds in case of private key compromise.\n\nDoes that make sense? Do you have any more questions about how VerusIDs protect funds, or about the different states a VerusID can be in?",
    "AI Assistant",
    "",
    "N/A",
    [
        [
            "How do VerusIDs protect funds in case of private key compromise, and what are the different states a VerusID can be in?",
            "A VerusID can be in one of three states: locked indefinitely, locked and will unlock after a predetermined amount of time has elapsed, and unlocked. In the locked state, the spending power of the ID can still be revoked, and revocation overrides locking.\n\nTo secure funds in case of private key compromise, VerusIDs offer a powerful solution. For example, let's say Bob@ holds 1000 VRSC and the private key for Bob@ is compromised. To protect the funds, you can assign both revocation and recovery authority to another ID, such as Alice@. Then, you can lock Bob@ with the condition that it won't unlock for a certain amount of time (e.g., 24 hours) after unlocking is requested. This time lock is protected by the blockchain and cannot be changed.\n\nIf an attacker tries to access the funds, they will first have to request that Bob@ be unlocked. However, because of the time lock, they will have to wait for 24 hours before they can try to access the funds. During this time, you can use Alice@ to revoke primary authority for Bob@, preventing the attacker from withdrawing the funds. You can then create a new address and use Alice@ to recover primary authority to the new address, effectively swapping out the controlling address. The attacker will now have private keys for an address that used to control Bob@ but now controls nothing.\n\nTo stay informed about unlock requests, you can set an alert since requests are publicly published on the blockchain. This way, you can take action to safeguard your funds in case of private key compromise.",
            "ID:\nLocked indefinitely\nLocked and will unlock after\n1) an unlock has been requested and then\n2) a predetermined amount of time has elapsed\nUnlocked\nA VerusID can be in one of three states.\nWhen an ID is locked, its spending power can still be revoked. Revocation overrides locking. So, let\u2019s go back to our example and figure out how to really secure our funds.\nExample, Part B\nOnce again, Bob@ holds 1000 VRSC, but this time you can:\nAssign both revocation and recovery authority to the Alice@ address. (You could give revocation and recovery to different IDs, but for this example we\u2019ll put them both on the same one.)\nLock Bob@ with the condition that it won\u2019t unlock for 24 hours after unlocking is requested. Once you set a time, it can\u2019t be changed. It\u2019s protected by the blockchain.\nWith this design, you have complete a solution if a private key for Bob@ is compromised. Let\u2019s run through that scenario again.\nFirst, Bob@ is locked, so the attacker can\u2019t spend the 1000 VRSC. Instead, the attacker first has to request that Bob@ be unlocked. But you have cleverly configured Bob@ so it won\u2019t unlock until 24 hours after a request. You can use that time to safeguard your funds.\nUse Alice@ to revoke primary authority for Bob@. That prevents the attacker from withdrawing the funds.\nCreate a new address.\nUse Alice@ to recover primary authority to the new address. Bob@ is once again a functioning ID that you have primary authority over and that holds 1000 VRSC. You\u2019ve just swapped out a controlling address.\nThe attacker is now proud owner of private keys for an address that used to control Bob@ but now controls nothing.\nWhile this scenario tames the power of the private key, it also begs the question of how you know if an attacker has made an unlock request for Bob@? The answer is that requests are public \u2014 they\u2019re published on the blockchain. You can set an alert.\nIn Summary\nTwo b",
            "./raw_text_input_medium/How Verus Tames the Wild Private Key-2020-10-11 00:02:49"
        ]
    ]
]