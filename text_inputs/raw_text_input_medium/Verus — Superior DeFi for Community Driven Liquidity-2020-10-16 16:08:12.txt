Title: Verus — Superior DeFi for Community Driven Liquidity
Article URL: https://medium.com/veruscoin/verus-superior-defi-for-community-driven-liquidity-e2592b251146
Content:

Verus — Superior DeFi for Community Driven Liquidity
Simultaneous parallel processing of DeFi transactions allows Verus to advance the technology underpinning automated market makers and community liquidity. The result is a series of improvements including lower costs, optimization of liquidity, and new benefits to users.

The power of automated market makers and liquidity pools is a recently growing phenomenon, which so far has only been explored primarily within the VM models of Ethereum/EOS/Tron.
The VM model is based on serial processing of ordered transactions, solving each transaction one after the other after the other, etc..
Verus is an UTXO-based blockchain using smart transactions which are essentially smart contracts written into the protocol.
The Verus model allows for parallel processing of all transactions within a block simultaneously, allowing new paradigms for community driven liquidity.
Parallel processing saves users costs by reducing slippage, eliminating front-running, eliminating risks from faulty smart contracts and unintended consequences.
Parallel processing also allows for the fairest prices without mind to latency or gas price rigging, as well as novel investment vehicles, new approaches to arbitrage, and better use of all existing liquidity in a system.
Verus DeFi is conducted by smart “send transactions” on Verus blockchains any of which may include multi-chain capabilities; this means chain transaction costs are kept as low as possible or new, less expensive chains can take the traffic, and scalability is practically unlimited.
The Verus community believes that community driven liquidity does not need to be driven entirely by yield farming, but that ample liquidity will emerge under low-cost conditions, and that this liquidity will provide the lowest friction, lowest cost, lowest risk, fairest conversion transactions for the crypto and wider financial communities.
Verus is concurrently in the advanced stages of completing decentralized bridging technology which will allow other blockchain ecosystems (including Ethereum and its ERC-20s) to be represented on the Verus system in a decentralized manner.
Automated Market Makers and Community Driven Liquidity
The era of smart contract enabled blockchains, pioneered by Ethereum, has allowed the creation of new financial primitives. Among the most important of these are automated market makers. Brought to the Ethereum blockchain in 2017, they have developed into a popular new paradigm for conversion of one financial instrument to another. By attracting ERC20 holders to lock their tokens in so-called liquidity pools, the reserves in these pools act as an always-ready counterparty able to transact with any user at an algorithmically determined price. Prior to this, all price discovery in crypto markets had been through the bid/ask, order-matching paradigm. Automated market makers replace the order book with on-chain reserves, allowing asynchronous price discovery. The recently surging use of Ethereum-based liquidity pools speaks to the power of the model.
Notwithstanding the success so far, there have been various drawbacks and concerns with the community liquidity solutions that have been employed. The highest profile problems have been cases where the smart contracts involved have errors in design or execution that were overlooked, leading to catastrophic loss for liquidity providers. But other large problems have emerged, including front-running, latency wars, gas price rigging and high transaction costs. Less noticed drawbacks include sub-optimal use of all available liquidity in a system, and sub-optimal slippage on price discovery.
The Smart Contract VM Model
Prior to Komodo and Verus, smart contract enabled blockchains have used the state machine VM model where the blockchain acts as one giant world computer on which various contracts are “run”. This has been realized as a system of ordered actions/transactions simulating discrete events on a timeline, executed serially, in order, which is controlled by the miner. For liquidity pools and their users, this means that, within a block, one transaction or another will be the first to be processed (usually determined by order, and selected from all possible transactions by latency or gas prices paid), while others follow, in order. In serial processing, the order of the sequenced transactions has important implications for the fair and efficient use of liquidity.
Front-running is traditionally viewed as predatory market behavior and is endemic on Ethereum-based systems where transactions and contracts submitted to the network are public, and queue-jumping can take place. As described in the well-known 2019 paper Flash Boys 2.0 there is inevitably a race to be the “next trade”, and the entire platform becomes dominated by a zero sum game to optimally position a transaction in the sequence, with advantage to the miners, who often defer, based on earnings opportunity, to the most sophisticated and well-financed players .
Latency wars and gas price rigging are just two ways of manipulating the transaction sequence, a zero-sum arbitrage exploit. Advantage can be gained by reducing latency through better infrastructure; for example, by being in a better position in the network topology. Advantage also goes to traders/arbs who have worked out better gas price strategies, or have made deals with key miners. As described in Flash Boys 2.0, as the DeFi worlds grow bigger on Ethereum, systemic risks to the network consensus may arise when time-bandit attacks and additional exploits start to look enticing.
High transaction costs — for users who seek to convert from one asset to another, transaction costs are many and growing, starting with the basic Ethereum gas prices, which are large and growing on the crowded network. Additional costs come from the conversion fees needed to pay the “yield farmers” who stock the liquidity pools. And finally, there is the cost from predatory activity as described above. There are also unseen costs that arise from the less efficient design of serial transaction processing. Parallel transaction processing (described below) allows for more optimal slippage rates and more efficient use of overall systemic liquidity.

Verus — Smart Transactions
Verus is an entirely different model for the execution of smart transactions on the blockchain. In Verus. smart contract capabilities are primitives built into the protocol on a UTXO-based blockchain and are accessed by users through smart transactions. There are no intervening smart contracts to audit or sweat over. There is only the single protocol that leverages the added security gained from using a UTXO-based system. Users interact with smart contracts by issuing transactions using a simple command line API, or a few clicks in the GUI wallet. Most importantly for liquidity pools, protocol based smart transactions allow for the simultaneous solving of submitted transactions in any group of transactions, which for native currencies can either be a specific block, for launches, all pre-launch blocks, or for normal conversions, a group of transactions aggregated by the protocol rules. By processing all transactions aggregated according to the protocol in parallel, as opposed to serial processing, the specific order within a block has no impact on the fairness of any conversion. In fact, all conversions in all directions, which are processed on one group of transactions get exactly the same conversion price, without even a spread between conversions to and from a specific currency. The implications of this fundamental design difference are many and important.
There is also a fundamental difference in how Verus developers have chosen to implement liquidity pools and token conversions. In Ethereum, the users (converters of tokens) interact with different smart contracts than do the liquidity providers. They operate on different sides of the playing field, so to speak, only meeting occasionally to transact. In Verus, however, users and providers are using the exact same mechanism to achieve their ends — they each issue the same transactions, converting to, from or through an asset known as a multi-reserve currency. This new asset is, in effect, the pool. When a user wishes to convert from one token to another, they can conduct two successive transactions, first entering the “pool” by acquiring the multi-reserve currency, then, in the subsequent block, exiting the “pool” to the target currency. Or, they can elect to convert directly from reserve to reserve using a single “via” transaction, through the “pool”. These conversion transactions are accomplished by simple “sending” transactions, as easily as one would typically send a single cryptocurrency. Prices do not need to be selected as the user will be able to observe the price from the last block, understand the typical changes from block to block, and transact at the “market” price. The market price is the same fair, solved price for all users who transact in a block.
Reduced Costs and Risks for Liquidity Providers
The Verus system drives the marginal cost for provision of liquidity to zero, with the exception of the phenomenon known as “impermanent loss”. There are no smart contracts to audit — no unintended scenarios for poorly written contracts that will lead to catastrophic loss. Impermanent loss is dealt with through a fee of 0.025% that is paid to the “pool” holders by every conversion that goes directly from “reserve” to “reserve”. The phenomenon of impermanent loss is a mathematical property of automated market makers, inherent to the mechanisms required to solve new prices as reserves change from block to block. Unattended, it operates to penalize liquidity providers in situations where the conversion ratios of constituent currencies in a multi-reserve pool have diverged from the ratios that prevailed when the provider entered the pool. In the Ethereum VM model, as in Verus, the method to counteract impermanent loss includes the imposition of a standard conversion transaction fee. In Verus, the fee is earned and shared by holders of the multi-reserve currency, thus offering a yield based on the amount of the reserve-to-reserve conversion transactions conducted. In Verus, the fee is currently set at 0.025%, which is significantly lower than similar fees in Ethereum. The Verus community believes this will be more than sufficient to counteract impermanent loss in all but the most extreme cases.
Reduced Costs for Users/Converters
As stated multiple times above, the Verus system eliminates common predatory front-running behaviors. This is an endemic problem in Ethereum-based systems, and also in traditional financial markets, where high frequency trading and “flash boys” operate to game value out of the system at the expense of less sophisticated players. In traditional markets, where ordered transactions and serial transaction processing are also a necessary part of the paradigm, exchanges have begun to experiment with “speed bumps” in order to reduce the advantages of players with more sophisticated infrastructure and superior latency. With the decentralized, parallel transaction processing engine used by Verus nobody can predict the exact timing of the solving block, all transactions included in a block get the same price in all directions, and no single party can reliably control what transactions are or are not processed. Thus, Verus eliminates intra-block frontrunning, and using transaction expiration, even sophisticated front-runners that may attempt multi-block mining control can be prevented entirely using “fill-or-kill” transactions.
The parallel processing system also leads to reduced slippage for users in almost all circumstances. In all automated market makers, the price offered changes due to interaction with the system. Put simply, if I sell ETH for ERC20, my interaction will push down the price of ETH, and I will get less ERC20 than is indicated by the price existing immediately before my transaction. The larger the size of my transaction, the more slippage I will see. In a system that solves all transactions in parallel, including all “buys” and all “sells”, slippage is reduced because in solving the price for a block, the protocol will first “cancel out” (in the mathematical sense) all the buys and sells until one of them is zero. Then, in the above example, if purchases of ETH exceed sales of ETH (in the block in which I transact), then the price, from my perspective will have improved from that existing immediately prior to my transaction — the direct opposite of slippage. In a robustly-used system, it should be true that overall slippage experienced by users will be significantly lower than in a serial-based system.
Improved Benefits for Users
A significant benefit, covered extensively already, is that users (converters) can expect to receive the fairest, best price without any needed sophistication, trading algorithms, bots, superior infrastructure investment, and the like. In a “pool” that is fairly large (compared to my trading size) and regularly transacted, I can simply issue a sendcurrency command, and transact at market, with a calm and confidence that is rare in other serial-based heavily-gamed markets.
In fact, because of parallel processing, and the fact that other traders can be entering the pool along with me during my block, system stability acts as if overall liquidity has been significantly amplified (relative to what is possible with serial processing). In other words, for a given level of liquidity in the pool, a user can expect more stable slippage rates from block to block. There are two primary reasons for this. Firstly, with all transactions in a block cancelling themselves out towards parity, there is a lower ratio of effective aggregate transaction size to aggregate liquidity, thus giving the appearance of greater liquidity. Secondly, because other users (converters) are in the block with me, system liquidity is enhanced by use, even if users intend only to use the multi-reserve currency as a point-to-point conversion, and not a destination in itself. In this way, liquidity begets liquidity — if a particular multi-reserve is bootstrapped with sufficient liquidity, it becomes attractive for users because they can convert in the fair, low slippage, ungamed, low cost environment. As users come, liquidity naturally increases, and the system becomes increasingly robust, thus attracting more users.
Having said this, the multi-reserves also serve as a liquidity destination in themselves. This is because the multi-reserves act as two different types of novel investment vehicles. First, they are a self-rebalancing portfolio with zero fees and dynamic rebalancing over 1000 times per day. An investor can, for example, choose to convert into a “quad coin” that is a multi-reserve currency that is backed by 25/25/25/25% of four different tokens (say, ETH, BTC, VRSC, USDT). Many sophisticated investors typically follow efficient portfolio theory and engage in occasional rebalancing. Usually done once a year, a quarter, or after sharp moves, rebalancing requires management oversight (thus costs or fees) and continuous transaction fees for selling and acquiring the coins (plus occasional market slippage in that process). It can also only vaguely approximate the desired hoped for strategy. In a multi-reserve, exposure is retained at 25/25/25/25 automatically, without fees, and is done on every block — a significant advance for all who seek to stay with balanced exposure despite market moves.
It’s important to note, as described above, that a self-rebalancing portfolio would be susceptible to impermanent loss. Accordingly, in order to counteract this, and to attract providers who are interested in self-rebalancing, Verus includes the already described conversion fees. At a minimum, these fees should be sufficient to counteract any impermanent loss. Also possible though, is the result that the conversion fees will exceed the impermanent loss experienced by a provider — this is because impermanent loss is not “permanent” in the sense that it appears and disappears only insofar as conversion ratios diverge from those that prevailed when a provider acquired the multi-reserve currency. So, in the example of highly used conversion “pools” where those rates eventually return to those prevailing when the provider entered the system, there would be no impermanent loss but the provider would still enjoy conversion fees that were generated along the way. Such situations give liquidity providers the opportunity to “yield farm”.
A second “destination” for investors is that they can achieve “throttled exposure” to an asset. Throttled exposure is the opposite of leverage and can be used to reduce risk, or to mirror, for example, the strategy of constantly selling down an appreciating asset, or constantly “dollar cost averaging down” with a falling asset. This throttling, or averaging up and down is also done automatically, with no fees, on every block more than a thousand times a day.
Finally, while liquidity baskets and balanced investments across multiple currencies is one way to use the Verus DeFi protocols, fractional currencies do not need to be 100% backed. While beyond the scope of this article, currencies that are not 100% backed have market prices that are decoupled from their underlying reserve basket, providing seamless liquidity to and from its basket currencies, earning fees between them, yet providing investment value that may far exceed a function of the currencies held in reserve as well.
Ease of Use, Low Transactions Costs and Scalability
Verus DeFi is conducted by normal “send transactions” using its sendcurrency API (or the GUI in the wallet). To convert from one currency into another, a user simply sends to themselves, electing to convert from a particular token to another token via a multi-reserve currency that contains both tokens as reserves. There are no limit orders currently implemented in Verus, as it is expected that robust pairs will have low slippage and fair, market rates. In less robust multi-reserves, users will have to take care that they do not transact in excessive volumes in order to guard against prices moving sharply in an undesired direction.
Verus is also in the process of implementing multi-chain capabilities with independent blockchains that are interoperable such that a particular token can exist on more than one chain. When work on a new chain requires a transaction fee, it can be paid in either an existing or new token, as appropriate. This leads to practically unlimited scalability since multi-reserves and tokens that are “popular” do not lead to chain congestion or transaction fee competition. Accordingly, transaction fees will always remain at a de minimis level.
Ease of use also operates at the level of liquidity “pool creation”, making pool creation possible for all types of users. No programming is required to define a pool. A user simply uses the definecurrency api (or a few clicks on the wallet GUI) to launch a new multi-reserve currency. It is a risk-less, permission-less process. Coupled with Verus’ multi-chain capabilities and easy creation of independent blockchains, new currencies, tokens and projects can set up community liquidity, and bootstrap it to a level commensurate to their size. This opens the door to all kinds of novel uses and developments.
User-Centric DeFi
The Verus community believes that community driven liquidity does not need to be driven entirely by yield farming (and increased costs to users), but that ample liquidity will emerge under near-zero-cost conditions, and that this liquidity will provide the lowest friction, lowest cost, lowest risk, fairest conversion transactions for the crypto and wider financial communities. As discussed above, liquidity will come from investors using multi-reserves as novel investment vehicles, from system liquidity (where continuous use begets its own liquidity), and from novel probabilistic arbitrage strategies which may result in staying “invested” in multi-reserves for multi-block periods. Also, coin communities, whales, and others who wish to bootstrap liquidity can do so more easily than in a VM-based system because they can do it with less risk and cost.
What is Verus’ DeFi Universe?
Verus is currently in the advanced stages of implementing its decentralized bridging protocols which will allow various coins, both ETH-like and UTXO coins, and others, to be represented on the Verus system in a decentralized manner, and it will also allow all Verus-created currencies to be sent to and represented in the Ethereum network as automatically created ERC20 tokens. This will lead to an expansive universe of potential tokens and coins with liquidity across the Verus system and other leading blockchain networks.
In addition, with multi-chain capabilities, Verus will be a go-to destination for new projects and blockchains, as there is an easy, scalable system to deploy, with ready-made cost-free, risk-free roads to liquidity for new communities and projects.
Discuss and explore all Verus has to offer on Discord. Follow us on Twitter. Go to our website.
