[[["User:: I'm curious about how VerusID login works. Can you explain the process and the steps involved in logging into a website or service using VerusID?", "AI Assistant:: VerusID login is a secure and private way for users to log in to websites and services using their VerusID. Here's how it works:\n\nThe process starts when a user wants to log in to a website or service that supports VerusID login. The user is presented with a QR code, which they scan using their Verus Mobile app. This triggers a verification and data request process, where the app verifies the request from the website and asks the user to reveal some identity data.\n\nThe user can confirm the source of the request and verify the website's identity before trusting it. Once the user trusts the website, the app posts a reply to the website's server in the background, which causes an immediate login and sharing of the requested data privately.\n\nThroughout this process, the user is in control of their personal data and decides how, when, and with whom it is shared. The VerusID login system ensures that users' personal data is protected and respected, and that they have full control over it.\n\nThe key benefits of VerusID login include:\n\n* Private and secure login\n* User control over personal data\n* Private data sharing\n* Trustless verification\n* Immediate login and data sharing\n\nOverall, VerusID login provides a secure, private, and user-controlled way for individuals to log in to websites and services, while maintaining full control over their personal data.\n\nDo you have any questions about the VerusID login process or its benefits?"], "AI Assistant", "", "N/A", [["How does VerusID login work, and what are the steps involved in logging into a website or service using VerusID?", "VerusID login is a secure and private way for users to log in to websites and services using their VerusID. Here's how it works:\n\nThe process starts when a user wants to log in to a website or service that supports VerusID login. The user is presented with a QR code, which they scan using their Verus Mobile app. This triggers a verification and data request process, where the app verifies the request from the website and asks the user to reveal some identity data.\n\nThe user can confirm the source of the request and verify the website's identity before trusting it. Once the user trusts the website, the app posts a reply to the website's server in the background, which causes an immediate login and sharing of the requested data privately.\n\nThroughout this process, the user is in control of their personal data and decides how, when, and with whom it is shared. The VerusID login system ensures that users' personal data is protected and respected, and that they have full control over it.\n\nThe key benefits of VerusID login include:\n\n* Private and secure login\n* User control over personal data\n* Private data sharing\n* Trustless verification\n* Immediate login and data sharing\n\nOverall, VerusID login provides a secure, private, and user-controlled way for individuals to log in to websites and services, while maintaining full control over their personal data.", "# VerusID SSID Login\n\n::: tip VerusID Login Demo\nTest the VerusID login with Verus Mobile [here](https://verus.io/verusid-login-demo)\n:::\n\n### Login to websites and services\nLogin with VerusID on supported websites and services. Users control how, when, and with whom their personal data is shared. Users control their personal data fully.\n\n![image-verusid-login](/images/verusidlogin1.png)\n\nThese are the steps:\n1. **User Scans QR Code**: The user scans a QR code if they want to proceed to login. If the user has a valid attestation the website respects, it can be used on login.\n\n2. **Mobile App Verification and Data Request**: Once Verus Mobile ([Google Play](https://play.google.com/store/apps/details?id=org.autonomoussoftwarefoundation.verusmobile.android&hl=en&gl=US), [App Store](https://play.google.com/store/apps/details?id=org.autonomoussoftwarefoundation.verusmobile.android&hl=en&gl=US)) scans the QR code the user can verify the request from the site. In this case it will ask the user to reveal some identity data. The user can confirm the source of the request of data by verifying, and then trusting.\n\n3. **Login and Data Sharing**: At the website the user will be logged in using a reply the phone posts to the websites server in the background. This causes an immediate login and\nsharing of the data privately.", "./raw_text_input_docs/login.md"]]], [["User:: I'm curious about how the Verus-Ethereum Bridge works and how it prevents hacks. Can you explain how it ensures secure and decentralized cross-chain communication, and what safeguards are in place to prevent bridge hacks?", "AI Assistant:: The Verus-Ethereum Bridge is a critical component of the Verus ecosystem, and I'm happy to dive into the details of how it works.\n\nThe Verus-Ethereum Bridge ensures secure and decentralized cross-chain communication through a process called notarization. Every 10 blocks, block producers create digital receipts, known as notarizations, which contain essential information such as the stateroot, blockheight, blockhash, and gas price for Ethereum. These notarizations are agreed upon by block producers (miners and stakers) and are then mined into the Verus blockchain.\n\nBut what about security? How does the bridge prevent hacks? Well, the Verus-Ethereum Bridge has several safeguards in place to prevent bridge hacks. Firstly, it would require a majority of colluding, malicious witnesses to successfully mount an attack on the bridge. Additionally, these malicious witnesses would need to have more combined hash and stake power than the publicly validated Verus blockchain, which is a highly unlikely scenario.\n\nFurthermore, even if such an attack were possible, the bridge provides a way to defend against it. The Verus Protocol's hybrid consensus algorithm, known as Proof of Power (PoP), is designed to be resistant to 51% hash attacks, making it extremely difficult for malicious actors to compromise the bridge.\n\nIn summary, the Verus-Ethereum Bridge's decentralized and provable approach to cross-chain communication, combined with its robust safeguards against bridge hacks, ensures a secure and trustworthy bridge between the Verus and Ethereum blockchains.\n\nDo you have any more questions about the Verus-Ethereum Bridge or its security features?"], "AI Assistant", "", "N/A", [["How does the Verus-Ethereum Bridge ensure secure and decentralized cross-chain communication, and what safeguards are in place to prevent bridge hacks?", "The Verus-Ethereum Bridge ensures secure and decentralized cross-chain communication through a process called notarization. Every 10 blocks, block producers create digital receipts, known as notarizations, which contain essential information such as the stateroot, blockheight, blockhash, and gas price for Ethereum. These notarizations are agreed upon by block producers (miners and stakers) and are then mined into the Verus blockchain.\n\nTo prevent bridge hacks, the Verus-Ethereum Bridge has several safeguards in place. Firstly, it would require a majority of colluding, malicious witnesses to successfully mount an attack on the bridge. Additionally, these malicious witnesses would need to have more combined hash and stake power than the publicly validated Verus blockchain, which is a highly unlikely scenario.\n\nFurthermore, even if such an attack were possible, the bridge provides a way to defend against it. The Verus Protocol's hybrid consensus algorithm, known as Proof of Power (PoP), is designed to be resistant to 51% hash attacks, making it extremely difficult for malicious actors to compromise the bridge.\n\nIn summary, the Verus-Ethereum Bridge's decentralized and provable approach to cross-chain communication, combined with its robust safeguards against bridge hacks, ensures a secure and trustworthy bridge between the Verus and Ethereum blockchains.", "Every 10 blocks the block producers create a notarization (when there is traffic over the bridge). They create these digital receipts for both Verus and Ethereum. The digital receipts, called \u201cnotarizations\", contain, among other things: the \u201cstateroot\u201d ([Merkle Mountain Range](https://www.investopedia.com/terms/m/merkle-root-cryptocurrency.asp) for Verus, [Merkle Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) for Ethereum), the blockheight, blockhash and the gas price for Ethereum. The notarizations have to be agreed to by the block producers (miners and stakers) and are then mined into the Verus blockchain.\ud83d\udc49 [Read more here](https://medium.com/veruscoin/verus-internet-protocol-vip-provable-decentralized-cross-chain-communication-8d9414a429c5?source=rss----4869a79d7e7f---4) on how the Verus Protocol handles cross-chain communication (PBaaS-chains and more) in a decentralized and provable way.### Safeguards against bridge hacks\nThreats caused by malicious notary witnesses, or stolen keys to drain funds are not viable against the Verus-Ethereum Bridge. To successfully mount an attack on the bridge, if a majority of witnesses were colluding or got their private keys stolen the following would need to happen:- Colluding, malicious witnesses.\n- Fake block producers with more combined hash and stake power than the publicly validated Verus blockchain. [\ud83d\udc49 Verus Paper: A Provable Hybrid Solution to 51% Hash Attacks](https://verus.io/papers/VerusPoP.pdf)\n- Developers helping them by creating an alternate protocol for the shadow chain.These requirements are very close to the requirements of attacking any blockchain. The bridge even provides a way to defend against such an unlikely scenario.", "./raw_text_input_docs/README_eth-bridge.md"]]], [["User:: I'm trying to understand how Transfer Destination works in Verus. Can you explain the key components and considerations involved in the serialization and deserialization of Transfer Destination information, and why is it important for interoperability across different implementations?", "AI Assistant:: The serialization and deserialization of Transfer Destination information is a crucial aspect of Verus, and I'd be happy to break it down for you.\n\nThe core functionality of Transfer Destination in Verus revolves around the ability to serialize and deserialize destination information. Serialization is the process of converting destination data into a format that can be efficiently transmitted across networks or stored, while deserialization is the process of converting the serialized data back into its original form.\n\nThere are several key components involved in the serialization of Transfer Destination information:\n\n1. **Type**: A numerical value indicating the destination type, which includes flags and is serialized directly as part of the destination data.\n2. **Destination Bytes**: The specific bytes associated with the destination, which may represent an address, identifier, or other relevant data, depending on the destination type.\n3. **Gateway ID & Gateway Code**: Optional components used for gateway destinations, which are serialized when present to include external system identifiers.\n4. **Fees**: Associated fees, if applicable, which are serialized to ensure the correct processing of transactions, particularly for complex or cross-chain operations.\n5. **Auxiliary Destinations**: An optional list of additional Transfer Destination constructs, which are serialized to support nested or multi-part transactions.\n\nIt is essential that the serialization and deserialization mechanisms adhere to a standardized format to ensure interoperability across different implementations. This means that implementations in different programming languages should focus on accurately reflecting the structure and logic outlined, ensuring that Transfer Destination constructs are universally compatible, regardless of the underlying platform or language used.\n\nThe significance of Transfer Destination serialization and deserialization lies in its ability to enable efficient and secure transmission and storage of destination data, while maintaining integrity and compatibility across different implementations. This is crucial for ensuring seamless transactions and interactions within the Verus ecosystem.\n\nDo you have any further questions about Transfer Destination serialization and deserialization, or how it affects interoperability in Verus?"], "AI Assistant", "", "N/A", [["What are the key components and considerations involved in the serialization and deserialization of Transfer Destination information, and why is it important for interoperability across different implementations?", "The core functionality of Transfer Destination in Verus revolves around the ability to serialize and deserialize destination information. Serialization is the process of converting destination data into a format that can be efficiently transmitted across networks or stored, while deserialization is the process of converting the serialized data back into its original form.\n\nThere are several key components involved in the serialization of Transfer Destination information:\n\n1. **Type**: A numerical value indicating the destination type, which includes flags and is serialized directly as part of the destination data.\n2. **Destination Bytes**: The specific bytes associated with the destination, which may represent an address, identifier, or other relevant data, depending on the destination type.\n3. **Gateway ID & Gateway Code**: Optional components used for gateway destinations, which are serialized when present to include external system identifiers.\n4. **Fees**: Associated fees, if applicable, which are serialized to ensure the correct processing of transactions, particularly for complex or cross-chain operations.\n5. **Auxiliary Destinations**: An optional list of additional Transfer Destination constructs, which are serialized to support nested or multi-part transactions.\n\nIt is essential that the serialization and deserialization mechanisms adhere to a standardized format to ensure interoperability across different implementations. This means that implementations in different programming languages should focus on accurately reflecting the structure and logic outlined, ensuring that Transfer Destination constructs are universally compatible, regardless of the underlying platform or language used.\n\nThe significance of Transfer Destination serialization and deserialization lies in its ability to enable efficient and secure transmission and storage of destination data, while maintaining integrity and compatibility across different implementations. This is crucial for ensuring seamless transactions and interactions within the Verus ecosystem.", "The core functionality of Transfer Destination revolves around the ability to serialize and deserialize destination information. This process ensures that destination data can be efficiently transmitted across networks or stored, maintaining integrity and compatibility across different implementations.### Key Components in Serialization![image-transfer-destination-bytes](/images/transfer-destination-bytes.svg)- **Type**: A numerical value indicating the destination type, serialized directly as part of the destination data. Includes flags.\n- **Destination Bytes**: The specific bytes associated with the destination, which may represent an address, identifier, or other relevant data, depending on the destination type.\n- **Gateway ID & Gateway Code**: Optional components used for gateway destinations, serialized when present to include external system identifiers.\n- **Fees**: Associated fees, if applicable, serialized to ensure the correct processing of transactions, particularly for complex or cross-chain operations.\n- **Auxiliary Destinations**: An optional list of additional Transfer Destination constructs, serialized to support nested or multi-part transactions.### ConsiderationsThe serialization and deserialization mechanisms must adhere to a standardized format to ensure interoperability. Implementations in different programming languages should focus on accurately reflecting the structure and logic outlined, ensuring that Transfer Destination constructs are universally compatible, regardless of the underlying platform or language used.## Application and Significance", "./raw_text_input_docs/transfer-destination.md"]]], [["User:: Hi, I'm trying to understand the concept of simple token currencies in Verus. Can you explain what they are and how they relate to Ethereum ERC-20 tokens?", "AI Assistant:: I'd be happy to clarify that for you.\n\nSimple token currencies in Verus are a type of currency that does not have any reserves. While they may not offer the same level of complexity as basket currencies, they still provide significant value due to their flexibility and customizability. These currencies can be used in a variety of use cases, such as decentralized crowdfunding mechanisms, and can be created with various parameters and subIDs.\n\nIn a decentralized simple token currency, the supply is static, whereas in a centralized version, the owner of the rootID can mint new tokens and anyone can burn existing ones. Additionally, simple token currencies can be used to create currencies that are mapped to Ethereum ERC-20 tokens, allowing for seamless transfer between the two platforms.\n\nThe Verus-Ethereum Bridge, a non-custodial bridge, enables the transfer of currencies and tokens between Verus and Ethereum. This means that any currency or token on Verus or any other PBaaS blockchain can be exported to Ethereum as an ERC-20 token, allowing it to be used in the Ethereum ecosystem. Conversely, any existing ERC-20 token can be mapped one-to-one as a Verus currency, allowing it to leverage the features of the Verus blockchain.\n\nThe Verus-Ethereum Bridge operates on a consensus-based system, ensuring that all tokens and currencies transferred between the two platforms are never in anyone's custody and are verified by consensus rules. This provides a secure and trustworthy means of transferring assets between Verus and Ethereum.\n\nDo you have any more questions about simple token currencies or the Verus-Ethereum Bridge?"], "AI Assistant", "", "N/A", [["What are simple token currencies in the context of Verus, and how do they relate to Ethereum ERC-20 tokens?", "Simple token currencies in Verus are a type of currency that does not have any reserves. While they may not offer the same level of complexity as basket currencies, they still provide significant value due to their flexibility and customizability. These currencies can be used in a variety of use cases, such as decentralized crowdfunding mechanisms, and can be created with various parameters and subIDs.\n\nIn a decentralized simple token currency, the supply is static, whereas in a centralized version, the owner of the rootID can mint new tokens and anyone can burn existing ones. Additionally, simple token currencies can be used to create currencies that are mapped to Ethereum ERC-20 tokens, allowing for seamless transfer between the two platforms.\n\nThe Verus-Ethereum Bridge, a non-custodial bridge, enables the transfer of currencies and tokens between Verus and Ethereum. This means that any currency or token on Verus or any other PBaaS blockchain can be exported to Ethereum as an ERC-20 token, allowing it to be used in the Ethereum ecosystem. Conversely, any existing ERC-20 token can be mapped one-to-one as a Verus currency, allowing it to leverage the features of the Verus blockchain.\n\nThe Verus-Ethereum Bridge operates on a consensus-based system, ensuring that all tokens and currencies transferred between the two platforms are never in anyone's custody and are verified by consensus rules. This provides a secure and trustworthy means of transferring assets between Verus and Ethereum.", "## Simple token currencies\nSimple token currencies and are just currencies without any reserves. They are not as exciting as the basket currencies, yet still offer much value. With all the parameters that can be added, subIDs created and decentralized crowdfund mechanisms, these currencies can support a lot of use cases that are difficult to do with alternative protocols.The supply of this type of currency is static when it\u2019s a decentralized version. When it\u2019s a centralized version, the owner of the rootID can mint tokens into existence, and anyone can burn them.This option is also used to create currencies that are mapped to Ethereum ERC-20s. Which means you can send those ERC-20s over to Verus, or from Verus to the ERC-20. This is made possible with the non-custodial Verus-Ethereum Bridge. You can read more about it here.And of course, a simple token currency can be one of the reserves in a basket currency.## Ethereum ERC-20 \nThe Verus-Ethereum Bridge makes it possible for currencies and tokens to be send over to Ethereum, and back to Verus. It is a true non-custodial bridge. All tokens and currencies flowing over the bridge are never in anyone\u2019s custody, and are proven and verified by consensus rules. [Everything on the Verus-Ethereum Bridge here.](/eth-bridge/)Any currency and token, on Verus or any other PBaaS-blockchain, can be exported to Ethereum as an ERC-20. They can then be used in the Ethereum ecosystem.Also, any already existing ERC-20 token can be mapped one-to-one as a Verus currency. Meaning any ERC-20 token can live on the Verus blockchain (or any other PBaaS-chain) and take advantage of all the L1 features.", "./raw_text_input_docs/README_currencies.md"]]], [["User:: I'm interested in performing some DeFi operations using Verus API commands. Can you show me how to estimate conversion prices, get currency converters, convert currencies, and preconvert to new currencies?", "AI Assistant:: Verus provides an API that allows you to perform various DeFi (Decentralized Finance) operations. Here are some examples of how you can use Verus API commands to perform these operations:\n\n**Estimating Conversion Prices:**\nYou can use the `estimateconversion` API to estimate the price of a conversion from one currency to another. For example, to estimate the price of converting 1000 VRSCTEST to VETH via the bridge.veth converter, you can use the following command:\n```json\n./verus -chain=VRSCTEST estimateconversion '{\n\"currency\":\"vrsctest\",\n\"convertto\":\"veth\",\n\"via\":\"bridge.veth\",\n\"amount\":1000\n}'\n```\n**Getting Currency Converters:**\nThe `getcurrencyconverters` API retrieves a list of currencies that have at least 1000 VRSC in reserve, are greater than 10% VRSC reserve ratio, and have all listed currencies as reserves. For example, to get the converters for BTC and ETH, you can use the following command:\n```json\n./verus -chain=VRSCTEST getcurrencyconverters btc eth\n```\n**Converting Currencies:**\nYou can use the `sendcurrency` API to convert one currency to another. For example, to convert 10 VRSCTEST to VRSC-BTC, you can use the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*i\" '[{\n\"address\":\"bob@\",\n\"amount\":10,\n\"convertto\":\"VRSC-BTC\"\n}]'\n```\nYou can also convert VRSCTEST to another reserve, such as BTC, through a basket currency, VRSC-BTC:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n\"address\":\"bob@\",\n\"amount\":10,\n\"convertto\":\"BTC\",\n\"via\":\"VRSC-BTC\"\n}]'\n```\n**Preconverting to New Currencies:**\nYou can use the `sendcurrency` API to preconvert to a new currency before it is active. For example, to preconvert 10 VRSCTEST to a new currency, NEWCOIN, you can use the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n\"address\":\"alice@\",\n\"amount\":10,\n\"convertto\":\"NEWCOIN\",\n\"preconvert\":true,\n\"refundto\":\"alice@\"\n}]'\n```\nDo you have any questions about these examples or would you like more information on using Verus API commands for DeFi operations?"], "AI Assistant", "", "N/A", [["How can I perform various DeFi operations, such as estimating conversion prices, getting currency converters, converting currencies, and preconverting to new currencies, using Verus API commands?", "Verus provides an API that allows you to perform various DeFi (Decentralized Finance) operations. Here are some examples of how you can use Verus API commands to perform these operations:\n\n**Estimating Conversion Prices:**\nYou can use the `estimateconversion` API to estimate the price of a conversion from one currency to another. For example, to estimate the price of converting 1000 VRSCTEST to VETH via the bridge.veth converter, you can use the following command:\n```json\n./verus -chain=VRSCTEST estimateconversion '{\n  \"currency\":\"vrsctest\",\n  \"convertto\":\"veth\",\n  \"via\":\"bridge.veth\",\n  \"amount\":1000\n}'\n```\n**Getting Currency Converters:**\nThe `getcurrencyconverters` API retrieves a list of currencies that have at least 1000 VRSC in reserve, are greater than 10% VRSC reserve ratio, and have all listed currencies as reserves. For example, to get the converters for BTC and ETH, you can use the following command:\n```json\n./verus -chain=VRSCTEST getcurrencyconverters btc eth\n```\n**Converting Currencies:**\nYou can use the `sendcurrency` API to convert one currency to another. For example, to convert 10 VRSCTEST to VRSC-BTC, you can use the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*i\" '[{\n  \"address\":\"bob@\",\n  \"amount\":10,\n  \"convertto\":\"VRSC-BTC\"\n}]'\n```\nYou can also convert VRSCTEST to another reserve, such as BTC, through a basket currency, VRSC-BTC:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"bob@\",\n  \"amount\":10,\n  \"convertto\":\"BTC\",\n  \"via\":\"VRSC-BTC\"\n}]'\n```\n**Preconverting to New Currencies:**\nYou can use the `sendcurrency` API to preconvert to a new currency before it is active. For example, to preconvert 10 VRSCTEST to a new currency, NEWCOIN, you can use the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"alice@\",\n  \"amount\":10,\n  \"convertto\":\"NEWCOIN\",\n  \"preconvert\":true,\n  \"refundto\":\"alice@\"\n}]'\n```\nThese are just a few examples of how you can use Verus API commands to perform DeFi operations. By using these commands, you can easily convert between different currencies, estimate conversion prices, and preconvert to new currencies.", "# API commands\nAll functionality is easily accessible by doing API commands. Here are a few examples:## Converting (DeFi)### Estimate conversion price\nThe ``estimateconversion`` API estimates what you might receive for a certain conversion.Example:\n``` json\n./verus -chain=VRSCTEST estimateconversion '{\n  \"currency\":\"vrsctest\",\n  \"convertto\":\"veth\",\n  \"via\":\"bridge.veth\",\n  \"amount\":1000\n}'\n```Example:\n``` json\n./verus -chain=VRSCTEST estimateconversion '{\n  \"currency\":\"vrsctest\",\n  \"convertto\":\"bridge.veth\",\n  \"amount\":500\n}'\n```### Get currency converters\nThe ``getcurrencyconverters`` API retrieves all currencies that have at least 1000 VRSC in reserve, are greater than 10% VRSC reserve ratio, and have all listed currencies as reserves.Example ``btc`` and ``eth``:\n``` json\n./verus -chain=VRSCTEST getcurrencyconverters btc eth\n```### Converting VRSCTEST to basket currency\nConverting VRSCTEST to a basket currency, VRSC-BTC, using IDs as a funding source:\n``` json\n./verus -chain=VRSCTEST sendcurrency \"*i\" '[{\n  \"address\":\"bob@\",\n  \"amount\":10,\n  \"convertto\":\"VRSC-BTC\"\n}]'\n```### Converting VRSCTEST to BTC via basket currency\nConverting VRSCTEST to another reserve, BTC through a basket currency, VRSC-BTC:\n``` json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"bob@\",\n  \"amount\":10,\n  \"convertto\":\"BTC\",\n  \"via\":\"VRSC-BTC\"\n}]'\n```\n### Preconverting\nPreconverting to new currency, NEWCOIN, before it is active:\n``` json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"alice@\",\n  \"amount\":10,\n  \"convertto\":\"NEWCOIN\",\n  \"preconvert\":true,\n  \"refundto\":\"alice@\"\n}]'\n```", "./raw_text_input_docs/sendcurrency-examples.md"]]], [["User:: I've been playing around with VerusPay and I'm trying to understand more about the flags that can be set on an invoice. Can you explain what these flags are and what they indicate about the invoice's properties and behavior?", "AI Assistant:: VerusPay invoices can have various flags set to define their properties and behavior. These flags are used to indicate whether an invoice is valid, what kind of payments it accepts, and under what conditions. Here's a breakdown of the different flags and their meanings:\n\n**VERUSPAY_INVALID (0)**: This flag indicates that the invoice is invalid and should not be processed.\n\n**VERUSPAY_VALID (1)**: This flag must be set for the invoice to be considered actionable, indicating that the invoice is valid and can be processed.\n\n**VERUSPAY_ACCEPTS_CONVERSION (2)**: If this flag is set, the invoice accepts payments in different currencies, with conversion to the invoice's requested currency. This requires a max estimated slippage value to be specified.\n\n**VERUSPAY_ACCEPTS_NON_VERUS_SYSTEMS (4)**: This flag indicates that payments from non-Verus blockchain systems are accepted. If set, the invoice must specify which systems are accepted.\n\n**VERUSPAY_EXPIRES (8)**: This flag determines that the invoice has an expiry condition, meaning it must be paid before a specific Verus blockchain height is reached. An expiry height must be set if this flag is set.\n\n**VERUSPAY_ACCEPTS_ANY_DESTINATION (16)**: If this flag is set, the invoice can accept payments to any destination. In this case, the destination field in the invoice must be left blank.\n\n**VERUSPAY_ACCEPTS_ANY_AMOUNT (32)**: This flag indicates that the invoice can be paid with any amount, making it useful for donations or when the exact payment amount is not fixed. If set, the amount field in the invoice must be left blank.\n\n**VERUSPAY_EXCLUDES_VERUS_BLOCKCHAIN (64)**: If set, the invoice cannot be paid on the VRSC or VRSCTEST blockchains.\n\n**VERUSPAY_IS_TESTNET (128)**: This flag marks the invoice as only valid on VRSCTEST and/or testnet PBaaS blockchains, and establishes that all currencies/identities referenced within the invoice exist only on testnet.\n\nThese flags provide flexibility and customization options for VerusPay invoices, allowing them to accommodate different use cases and payment scenarios.\n\nDo you have any further questions about these flags or how to use them in VerusPay invoices?"], "AI Assistant", "", "N/A", [["What are the different flags that can be set on a VerusPay invoice, and what do they indicate about the invoice's properties and behavior?", "VerusPay invoices can have various flags set to define their properties and behavior. These flags are used to indicate whether an invoice is valid, what kind of payments it accepts, and under what conditions. Here's a breakdown of the different flags and their meanings:\n\n**VERUSPAY_INVALID (0)**: This flag indicates that the invoice is invalid and should not be processed.\n\n**VERUSPAY_VALID (1)**: This flag must be set for the invoice to be considered actionable, indicating that the invoice is valid and can be processed.\n\n**VERUSPAY_ACCEPTS_CONVERSION (2)**: If this flag is set, the invoice accepts payments in different currencies, with conversion to the invoice's requested currency. This requires a max estimated slippage value to be specified.\n\n**VERUSPAY_ACCEPTS_NON_VERUS_SYSTEMS (4)**: This flag indicates that payments from non-Verus blockchain systems are accepted. If set, the invoice must specify which systems are accepted.\n\n**VERUSPAY_EXPIRES (8)**: This flag determines that the invoice has an expiry condition, meaning it must be paid before a specific Verus blockchain height is reached. An expiry height must be set if this flag is set.\n\n**VERUSPAY_ACCEPTS_ANY_DESTINATION (16)**: If this flag is set, the invoice can accept payments to any destination. In this case, the destination field in the invoice must be left blank.\n\n**VERUSPAY_ACCEPTS_ANY_AMOUNT (32)**: This flag indicates that the invoice can be paid with any amount, making it useful for donations or when the exact payment amount is not fixed. If set, the amount field in the invoice must be left blank.\n\n**VERUSPAY_EXCLUDES_VERUS_BLOCKCHAIN (64)**: If set, the invoice cannot be paid on the VRSC or VRSCTEST blockchains.\n\n**VERUSPAY_IS_TESTNET (128)**: This flag marks the invoice as only valid on VRSCTEST and/or testnet PBaaS blockchains, and establishes that all currencies/identities referenced within the invoice exist only on testnet.\n\nThese flags provide flexibility and customization options for VerusPay invoices, allowing them to accommodate different use cases and payment scenarios.", "- **VERUSPAY_INVALID (0)**: Indicates that the invoice is invalid. This default state can be used to signify that an invoice should not be processed.\n- **VERUSPAY_VALID (1)**: Signifies that the invoice is valid and can be processed. This flag must be set for the invoice to be considered actionable.\n- **VERUSPAY_ACCEPTS_CONVERSION (2)**: Specifies that the invoice accepts currency conversions. This allows payments in different currencies, with conversion to the invoice's requested currency. If an invoice accepts conversion, it requires a max estimated slippage value.\n- **VERUSPAY_ACCEPTS_NON_VERUS_SYSTEMS (4)**: Indicates that payments from non-Verus blockchain systems are accepted. If this flag is set, specifying accepted systems is required.\n- **VERUSPAY_EXPIRES (8)**: Determines that the invoice has an expiry condition. If set, the invoice must be paid before a specific Verus blockchain height is reached, and an expiry height must be set.\n- **VERUSPAY_ACCEPTS_ANY_DESTINATION (16)**: Allows the invoice to accept payments to any destination. If set, the destination field in the invoice must be left blank.\n- **VERUSPAY_ACCEPTS_ANY_AMOUNT (32)**: Indicates that the invoice can be paid with any amount. This is useful for donations or when the exact payment amount is not fixed. If set, the amount field in the invoice must be left blank.\n- **VERUSPAY_EXCLUDES_VERUS_BLOCKCHAIN (64)**: If set, invoice cannot be paid on VRSC/VRSCTEST.\n- **VERUSPAY_IS_TESTNET (128)**: Marks the invoice as only valid on VRSCTEST and/or testnet PBaaS blockchains, and establishes that all currencies/identities referenced within the invoice exist only on testnet.## Serialization and Deserialization![veruspay-invoice-bytes](/images/veruspay-invoice-bytes.svg)", "./raw_text_input_docs/invoices.md"]]], [["User:: Hi, I'm interested in learning more about launching currencies on Verus, a Public Blockchain as a Service (PBaaS) protocol. Can you explain the key benefits and characteristics of doing so, and how basket currencies (e.g. liquidity pools) work on Verus?", "AI Assistant:: Launching currencies on Verus offers several benefits over other EVM-like protocols. These benefits include faster, cheaper, and more secure launches, with no coding involved. There are two types of currencies that can be launched on Verus: basket currencies (e.g. liquidity pools) and simple token currencies. Both types can be issued in a decentralized or centralized manner, with minting and burning capabilities.\n\nLet me dive deeper into basket currencies, also known as liquidity pools. They function similarly to automated market makers (AMMs) and have reserves, which can be any currency or token on the Verus network. These reserves can also be bridged from other networks. Basket currencies have a dynamic supply, which is dependent on the amount of conversions into or out of the basket currency. The supply is minted when users convert into the basket currency and burned when users convert out of it.\n\nA basket currency can have between 1 and 10 currencies in its reserves, and its supply is directly linked to the reserve ratio, also known as the weight. The reserve ratio determines the volatility of the basket currency when users convert into or out of it. A higher reserve ratio means that the basket currency is more stable, while a lower reserve ratio makes it more volatile. The value of the basket currency is directly tied to the value of its reserves and the reserve ratio.\n\nAdditionally, Verus also allows for the creation of subIDs, which are powerful objects that are similar to VerusIDs but cannot launch blockchains or currencies. SubIDs can be created from any currency launched on Verus, offering a range of possibilities for decentralized applications and use cases.\n\nDo you have any further questions about launching currencies on Verus, or how basket currencies work on the platform?"], "AI Assistant", "", "N/A", [["What are the key benefits and characteristics of launching currencies on Verus, a Public Blockchain as a Service (PBaaS) protocol, and how do basket currencies (e.g. liquidity pools) work on Verus?", "Launching currencies on Verus, a Public Blockchain as a Service (PBaaS) protocol, offers several benefits over other EVM-like protocols. These benefits include faster, cheaper, and more secure launches, with no coding involved. There are two types of currencies that can be launched on Verus: basket currencies (e.g. liquidity pools) and simple token currencies. Both types can be issued in a decentralized or centralized manner, with minting and burning capabilities.\n\nBasket currencies, also known as liquidity pools, are a type of currency that can be launched on Verus. They function similarly to automated market makers (AMMs) and have reserves, which can be any currency or token on the Verus network. These reserves can also be bridged from other networks. Basket currencies have a dynamic supply, which is dependent on the amount of conversions into or out of the basket currency. The supply is minted when users convert into the basket currency and burned when users convert out of it.\n\nA basket currency can have between 1 and 10 currencies in its reserves, and its supply is directly linked to the reserve ratio, also known as the weight. The reserve ratio determines the volatility of the basket currency when users convert into or out of it. A higher reserve ratio means that the basket currency is more stable, while a lower reserve ratio makes it more volatile. The value of the basket currency is directly tied to the value of its reserves and the reserve ratio.\n\nIn addition to basket currencies, Verus also allows for the creation of subIDs, which are powerful objects that are similar to VerusIDs but cannot launch blockchains or currencies. SubIDs can be created from any currency launched on Verus, offering a range of possibilities for decentralized applications and use cases.", "# Introduction\nLaunching currencies on Verus, and any other PBaaS-chain (Public Blockchains as a Service), is better, faster, cheaper and more secure than any EVM-like protocol out there. There is no coding involved.There are two types of currencies that can be launched with the Verus Protocol. Basket currencies (e.g. liquidity pools) and simple token currencies. Both can be issued decentralized, or centralized with minting and burning capabilities.When a currency is launched, subIDs can be created from it. SubIDs are powerful objects on Verus (and other PBaaS-blockchains). They are exactly the same as [VerusIDs](/verusid/), yet can not launch blockchains or currencies.## Basket currencies (e.g. liquidity pools)\n![image-basket-currencies](/images/currencies-reserves.png)Basket currencies function like automated market makers (AMMs), they have reserves. A reserve can be any currency or token on the Verus network (also bridged). Have a look at the simplified image. If anyone has currency X or Y, they can convert to the basket currency, or convert from reserve to reserve. If anyone has the basket currency, they can go to currency X or Y. A basket currency can have 1 and up to 10 currencies in its reserves.The basket currency supply is dynamic, depending on how much is converted to the basket currency (supply minted), or back to its reserve(s) (supply burned).A basket currency can be 100% backed by its reserves, 5%, or anything in between. This is called the reserve ratio, or the weight. The lower the reserve ratio, the more volatile the currency is when people are converting into or out of the basket currency. The value of the basket currency is directly linked to what is in the reserves and what the reserve ratio is.", "./raw_text_input_docs/README_currencies.md"]]], [["User:: I've been experimenting with VerusIDs and I'm interested in learning more about locking them. Can you explain how to use Verus to lock a VerusID with a time lock or a DelayLock, and what are the implications of doing so?", "AI Assistant:: Locking a VerusID can be a useful feature to add an extra layer of security or to implement specific use cases. I'd be happy to walk you through the process.\n\nVerus provides a way to lock a VerusID, which prevents the associated funds from being spent until a certain condition is met. There are two types of locks: a time lock and a DelayLock.\n\n**Time Lock:**\nA time lock allows you to specify a block number at which the lock will be released. To set a time lock, you can use the `setidentitytimelock` command in the Verus command-line interface. For example, to lock a VerusID for approximately 1 year, you can use the following command:\n```json\nrun setidentitytimelock \"myid@\"\n'{\n\"unlockatblock\":1508994\n}'\n```\nReplace `myid@` with your own VerusID. This will lock the funds associated with the VerusID until the specified block number is reached.\n\n**DelayLock:**\nA DelayLock is similar to a time lock, but instead of specifying a specific block number, you specify a delay period in blocks. When you request an unlock, the funds will not be available until the delay period has passed. To set a DelayLock, you can use the `setidentitytimelock` command with the `setunlockdelay` option. For example, to set a DelayLock of 1 week (10,080 blocks), you can use the following command:\n```json\nrun setidentitytimelock \"myid@\"\n'{\n\"setunlockdelay\":10080\n}'\n```\nReplace `myid@` with your own VerusID. This will lock the funds associated with the VerusID, and when you request an unlock, you will have to wait for 1 week (or 10,080 blocks) before the funds can be spent again.\n\n**Requesting an Unlock:**\nOnce you have set a time lock or DelayLock, you can request an unlock using the same `setidentitytimelock` command. However, you will have to wait for the specified delay period or until the specified block number is reached before the funds can be spent again.\n\n**Important Note:**\nRemember that you can always revoke and recover a locked VerusID if needed.\n\nDo you have any further questions about locking VerusIDs or the implications of doing so?"], "AI Assistant", "", "N/A", [["How do I use Verus to lock a VerusID with a time lock or a DelayLock, and what are the implications of doing so?", "Verus provides a way to lock a VerusID, which prevents the associated funds from being spent until a certain condition is met. There are two types of locks: a time lock and a DelayLock.\n\n**Time Lock:**\nA time lock allows you to specify a block number at which the lock will be released. To set a time lock, you can use the `setidentitytimelock` command in the Verus command-line interface. For example, to lock a VerusID for approximately 1 year, you can use the following command:\n```json\nrun setidentitytimelock \"myid@\" \n'{\n  \"unlockatblock\":1508994\n}'\n```\nReplace `myid@` with your own VerusID. This will lock the funds associated with the VerusID until the specified block number is reached.\n\n**DelayLock:**\nA DelayLock is similar to a time lock, but instead of specifying a specific block number, you specify a delay period in blocks. When you request an unlock, the funds will not be available until the delay period has passed. To set a DelayLock, you can use the `setidentitytimelock` command with the `setunlockdelay` option. For example, to set a DelayLock of 1 week (10,080 blocks), you can use the following command:\n```json\nrun setidentitytimelock \"myid@\" \n'{\n  \"setunlockdelay\":10080\n}'\n```\nReplace `myid@` with your own VerusID. This will lock the funds associated with the VerusID, and when you request an unlock, you will have to wait for 1 week (or 10,080 blocks) before the funds can be spent again.\n\n**Requesting an Unlock:**\nOnce you have set a time lock or DelayLock, you can request an unlock using the same `setidentitytimelock` command. However, you will have to wait for the specified delay period or until the specified block number is reached before the funds can be spent again.\n\n**Important Note:**\nRemember that you can always revoke and recover a locked VerusID if needed.", "- Under ``unlockatblock`` you put ``1508994``\n- Change ``myid@`` with your own VerusIDSo in our example your VerusID is locked for approximately for 1 year. After that period of time the funds can be spent again.``` json\nrun setidentitytimelock \"myid@\" \n'{\n  \"unlockatblock\":1508994\n}'\n```You can copy and paste this code snippet into the commandline interface of Verus Desktop and edit the necessary inputs for your needs.:::tip Revoke & Recover\nRemember: you can always revoke and recover a locked VerusID.\n:::## Vault with DelayLock\n![image-delaylock](/images/delaylock.png)\nNow let's put a DelayLock on a VerusID. This means that you lock the identity, and when you request the identity to be unlocked, a predetermined number of blocks have to pass before you can actually spend the funds again.### Set the DelayLock\nLet's say you want to put a DelayLock of 1 week. 1 week is ``10,080`` blocks (1440x7). This will lock the identity, and when you request an unlock, it takes 1 week (or 10,080 blocks) before the funds can be spent again.- Under ``setunlockdelay`` you put ``10080``\n- Change ``myid@`` with your own VerusID``` json\nrun setidentitytimelock \"myid@\" \n'{\n  \"setunlockdelay\":10080\n}'\n```You can copy and paste this code snippet into the commandline interface of Verus Desktop and edit the necessary inputs for your needs.:::tip Revoke & Recover\nRemember: you can always revoke and recover a locked VerusID.\n:::### Request an unlock\nAbove you locked a VerusID with a DelayLock. Now let's request an unlock. When an unlock has been requested you have to wait the predetermined number of blocks before you can spend the funds again.", "./raw_text_input_docs/setup-vault-v2.md"]]], [["User:: I'm interested in creating a PBaaS blockchain, but I'm not sure what options are available or how to choose the right combination for my specific use case. Can you help me understand my options and make an informed decision?", "AI Assistant:: Defining a PBaaS blockchain can be a complex process, but I'm here to break it down for you. When creating a PBaaS blockchain, there are several options to consider, and I'll walk you through each of them. These options are combined in the `options` parameter and can be used in different ways to create a blockchain that meets your specific needs.\n\nHere's a breakdown of the available options:\n\n1. **OPTION_FRACTIONAL**: This option allows reserve conversion using base calculations when set. This can be useful for certain types of conversions or calculations on your blockchain.\n\n2. **OPTION_ID_ISSUANCE**: If set, this option makes it so that IDs may only be created by the controlling ID. This can be useful for permissioned or controlled environments.\n\n3. **OPTION_ID_STAKING**: With this option, all IDs on the chain stake equally, rather than using value-based staking. This can be useful for fairness or equality in staking.\n\n4. **OPTION_ID_REFERRALS**: If set, this option enables referrals on the chain.\n\n5. **OPTION_ID_REFERRALREQUIRED**: If set, this option requires referrals on the chain.\n\n6. **OPTION_TOKEN**: If set, this option makes the blockchain a token, rather than a native currency.\n\n7. **OPTION_SINGLECURRENCY**: This option can be used to restrict a PBaaS chain or gateway to a single currency.\n\n8. **OPTION_GATEWAY**: If set, this option routes external currencies.\n\n9. **OPTION_PBAAS**: This option defines a PBaaS chain.\n\n10. **OPTION_GATEWAY_CONVERTER**: This option makes the blockchain the default converter for a specific PBaaS gateway and publishes prices.\n\n11. **OPTION_GATEWAY_NAMECONTROLLER**: If not set on a gateway, top-level ID and currency registration happen on the launch chain.\n\n12. **OPTION_NFT_TOKEN**: This option creates a single satoshi NFT token, which tokenizes control over the root ID.\n\nWhen choosing the right combination of options, consider the specific use case and requirements for your blockchain. You can combine these options in different ways to create a blockchain that meets your needs.\n\nAdditionally, it's important to note that to create a blockchain of a specific name, you need a VerusID of the same name. The controller of this VerusID is the only one who can create a blockchain of that name, and they can only do so once.\n\nIf you're new to setting up a blockchain launch, the Verus community is happy to assist you. You can reach out to them on the Verus Discord #pbaas-development channel for help.\n\nDo you have any specific questions about these options or how to choose the right combination for your use case?"], "AI Assistant", "", "N/A", [["What are the options for defining a PBaaS blockchain, and how do I choose the right combination for my specific use case?", "When defining a PBaaS blockchain, there are several options to consider. These options are combined in the `options` parameter and can be used in different ways to create a blockchain that meets your specific needs. Here's a breakdown of the available options:\n\n1. **OPTION_FRACTIONAL**: This option allows reserve conversion using base calculations when set. This can be useful for certain types of conversions or calculations on your blockchain.\n\n2. **OPTION_ID_ISSUANCE**: If set, this option makes it so that IDs may only be created by the controlling ID. This can be useful for permissioned or controlled environments.\n\n3. **OPTION_ID_STAKING**: With this option, all IDs on the chain stake equally, rather than using value-based staking. This can be useful for fairness or equality in staking.\n\n4. **OPTION_ID_REFERRALS**: If set, this option enables referrals on the chain.\n\n5. **OPTION_ID_REFERRALREQUIRED**: If set, this option requires referrals on the chain.\n\n6. **OPTION_TOKEN**: If set, this option makes the blockchain a token, rather than a native currency.\n\n7. **OPTION_SINGLECURRENCY**: This option can be used to restrict a PBaaS chain or gateway to a single currency.\n\n8. **OPTION_GATEWAY**: If set, this option routes external currencies.\n\n9. **OPTION_PBAAS**: This option defines a PBaaS chain.\n\n10. **OPTION_GATEWAY_CONVERTER**: This option makes the blockchain the default converter for a specific PBaaS gateway and publishes prices.\n\n11. **OPTION_GATEWAY_NAMECONTROLLER**: If not set on a gateway, top-level ID and currency registration happen on the launch chain.\n\n12. **OPTION_NFT_TOKEN**: This option creates a single satoshi NFT token, which tokenizes control over the root ID.\n\nWhen choosing the right combination of options, consider the specific use case and requirements for your blockchain. You can combine these options in different ways to create a blockchain that meets your needs.\n\nAdditionally, it's important to note that to create a blockchain of a specific name, you need a VerusID of the same name. The controller of this VerusID is the only one who can create a blockchain of that name, and they can only do so once.\n\nIf you're new to setting up a blockchain launch, the Verus community is happy to assist you. You can reach out to them on the Verus Discord #pbaas-development channel for help.", "# Defining a PBaaS-blockchain::: warning Information here is not complete. Need help setting up a blockchain launch? \ud83e\udd14\n[Go to the Verus Discord #pbaas-development channel. The community is happy to assist!](https://www.verus.io/discord) \n:::There are many options to choose from when defining your blockchain. Combine them in the ``options`` parameter for different use cases.| # | Options | Details |\n| - |:-----|:-----|\n| 1 | OPTION_FRACTIONAL | Allows reserve conversion using base calculations when set |\n| 2 | OPTION_ID_ISSUANCE | Clear is permissionless, if set, IDs may only be created by controlling ID |\n| 4 | OPTION_ID_STAKING | All IDs on chain stake equally, rather than value-based staking |\n| 8 | OPTION_ID_REFERRALS | If set, this chain supports referrals |\n| 16 | OPTION_ID_REFERRALREQUIRED | If set, this chain requires referrals |\n| 32 | OPTION_TOKEN | If set, this is a token, not a native currency |\n| 64 | OPTION_SINGLECURRENCY | For PBaaS chains or gateways to potentially restrict to single currency |\n| 128 | OPTION_GATEWAY | If set, this routes external currencies |\n| 256 | OPTION_PBAAS | This is a PBaaS chain definition|\n| 512 | OPTION_GATEWAY_CONVERTER | This means that for a specific PBaaS gateway, this is the default converter and will publish prices |\n| 1024 | OPTION_GATEWAY_NAMECONTROLLER | When not set on a gateway, top level ID and currency registration happen on launch chain |\n| 2048 | OPTION_NFT_TOKEN | Single satoshi NFT token, tokenizes control over the root ID |## VerusID Namespace\nTo create a blockchain of a specific name, you need a VerusID of the same name. The controller of this VerusID is the only one who can create a blockchain of that name, and they can only do so once.## Examples of blockchain launches", "./raw_text_input_docs/define-pbaas.md"]]], [["User:: I'm trying to understand the different transaction scenarios in Verus, and how they affect the visibility of information. Can you explain the different scenarios, including public-to-public, public-to-private, private-to-public, and private-to-private transactions, and what information is visible or not visible in each scenario?", "AI Assistant:: I'd be happy to break down each transaction scenario in Verus for you.\n\nIn Verus, there are four different transaction scenarios: public-to-public, public-to-private, private-to-public, and private-to-private. Each scenario has its own characteristics in terms of what information is visible or not visible to the public.\n\n**Public-to-Public Transactions:**\nIn a public-to-public transaction, a sender using a `VerusID@`, `R-address`, or `i-address` sends funds to a recipient using a `VerusID@`, `R-address`, or `i-address`. In this scenario, both the sender's address and the amount sent are visible, as well as the recipient's address(es) and received amount(s). So, all information about the transaction is publicly visible.\n\n**Public-to-Private Transactions:**\nIn a public-to-private transaction, a sender using a `VerusID@`, `R-address`, or `i-address` sends funds to a recipient using a `z-address` or `VerusID@:private`. In this scenario, the sender's address and the amount sent are visible, but the recipient's address(es) and received amount(s) are not visible. However, it is still possible to correlate transactions by time and amounts between public and private addresses, potentially linking two public addresses based on transaction patterns. So, while the recipient's information is private, there's still some potential for analysis.\n\n**Private-to-Public Transactions:**\nIn a private-to-public transaction, a sender using a `z-address` sends funds to a recipient using a `VerusID@`, `R-address`, or `i-address`. In this scenario, the sender's address and the amount sent are not visible, but the recipient's address(es) and received amount(s) are visible. Like public-to-private transactions, there remains a possibility of correlating transactions based on timing and value, potentially linking two public addresses. So, in this case, the sender's information is private, but the recipient's is not.\n\n**Private-to-Private Transactions:**\nIn a private-to-private transaction, a sender using a `z-address` sends funds to a recipient using a `z-address` or `VerusID@:private`. In this scenario, both the sender's address and the amount sent are not visible, as well as the recipient's address(es) and received amount(s). This provides the highest level of privacy, as no information about the transaction is visible to the public.\n\nIt's important to note that `z-addresses` can only hold the native blockchain currency and not simple token currencies or basket currencies.\n\nDo you have any more questions about these transaction scenarios or how they impact privacy in Verus?"], "AI Assistant", "", "N/A", [["Explain the different transaction scenarios in Verus, including public-to-public, public-to-private, private-to-public, and private-to-private transactions, and what information is visible or not visible in each scenario?", "In Verus, there are four different transaction scenarios: public-to-public, public-to-private, private-to-public, and private-to-private. Each scenario has its own characteristics in terms of what information is visible or not visible to the public.\n\n**Public-to-Public Transactions:**\nIn a public-to-public transaction, a sender using a `VerusID@`, `R-address`, or `i-address` sends funds to a recipient using a `VerusID@`, `R-address`, or `i-address`. In this scenario, both the sender's address and the amount sent are visible, as well as the recipient's address(es) and received amount(s).\n\n**Public-to-Private Transactions:**\nIn a public-to-private transaction, a sender using a `VerusID@`, `R-address`, or `i-address` sends funds to a recipient using a `z-address` or `VerusID@:private`. In this scenario, the sender's address and the amount sent are visible, but the recipient's address(es) and received amount(s) are not visible. However, it is still possible to correlate transactions by time and amounts between public and private addresses, potentially linking two public addresses based on transaction patterns.\n\n**Private-to-Public Transactions:**\nIn a private-to-public transaction, a sender using a `z-address` sends funds to a recipient using a `VerusID@`, `R-address`, or `i-address`. In this scenario, the sender's address and the amount sent are not visible, but the recipient's address(es) and received amount(s) are visible. Like public-to-private transactions, there remains a possibility of correlating transactions based on timing and value, potentially linking two public addresses.\n\n**Private-to-Private Transactions:**\nIn a private-to-private transaction, a sender using a `z-address` sends funds to a recipient using a `z-address` or `VerusID@:private`. In this scenario, both the sender's address and the amount sent are not visible, as well as the recipient's address(es) and received amount(s). This provides the highest level of privacy, as no information about the transaction is visible to the public.\n\nIt's important to note that `z-addresses` can only hold the native blockchain currency and not simple token currencies or basket currencies.", "::: warning Only native currencies\nZ-addresses can only contain the native blockchain currency. Simple token currencies or basket currencies can **not** be held in a z-address.\n:::\n\n# Transaction scenarios\n\n## Public-to-public\n``VerusID@``, ``R-address``, or ``i-address`` \u27a1\ufe0f ``VerusID@``, ``R-address``, or ``i-address``\n\n- Sender's address and the amount sent are visible \n- Recipient's address(es) and received amount(s) are visible\n   \n## Public-to-private\n``VerusID@``, ``R-address``, or ``i-address`` \u27a1\ufe0f ``z-address`` or ``VerusID@:private``\n\n- Sender's address and the amount sent are visible\n- Recipient's address(es) and received amount(s) are **not** visible\n\n*Note: Correlating transactions by time and amounts between public and private addresses is still possible, potentially linking two public addresses based on transaction patterns.*\n\n## Private-to-public\n``z-address`` \u27a1\ufe0f ``VerusID@``, ``R-address``, or ``i-address``\n\n- Sender's address and the amount sent are **not** visible \n- Recipient's address(es) and received amount(s) are visible\n\n*Note: Like public-to-private transactions, there remains a possibility of correlating transactions based on timing and value, potentially linking two public addresses.*\n\n## Private-to-private\n``z-address`` \u27a1\ufe0f ``z-address`` or ``VerusID@:private``\n\n- Sender's address and the amount sent are **not** visible \n- Recipient's address(es) and received amount(s) are **not** visible", "./raw_text_input_docs/README.md"]]], [["User:: I'm really interested in learning more about Verus. Can you tell me what it is, and what are its key features and benefits for creators, organizations, and users?", "AI Assistant:: Verus is an open-source, decentralized blockchain protocol that offers a range of features and benefits for creators, organizations, and users. At its core, Verus is a multichain protocol that focuses on scalability, security, and decentralization. Here are some of its key features and benefits:\n\n**Consensus Mechanism:** Verus uses a hybrid consensus mechanism that combines proof-of-work (PoW) and proof-of-stake (PoS) to validate transactions and secure the network.\n\n**Rent-Free Blockchain Tools:** Verus provides rent-free blockchain tools for creators and organizations to build products, services, and systems. This means that users can build and deploy their own blockchain-based projects without having to pay expensive fees or rent.\n\n**Scalability:** Verus is designed to scale to meet global demand, making it an ideal choice for large-scale blockchain projects.\n\n**Security:** Verus has been proven to be resistant to 51% hash attacks, ensuring the security and integrity of the network.\n\n**Decentralization:** Verus is a community-built protocol, with all coins in circulation fairly mined and staked. This decentralization ensures that no single entity has control over the network.\n\n**Public Blockchains as a Service (PBaaS):** Verus offers PBaaS, which allows anyone to launch scalable, fully interoperable, customizable, and independent blockchains for public or private use. This feature enables users to create their own blockchain-based projects with ease.\n\n**Launch Tokens and Basket Currencies:** Verus allows users to launch tokens and basket currencies (such as liquidity pools) on top of blockchains for any use case. This feature enables users to create their own tokens and currencies with ease.\n\n**Protocol-Level DeFi and Smart Launch Options:** Verus has built-in DeFi and smart launch options, which enable users to create markets and raise funding for their projects.\n\n**Self-Sovereign Digital Identities and Namespaces (VerusID):** VerusID is a protocol-level feature that provides self-sovereign digital identities and namespaces. This feature enables builders, communities, businesses, and organizations to have full control over their digital identities and namespaces.\n\n**Aligned Incentives:** Verus has aligned incentives with the miners and stakers of the worldwide network, making it one of the most secure protocols with opportunities to earn.\n\n**Low-Cost Deployment:** Verus enables users to launch blockchains, tokens, liquidity pools, identities, and more without requiring any coding knowledge. Users can deploy their projects using simple API commands, saving money on expensive blockchain developers and infrastructure.\n\nOverall, Verus is a powerful and flexible blockchain protocol that provides a range of features and benefits for creators, organizations, and users. Its focus on scalability, security, and decentralization makes it an ideal choice for large-scale blockchain projects.\n\nDo you have any further questions about Verus, its features, or its benefits?"], "AI Assistant", "", "N/A", [["What is Verus, and what are its key features and benefits for creators, organizations, and users?", "Verus is an open-source, decentralized blockchain protocol that offers a range of features and benefits for creators, organizations, and users. At its core, Verus is a multichain protocol that focuses on scalability, security, and decentralization. Here are some of its key features and benefits:\n\n**Consensus Mechanism:** Verus uses a hybrid consensus mechanism that combines proof-of-work (PoW) and proof-of-stake (PoS) to validate transactions and secure the network.\n\n**Rent-Free Blockchain Tools:** Verus provides rent-free blockchain tools for creators and organizations to build products, services, and systems. This means that users can build and deploy their own blockchain-based projects without having to pay expensive fees or rent.\n\n**Scalability:** Verus is designed to scale to meet global demand, making it an ideal choice for large-scale blockchain projects.\n\n**Security:** Verus has been proven to be resistant to 51% hash attacks, ensuring the security and integrity of the network.\n\n**Decentralization:** Verus is a community-built protocol, with all coins in circulation fairly mined and staked. This decentralization ensures that no single entity has control over the network.\n\n**Public Blockchains as a Service (PBaaS):** Verus offers PBaaS, which allows anyone to launch scalable, fully interoperable, customizable, and independent blockchains for public or private use. This feature enables users to create their own blockchain-based projects with ease.\n\n**Launch Tokens and Basket Currencies:** Verus allows users to launch tokens and basket currencies (such as liquidity pools) on top of blockchains for any use case. This feature enables users to create their own tokens and currencies with ease.\n\n**Protocol-Level DeFi and Smart Launch Options:** Verus has built-in DeFi and smart launch options, which enable users to create markets and raise funding for their projects.\n\n**Self-Sovereign Digital Identities and Namespaces (VerusID):** VerusID is a protocol-level feature that provides self-sovereign digital identities and namespaces. This feature enables builders, communities, businesses, and organizations to have full control over their digital identities and namespaces.\n\n**Aligned Incentives:** Verus has aligned incentives with the miners and stakers of the worldwide network, making it one of the most secure protocols with opportunities to earn.\n\n**Low-Cost Deployment:** Verus enables users to launch blockchains, tokens, liquidity pools, identities, and more without requiring any coding knowledge. Users can deploy their projects using simple API commands, saving money on expensive blockchain developers and infrastructure.\n\nOverall, Verus is a powerful and flexible blockchain protocol that provides a range of features and benefits for creators, organizations, and users. Its focus on scalability, security, and decentralization makes it an ideal choice for large-scale blockchain projects.", "# Introduction to VerusWelcome to the Verus documentation. Here you find all mainnet and testnet protocol features and implementations. The documentation will be updated continuously.## Open-source, rent-free, scalable public infrastructure\nVerus is an open-source, [fairly launched](/overview/#fair-launch), decentralized blockchain protocol with proof-of-work and proof-of-stake as its consensus mechanism. It offers rent-free blockchain tools for creators and organizations to build products, services and systems.Verus is a multichain protocol with strong focus on scalability, security and decentralization. It can scale to world demand, is proven 51% hash attack resistant and is community built - all coins in circulation are fairly mined and staked.With Public Blockchains as a Service (PBaaS) anyone can launch scalable, fully interoperable, customizable and independent blockchains for public or private use. Launch tokens & basket currencies (e.g. liquidity pools) on top of blockchains for any use case. Get funding and create markets with protocol level built-in DeFi and smart launch options.Protocol-level self-sovereign digital identities and namespaces ([VerusID](/verusid/)) are at the center of the Verus multichain protocol. Giving builders, communities, businesses and organizations tools never before seen.Everything happening on the Verus multichain protocol has aligned incentives with the [miners and stakers](/economy/) of the worldwide network. This makes it one of the most secure protocols with opportunities to earn.## Low-cost, rapid & easy deployment\nLaunch blockchains, tokens, liquidity pools, identities and much more without any coding needed, just simple API commands. Save money on expensive blockchain (Solidity) developers & infrastructure with the rent-free Verus Protocol.", "./raw_text_input_docs/README_overview.md"]]], [["User:: I've heard about the Verus-Ethereum Bridge, but I'm not quite sure what it is or how it works. Can you explain what it is, and what are its key features and benefits?", "AI Assistant:: I'd be happy to explain the Verus-Ethereum Bridge in detail.\n\nThe Verus-Ethereum Bridge is a decentralized solution that enables the secure transfer and conversion of cryptocurrencies between the Verus and Ethereum networks. This bridge is **trustless** and **non-custodial**, meaning that users do not need to rely on a third party to manage their funds, and no single entity has control over the assets being transferred.\n\nThe Verus-Ethereum Bridge stands out from other cryptocurrency bridges due to its unique approach to security. Instead of relying on a central authority, the bridge utilizes the decentralized network of miners and stakers to verify and account for funds crossing the bridge. This approach eliminates common security issues found in other bridges.\n\nThe Verus-Ethereum Bridge can be used for a variety of purposes, including:\n\n* Securely transferring cryptocurrencies between the Verus and Ethereum networks\n* Converting between different cryptocurrencies\n* Expanding the reach and interoperability of the Verus and Ethereum ecosystems\n\nThe bridge can be accessed through various means, including MetaMask or WalletConnect, or by downloading the Verus Mobile app for iOS and Android devices.\n\nOverall, the Verus-Ethereum Bridge provides a secure, decentralized, and trustless solution for users to transfer and convert cryptocurrencies between the Verus and Ethereum networks, promoting greater interoperability and flexibility in the cryptocurrency space.\n\nDo you have any further questions about the Verus-Ethereum Bridge, or how it can be used to benefit your cryptocurrency experience?"], "AI Assistant", "", "N/A", [["What is the Verus-Ethereum Bridge, and what are its key features and benefits?", "The Verus-Ethereum Bridge is a decentralized solution that enables the secure transfer and conversion of cryptocurrencies between the Verus and Ethereum networks. This bridge is **trustless** and **non-custodial**, meaning that users do not need to rely on a third party to manage their funds, and no single entity has control over the assets being transferred.\n\nThe Verus-Ethereum Bridge stands out from other cryptocurrency bridges due to its unique approach to security. Instead of relying on a central authority, the bridge utilizes the decentralized network of miners and stakers to verify and account for funds crossing the bridge. This approach eliminates common security issues found in other bridges.\n\nThe Verus-Ethereum Bridge can be used for a variety of purposes, including:\n\n* Securely transferring cryptocurrencies between the Verus and Ethereum networks\n* Converting between different cryptocurrencies\n* Expanding the reach and interoperability of the Verus and Ethereum ecosystems\n\nThe bridge can be accessed through various means, including MetaMask or WalletConnect, or by downloading the Verus Mobile app for iOS and Android devices.\n\nOverall, the Verus-Ethereum Bridge provides a secure, decentralized, and trustless solution for users to transfer and convert cryptocurrencies between the Verus and Ethereum networks, promoting greater interoperability and flexibility in the cryptocurrency space.", "# What is the Verus-Ethereum Bridge\nThe Verus-Ethereum Bridge (fully operational since Oct 20, 2023) allows for the secure transfer and conversion of cryptocurrencies between Verus and Ethereum. It's **trustless** and **non-custodial**, meaning it doesn't require users to trust a third party with their funds, and **no single entity has control over the assets being transferred**.The Bridge stands out because it avoids common security issues found in other cryptocurrency bridges by using the decentralized network of miners and stakers to verify and account for funds crossing the bridge.\ud83d\udc49 Access the Verus-Ethereum Bridge [with MetaMask or WalletConnect](https://eth.verusbridge.io), or download Verus Mobile for [iOS](https://apps.apple.com/en/app/verus-mobile/id6447361908) and [Android](https://play.google.com/store/apps/details?id=org.autonomoussoftwarefoundation.verusmobile.android&hl=en&gl=US).## What can the Verus-Ethereum Bridge do\nThe trustless and non-custodial Verus-Ethereum Bridge can be used for the following things:", "./raw_text_input_docs/README_eth-bridge.md"]]], [["User:: Hi there! I'm interested in using Verus for crowdfunding currency and blockchain launches. Can you tell me more about the features Verus offers for this, and how its multichain network enables interoperability between blockchains?", "AI Assistant:: Verus is a fantastic platform for crowdfunding currency and blockchain launches, and I'd be happy to walk you through its features and benefits.\n\nVerus offers a range of features for crowdfunding currency and blockchain launches. One key feature is the ability to set required minimum levels of worldwide participation in preferred currencies on the chain. If these minimums are not met by the start time of the blockchain, all participants will automatically receive a refund of their pre-conversions, minus network fees.\n\nAdditionally, Verus provides various launch options, including:\n\n* Maximum participation in one or more currencies\n* Pre-launch discounts\n* Price-neutral pre-allocations to select IDs, which increase the fractional reserve ratio to issue currencies\n* Price-neutral carve-outs of proceeds\n* Pre-launch discounts for early participants\n* Vesting schedules in pre-allocations using VerusIDs\n\nThese features provide a high degree of flexibility and customization for your crowdfunding campaign.\n\nNow, let's talk about Verus's multichain network and how it enables interoperability between blockchains. Verus allows the creation of an unlimited number of interoperable blockchains within its network. This is made possible through the use of Notary IDs, which provide decentralized blockchain-specific bridge confirmation. This allows for public blockchains to be made available for merge mining and staking, as well as private, internal blockchains, which can be easily set up with bridging of public currencies into an organization's internal private network and back.\n\nThe Verus network is designed to be fractal, enabling an unlimited number of simultaneously operating, interoperable blockchains. While there may be some overhead for cross-notarization, the network is capable of supporting a large number of blockchains, with no limit on the number of blockchains that can operate and interoperate simultaneously.\n\nDo you have any further questions about Verus's features for crowdfunding currency and blockchain launches, or how its multichain network enables interoperability between blockchains?"], "AI Assistant", "", "N/A", [["What features does Verus offer for crowdfunding currency and blockchain launches, and how does its multichain network enable interoperability between blockchains?", "Verus offers a range of features for crowdfunding currency and blockchain launches. One key feature is the ability to set required minimum levels of worldwide participation in preferred currencies on the chain. If these minimums are not met by the start time of the blockchain, all participants will automatically receive a refund of their pre-conversions, minus network fees.\n\nAdditionally, Verus provides various launch options, including:\n\n* Maximum participation in one or more currencies\n* Pre-launch discounts\n* Price-neutral pre-allocations to select IDs, which increase the fractional reserve ratio to issue currencies\n* Price-neutral carve-outs of proceeds\n* Pre-launch discounts for early participants\n* Vesting schedules in pre-allocations using VerusIDs\n\nVerus also enables the creation of an unlimited number of interoperable blockchains within its multichain network. This is made possible through the use of Notary IDs, which provide decentralized blockchain-specific bridge confirmation. This allows for public blockchains to be made available for merge mining and staking, as well as private, internal blockchains, which can be easily set up with bridging of public currencies into an organization's internal private network and back.\n\nThe Verus network is designed to be fractal, enabling an unlimited number of simultaneously operating, interoperable blockchains. While there may be some overhead for cross-notarization, the network is capable of supporting a large number of blockchains, with no limit on the number of blockchains that can operate and interoperate simultaneously.", "## Crowdfunding currency and blockchain launches\nSet required minimum levels of worldwide participation in your preferred currencies on chain. If by the start time of your blockchain, minimums are not met, all participants will automatically get a refund of all of their pre-conversions, less the network fees.\n\nThe launch options also provide for maximum participation in one or more currencies, pre-launch discounts, price neutral pre-allocations to select IDs that increase the fractional reserve ratio to issue currencies, similarly price neutral carve-outs of proceeds, and pre-launch discounts for early participants. Using VerusIDs, launches can also include vesting schedules in the pre-allocations as well.\n\n## Interoperable, multichain network\nThe Verus multi-currency, multi-chain network allows the creation of an unlimited number of interoperable blockchains in the Verus network.\n\nNotary IDs, specified at chain definition, provide decentralized blockchain-specific bridge confirmation, enabling public blockchains available to the world for merge mining and staking, as well as private, internal blockchains, which are easy to setup with easy bridging of public currencies into an organization and onto their internal private network and back, with all features and currencies of the public chain but none of the access.\n\nThere is no limit on the number of blockchains that may continuously operate and interoperate on the Verus network. While there is some overhead for cross notarization, the model for the Verus blockchain network is fractal, enabling an unlimited number of simultaneously operating, interoperable blockchains.", "./raw_text_input_docs/README_blockchains.md"]]], [["User:: Hi! I'm trying to get started with Verus Vault in Verus Desktop, but I'm not sure where to begin. Can you walk me through the setup process and explain the two ways to lock funds in a VerusID using Verus Vault?", "AI Assistant:: I'd be happy to help you with that. To set up Verus Vault in Verus Desktop, you'll need the latest version of Verus Desktop and a VerusID on the Verus mainchain or any other chain when PBaaS is live. Verus Vault allows you to lock funds in your VerusID, making them unspendable until the lock is removed. However, you can still stake and receive coins while your funds are locked.\n\nThere are two ways to lock funds in a VerusID using Verus Vault: TimeLock and DelayLock.\n\n**TimeLock:** With a TimeLock, you can lock funds and specify a predetermined number of blocks until they are unlocked. For example, if you want to lock your VerusID for a year, you would need to know the current block height of the blockchain. Let's say the block height is 1,000,000 blocks. You would calculate the number of blocks in a year, which is approximately 508,994 blocks. Then, you would use the Verus Desktop commandline interface to set up a TimeLock for 508,994 blocks.\n\n**Note:** When locking funds for long-term periods, it's best to use an average block time of 62 seconds, considering variables like leap years. This translates to an average of 1394.5484 blocks per day.\n\n**DelayLock:** With a DelayLock, you can lock funds and specify a delay before they are unlocked. The funds will be locked until an unlock request is made and a predetermined number of blocks have passed.\n\nTo set up Verus Vault, access the commandline interface in Verus Desktop by going to Settings (the cogwheel icon) > Coin Settings. From there, you can fill in the commands to set up your Vault with either a TimeLock or DelayLock.\n\nDo you have any questions about the setup process or how TimeLock and DelayLock work?"], "AI Assistant", "", "N/A", [["How do I set up Verus Vault in Verus Desktop, and what are the two ways to lock funds in a VerusID using Verus Vault?", "To set up Verus Vault in Verus Desktop, you'll need the latest version of Verus Desktop and a VerusID on the Verus mainchain or any other chain when PBaaS is live. Verus Vault allows you to lock funds in your VerusID, making them unspendable until the lock is removed. However, you can still stake and receive coins while your funds are locked.\n\nThere are two ways to lock funds in a VerusID using Verus Vault: TimeLock and DelayLock.\n\n**TimeLock:** With a TimeLock, you can lock funds and specify a predetermined number of blocks until they are unlocked. For example, if you want to lock your VerusID for a year, you would need to know the current block height of the blockchain. Let's say the block height is 1,000,000 blocks. You would calculate the number of blocks in a year, which is approximately 508,994 blocks. Then, you would use the Verus Desktop commandline interface to set up a TimeLock for 508,994 blocks.\n\n**Note:** When locking funds for long-term periods, it's best to use an average block time of 62 seconds, considering variables like leap years. This translates to an average of 1394.5484 blocks per day.\n\n**DelayLock:** With a DelayLock, you can lock funds and specify a delay before they are unlocked. The funds will be locked until an unlock request is made and a predetermined number of blocks have passed.\n\nTo set up Verus Vault, access the commandline interface in Verus Desktop by going to Settings (the cogwheel icon) > Coin Settings. From there, you can fill in the commands to set up your Vault with either a TimeLock or DelayLock.", "# Set up Verus Vault in Verus Desktop (easy method)\n![image-vaulteasy](/images/lockfunds2.png)\nVerus Vault is not yet accessible with clickable interfaces. You can still set up Vault in Verus Desktop. Here's how.What do you need:\n- Latest version Verus Desktop [download here](https://verus.io/wallet/desktop)\n- VerusID (on the Verus mainchain, or when PBaaS is live on any other chain)With Verus Vault you can lock funds in your VerusID. When your funds are locked in the Vault you can not spend them anymore, they cannot leave the VerusID. You can still always continue to stake and receive coins.You can lock a VerusID in two different ways that cannot be circumvented by anyone, except the ``revocation and recovery authorities`` together.| Lock type | How it works | \n| - |:-----|:-----|\n| TimeLock | Locks the funds and unlocks until a predetermined number of blocks have passed. | \n| DelayLock | Locks the funds and unlocks with a delay. Funds can not be spent until an unlock has been requested + a predetermined number of blocks have passed. |### Get Started\nWe need to access the commandline interface in Verus Desktop. Go to ``settings`` (the cogwheel top right corner), then select ``Coin Settings``. Here we can fill in the commands to set up your Vault.## Vault with TimeLock\n![image-timelock](/images/timeock.png)\nNow let's put a TimeLock on a VerusID. For a TimeLock you need to know the blockheight of the blockchain. Let's say the blockchain's blockheight is at ``1,000,000`` blocks. You want to lock your VerusID for 1 year. 1 year is ``508994`` blocks.::: warning Long-Term Locking\n**For long-term locking it's best to take an average block time of 62 seconds. Yet there are some variables that make it difficult to predict an exact time, leap years for example. Over long-term there are an average of 1394.5484 blocks per day.**\n:::", "./raw_text_input_docs/setup-vault-v2.md"]]], [["User:: I'm trying to create a basket currency in Verus, but I'm not sure how to do it. Can you walk me through the process of defining a basket currency, including setting initial contributions, initial supply, and preallocations? And what considerations should I keep in mind when doing so?", "AI Assistant:: Defining a basket currency in Verus can be a bit complex, but I'm here to guide you through it.\n\nTo define a basket currency, you can use the `definecurrency` command with specific parameters. Here's an example of how to define a basket currency called `CommunityBasket`:\n\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"CommunityBasket\",\n\"options\":33,\n\"currencies\":[\"vrsctest\",\"CoinCommunity\"],\n\"initialcontributions\":[10,200],\n\"initialsupply\":100,\n\"preallocations\":[{\"Jane@\":100},{\"John@\":50}]\n}'\n```\n\nIn this example, `CommunityBasket` is a basket currency that requires initial contributions to its reserves. At the moment of broadcasting the currency to the network, there needs to be 210 VRSCTEST and 200 CoinCommunity in the rootID.\n\nThe `initialsupply` parameter is a required parameter for basket currencies (options:33) and sets the initial supply during the preconversion time frame, before the currency is launched. People preconverting into the reserves receive from this initial supply.\n\nIt's important to note that `\"initialcontributions\"` and/or preconversions are required, otherwise the initial supply cannot go anywhere and the currency is bricked.\n\nAfter the currency is launched, the supply can be larger due to `\"preallocations\"`. In this example, 100 CoinCommunity is minted into `Jane@` and 50 into `John@`, which lowers the reserve ratio of the currency.\n\nWhen defining a basket currency, consider the following:\n\n1. Ensure you have the required funds in the rootID to make the initial contributions.\n2. Set the `initialsupply` parameter to the desired amount, which will be distributed to preconverters during the preconversion time frame.\n3. Define `preallocations` to specify the initial distribution of the currency to specific addresses.\n4. Remember that `\"initialcontributions\"` and/or preconversions are required to prevent the currency from being bricked.\n\nBy following these steps and considerations, you can successfully define a basket currency in Verus.\n\nDo you have any further questions about defining basket currencies or any of the specific parameters involved?"], "AI Assistant", "", "N/A", [["How do I define a basket currency in Verus, including setting initial contributions, initial supply, and preallocations, and what considerations should I keep in mind when doing so?", "To define a basket currency in Verus, you can use the `definecurrency` command with specific parameters. Here's an example of how to define a basket currency called `CommunityBasket`:\n\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CommunityBasket\", \n \"options\":33, \n \"currencies\":[\"vrsctest\",\"CoinCommunity\"], \n \"initialcontributions\":[10,200], \n \"initialsupply\":100, \n \"preallocations\":[{\"Jane@\":100},{\"John@\":50}]\n}'\n```\n\nIn this example, `CommunityBasket` is a basket currency that requires initial contributions to its reserves. At the moment of broadcasting the currency to the network, there needs to be 210 VRSCTEST and 200 CoinCommunity in the rootID.\n\nThe `initialsupply` parameter is a required parameter for basket currencies (options:33) and sets the initial supply during the preconversion time frame, before the currency is launched. People preconverting into the reserves receive from this initial supply.\n\nIt's important to note that `\"initialcontributions\"` and/or preconversions are required, otherwise the initial supply cannot go anywhere and the currency is bricked.\n\nAfter the currency is launched, the supply can be larger due to `\"preallocations\"`. In this example, 100 CoinCommunity is minted into `Jane@` and 50 into `John@`, which lowers the reserve ratio of the currency.\n\nWhen defining a basket currency, consider the following:\n\n1. Ensure you have the required funds in the rootID to make the initial contributions.\n2. Set the `initialsupply` parameter to the desired amount, which will be distributed to preconverters during the preconversion time frame.\n3. Define `preallocations` to specify the initial distribution of the currency to specific addresses.\n4. Remember that `\"initialcontributions\"` and/or preconversions are required to prevent the currency from being bricked.\n\nBy following these steps and considerations, you can successfully define a basket currency in Verus.", "The funds to initially contribute need to be in the rootID when defining the currency. After the preconversion time frame is over and the currency launched, the rootID has received an amount of the launched currency.Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CommunityBasket\", \n \"options\":33, \n \"currencies\":[\"vrsctest\",\"CoinCommunity\"], \n \"initialcontributions\":[10,200], \n \"initialsupply\":100, \n \"preallocations\":[{\"Jane@\":100},{\"John@\":50}]\n}'\n```\n\u261d\ufe0f This is a basket currency called CommunityBasket. The launcher of the currency wanted to make initial contributions to its reserves. At the moment of broadcasting the currency to the network, there needed to be 210 VRSCTEST and 200 CoinCommunity in the rootID. The initial supply of 100 went to the rootID (if there weren\u2019t any more preconverters). At the same time of the launch, 100 CoinCommunity was minted into Jane@ and 50 into John@, this lowered the reserve ratio of the currency.### **\"initialsupply\"**\nA required parameter for basket currencies (`options:33`). This parameter does not work with simple token currencies. This is the initial supply during the preconversion time frame, before the currency is launched. People preconverting into the reserves receive from this initial supply.\u26a0\ufe0f IMPORTANT: `\"initialcontributions\"` and/or preconversions are required, otherwise the initial supply can not go anywhere and the currency is bricked.Immediately after the currency is launched, the supply can be larger due to `\"preallocations\"`.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I'm creating a new currency on the Verus network and I want to know more about the parameters that can be used to customize the preconversion process. Can you explain what these parameters are and how they affect the preconversion process?", "AI Assistant:: When defining a new currency on the Verus network, there are several parameters that can be used to customize the preconversion process. These parameters include \"minpreconversion\", \"maxpreconversion\", and \"initialcontributions\".\n\nLet me break each of these down for you:\n\n**Minpreconversion:**\nThe \"minpreconversion\" parameter is used to set a minimum amount of preconversions required for a currency to launch. If the minimum amount is not met, the currency will not launch, and everyone who did a preconvert will get their funds back. For example, in the case of the CompanyX currency, people need to convert at least 500 VRSCTEST to the rootID during the preconversion time frame in order to receive 250 CompanyX. If this minimum amount is not met, the currency will not launch.\n\n**Maxpreconversion:**\nThe \"maxpreconversion\" parameter is used to set a maximum amount of preconversions. During the preconversion time frame, the amount set cannot be exceeded. Everything above this amount will be automatically refunded after the currency is launched. For example, in the case of the CoinCommunity currency, people can convert VRSCTEST into its reserves for 100 CoinCommunity in return, but there cannot be more than 100 VRSCTEST converted into its reserves during the preconversion time frame. Whatever is preconverted more than this amount will be returned.\n\n**Initialcontributions:**\nThe \"initialcontributions\" parameter allows the rootID to contribute some or all of the minimum preconversions directly as part of the currency definition. This can be used to make an initial contribution to either the reserves when it's a basket currency (options:33), or to the rootID when it's a simple token currency (options:32). This parameter provides flexibility in the preconversion process and allows for more control over the initial distribution of the currency.\n\nIt's also important to note that there is a 0.025% fee taken when preconverting, which should be taken into consideration when trying to meet the minimum amount of preconversions.\n\nI hope that helps! Do you have any more questions about these parameters or the preconversion process in general?"], "AI Assistant", "", "N/A", [["What are the different parameters that can be used when defining a new currency on the Verus network, and how do they affect the preconversion process?", "When defining a new currency on the Verus network, there are several parameters that can be used to customize the preconversion process. These parameters include \"minpreconversion\", \"maxpreconversion\", and \"initialcontributions\".\n\n**Minpreconversion:**\nThe \"minpreconversion\" parameter is used to set a minimum amount of preconversions required for a currency to launch. If the minimum amount is not met, the currency will not launch, and everyone who did a preconvert will get their funds back. For example, in the case of the CompanyX currency, people need to convert at least 500 VRSCTEST to the rootID during the preconversion time frame in order to receive 250 CompanyX. If this minimum amount is not met, the currency will not launch.\n\n**Maxpreconversion:**\nThe \"maxpreconversion\" parameter is used to set a maximum amount of preconversions. During the preconversion time frame, the amount set cannot be exceeded. Everything above this amount will be automatically refunded after the currency is launched. For example, in the case of the CoinCommunity currency, people can convert VRSCTEST into its reserves for 100 CoinCommunity in return, but there cannot be more than 100 VRSCTEST converted into its reserves during the preconversion time frame. Whatever is preconverted more than this amount will be returned.\n\n**Initialcontributions:**\nThe \"initialcontributions\" parameter allows the rootID to contribute some or all of the minimum preconversions directly as part of the currency definition. This can be used to make an initial contribution to either the reserves when it's a basket currency (options:33), or to the rootID when it's a simple token currency (options:32). This parameter provides flexibility in the preconversion process and allows for more control over the initial distribution of the currency.\n\nIt's also important to note that there is a 0.025% fee taken when preconverting, which should be taken into consideration when trying to meet the minimum amount of preconversions.", "There is a 0.025% fee taken when preconverting. Take this into consideration when trying to meet the minimum amount of preconversions.Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CompanyX\",\n \"options\":32,\n \"currencies\":[\"vrsctest\"],\n \"conversions\":[2],\n \"minpreconversion\":[500]\n}'\n```\n\u261d\ufe0f This simple token currency is called CompanyX. During the preconversion time frame people need to convert at least 500 VRSCTEST to the rootID. In exchange for that they receive 250 CompanyX, or more when more is converted. If this minimum amount is not met, the currency will not launch, and everyone who did a preconvert will get their funds back.### **\"maxpreconversion\"**\nUse this parameter to set a maximum amount of preconversions. During the preconversion time frame the amount set can not be exceeded. Everything above this amount will be automatically refunded after the currency is launched.Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CoinCommunity\", \n \"options\":33, \n \"currencies\":[\"vrsctest\"], \n \"maxpreconversion\":[100], \n \"initialsupply\":100\n}'\n```\n\u261d\ufe0f This is a basket currency called CoinCommunity. During the preconversion time frame people can convert VRSCTEST into its reserves for 100 CoinCommunity in return. During the preconversion time frame there can not be more than 100 VRSCTEST converted into its reserves. Whatever is preconverted more will be returned.### **\"initialcontributions\"**\nThe rootID can contribute some or all of the minimum preconversions directly as part of the currency definition. Use this parameter to make an initial contribution to either the reserves when it\u2019s a basket currency (`options:33`), or to the rootID when it\u2019s a simple token currency (`options:32`).", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I've been hearing about VDXF, but I'm not really sure what it is or how it works. Can you explain what VDXF is, and how it enables the recognition and usage of unlimited user-defined data types in a standardized and collision-free manner?", "AI Assistant:: VDXF (Verus Data eXchange Format) is a really powerful tool that enables the recognition and usage of an unlimited number of user-defined data types. I'd be happy to break it down for you.\n\nVDXF is a specification that focuses on recognizing and enabling the use of an unlimited number of user-defined data types. It does this by providing a standard human-readable format for defining and encoding type specifiers, which are then hashed to produce collision-free 20-byte keys. These keys can be associated with retrievable content hashes and location qualifiers, allowing applications to locate, recognize, parse, and decode various forms of application-specific data.\n\nVDXF defines some basic type formats to enable initial applications, but leaves the specification of application-specific data formats open-ended, allowing for an unlimited number of new data type definitions as needed. While it is recommended that new fundamental data types not be defined unless necessary, adherence to this recommendation is not enforced at the consensus protocol layer.\n\nIn terms of type definitions, VDXF uses namespaces that are equivalent to VerusIDs, which are protocol-first implemented on the Verus Blockchain. These namespaces can support IDs registered on any blockchain or uniquely named system that becomes recognized via a consensus-based bridge on the Verus network. Currently, the easiest way to create a unique namespace is to base it on a VerusID, registered on the Verus blockchain network.\n\nOverall, VDXF provides a flexible and standardized way to define and use custom data types, enabling efficient application development and data exchange.\n\nDo you have any further questions about VDXF or how it can be used in your applications?"], "AI Assistant", "", "N/A", [["What is VDXF, and how does it enable the recognition and usage of unlimited user-defined data types in a standardized and collision-free manner?", "VDXF (Verus Data eXchange Format) is a specification that focuses on recognizing and enabling the use of an unlimited number of user-defined data types. It does this by providing a standard human-readable format for defining and encoding type specifiers, which are then hashed to produce collision-free 20-byte keys. These keys can be associated with retrievable content hashes and location qualifiers, allowing applications to locate, recognize, parse, and decode various forms of application-specific data.\n\nVDXF defines some basic type formats to enable initial applications, but leaves the specification of application-specific data formats open-ended, allowing for an unlimited number of new data type definitions as needed. While it is recommended that new fundamental data types not be defined unless necessary, adherence to this recommendation is not enforced at the consensus protocol layer.\n\nIn terms of type definitions, VDXF uses namespaces that are equivalent to VerusIDs, which are protocol-first implemented on the Verus Blockchain. These namespaces can support IDs registered on any blockchain or uniquely named system that becomes recognized via a consensus-based bridge on the Verus network. Currently, the easiest way to create a unique namespace is to base it on a VerusID, registered on the Verus blockchain network.\n\nOverall, VDXF provides a flexible and standardized way to define and use custom data types, enabling efficient application development and data exchange.", "## Definition of VDXF typesVDXF is not a strongly opinionated or highly specified type description specification, and, instead, focuses on a model for recognizing an unlimited number of user defined data types, using a standard human readable format for definition and encoding of the type specifier, which is hashed, using the VDXF specification and standard methodology, to produce collision-free, 20 byte keys, which can be associated with retrieveable content hashes and location qualifiers that enable applications to locate, recognize types of, parse, and decode any form of application or system specific data. VDXF specifies some basic type formats, as necessary to enable initial applications, but leaves further specifications of applicaiton specific data formats, of which there may be an unlimited number, as an open-ended option for those needing new data type definitions for efficient application development. It is recommended that new fundamental data types not be defined unless necessary, but adherence to such recommendation is not enforced at the consensus protocol layer.## Namespace for Type Definitions - VerusIDNamespaces for type definitions are equivalent to VerusIDs, a protocol first implemented on the Verus Blockchain, and also one that can support IDs registered on any blockchain or uniquely named system that becomes recognized via a consensus-based bridge on the Verus network. Currently, to be recognized as a unique namespace, the easiest way is to base it on a VerusID, registered on the Verus blockchain network.", "./raw_text_input_docs/README_vdxf.md"]]], [["User:: I'm really interested in learning more about VerusID. Can you explain what VerusID is, and what are its key features that make it a self-sovereign identity and a building block for creating Web3 Dapps?", "AI Assistant:: VerusID is a decentralized and self-sovereign identity that serves as a permanent namespace for the Verus Protocol. It is a unique identity system that empowers individuals with complete autonomy both online and offline. VerusID offers a range of features that make it a powerful tool for creating Web3 Dapps. Here are some of its key features:\n\n**Namespace:** VerusID is a permanent namespace for the Verus Protocol, and anyone can register a VerusID. This namespace allows users to create a unique identity that can be used to interact with the Verus ecosystem.\n\n**Self-sovereign identity:** VerusID functions as a self-sovereign identity, giving individuals complete control over their online presence. This means that users have full autonomy over their identity, and can use it to interact with various applications and services.\n\n**Blockchain launches:** With VerusID, anyone can launch fully interconnected, customizable, independent, and secure blockchains without needing to write any code. This feature makes it easy to create decentralized applications (Dapps) on the Verus network.\n\n**Currency and token launches:** VerusID also allows users to launch powerful currencies and tokens, including basket currencies (DeFi AMMs). This feature makes it easy to create new digital assets and tokens on the Verus network.\n\n**Publish and store data:** VerusID and VDXF can be used as a controlled public storage system, allowing users to publish and store data with multiple levels of nesting. This feature makes it easy to store and manage data on the Verus network.\n\n**Revoking and recovering:** Each VerusID has revocation and recovery authorities (which are also VerusIDs). This means that users can autonomously revoke access to a VerusID and recover all assets and data associated with it.\n\n**Friendly name address:** A VerusID is a friendly name address that can send, receive, and hold assets. This makes it easy to use VerusID as a digital wallet or identity.\n\n**Verus Vault:** VerusID also enables theft-proof Verus Vault, which allows users to set locks or timelocks to secure assets on a VerusID. This feature provides an additional layer of security for users.\n\n**Marketplace:** VerusID has a peer-to-peer decentralized marketplace for VerusIDs, currencies, and tokens. This marketplace allows users to buy and sell digital assets and tokens in a decentralized manner.\n\n**Privacy:** VerusID also provides privacy features, allowing users to point a private address to a VerusID. This means that users can send and receive native assets with full anonymity.\n\n**Signatures:** Finally, VerusID allows users to create unforgable, verifiable signatures. This feature makes it easy to sign digital documents and contracts with a high level of security.\n\nOverall, VerusID is a powerful tool for creating self-sovereign identities and building Web3 Dapps. Its range of features makes it an ideal solution for individuals and organizations looking to create decentralized applications and services.\n\nDo you have any more questions about VerusID or its features?"], "AI Assistant", "", "N/A", [["What is VerusID, and what are its key features that make it a self-sovereign identity and a building block for creating Web3 Dapps?", "VerusID is a decentralized and self-sovereign identity that serves as a permanent namespace for the Verus Protocol. It is a unique identity system that empowers individuals with complete autonomy both online and offline. VerusID offers a range of features that make it a powerful tool for creating Web3 Dapps. Here are some of its key features:\n\n**Namespace:** VerusID is a permanent namespace for the Verus Protocol, and anyone can register a VerusID. This namespace allows users to create a unique identity that can be used to interact with the Verus ecosystem.\n\n**Self-sovereign identity:** VerusID functions as a self-sovereign identity, giving individuals complete control over their online presence. This means that users have full autonomy over their identity, and can use it to interact with various applications and services.\n\n**Blockchain launches:** With VerusID, anyone can launch fully interconnected, customizable, independent, and secure blockchains without needing to write any code. This feature makes it easy to create decentralized applications (Dapps) on the Verus network.\n\n**Currency and token launches:** VerusID also allows users to launch powerful currencies and tokens, including basket currencies (DeFi AMMs). This feature makes it easy to create new digital assets and tokens on the Verus network.\n\n**Publish and store data:** VerusID and VDXF can be used as a controlled public storage system, allowing users to publish and store data with multiple levels of nesting. This feature makes it easy to store and manage data on the Verus network.\n\n**Revoking and recovering:** Each VerusID has revocation and recovery authorities (which are also VerusIDs). This means that users can autonomously revoke access to a VerusID and recover all assets and data associated with it.\n\n**Friendly name address:** A VerusID is a friendly name address that can send, receive, and hold assets. This makes it easy to use VerusID as a digital wallet or identity.\n\n**Verus Vault:** VerusID also enables theft-proof Verus Vault, which allows users to set locks or timelocks to secure assets on a VerusID. This feature provides an additional layer of security for users.\n\n**Marketplace:** VerusID has a peer-to-peer decentralized marketplace for VerusIDs, currencies, and tokens. This marketplace allows users to buy and sell digital assets and tokens in a decentralized manner.\n\n**Privacy:** VerusID also provides privacy features, allowing users to point a private address to a VerusID. This means that users can send and receive native assets with full anonymity.\n\n**Signatures:** Finally, VerusID allows users to create unforgable, verifiable signatures. This feature makes it easy to sign digital documents and contracts with a high level of security.\n\nOverall, VerusID is a powerful tool for creating self-sovereign identities and building Web3 Dapps. Its range of features makes it an ideal solution for individuals and organizations looking to create decentralized applications and services.", "# IntroductionVerusID is the first decentralized and self-sovereign identity of its kind, the permanent namespace for the Verus Protocol, and the building block to create Web3 Dapps.## Feature List| Feature | Details | \n| :-----| :------ | \n| **Namespace** | VerusID is the permanent namespace for the Verus Protocol and can be registered by anyone. | \n| **Self-sovereign identity** | VerusID can function as a self-sovereign identity for anyone in the world, empowering individuals with complete autonomy both online and offline. |\n| [**Blockchain launches**](/blockchains/) | With the VerusID namespace anyone can launch fully interconnected, customizable, independent and secure blockchains, without any coding needed (just simple commands). | \n| [**Currency & token launches**](/currencies/) | With the VerusID namespace anyone can launch powerful currencies and tokens, including basket currencies (DeFi AMMs). |\n| [**Publish & store data**](/vdxf/README) | Use VerusID and VDXF as a controlled public storage system. Publish and store data with multiple levels of nesting. | \n| [**Revoking & recovering**](/verusid/#revoke-recover) | Each VerusID has revocation and recovery authorities (which are also VerusIDs). Autonomously revoke access to a VerusID, and recover all assets and data on a VerusID. | \n| [**Friendly name address**](/verusid/#friendly-name) | A VerusID is a friendly name address that can send, receive and hold assets. | \n| [**Verus Vault**](/verusid/#verus-vault) | Enable theft-proof Verus Vault. Set locks or timelocks to secure assets on a VerusID. | \n| [**Marketplace**](/verusid/#marketplace) | Peer-to-peer decentralized marketplace for VerusIDs and currencies and tokens. | \n| **Privacy** | Point a private address to a VerusID. Send and receive native assets with full anonimity. | \n| **Signatures** | Create unforgable, verifiable signatures with VerusID. Sign fi", "./raw_text_input_docs/README_addresses.md"]]], [["User:: I'm interested in using the Verus command-line interface (CLI) wallet, but I'm not sure where to start. Can you walk me through how to set up and use the Verus CLI wallet, and what are the different commands I can use to interact with the Verus blockchain?", "AI Assistant:: Setting up and using the Verus CLI wallet is a great way to interact with the Verus blockchain. I'd be happy to guide you through the process.\n\nTo set up and use the Verus CLI wallet, you will need to download the Verus CLI package for your operating system (Windows, macOS, or Linux) from the Verus website. Once downloaded, extract the package to a location on your computer where you can easily find it.\n\nInside the extracted package, you will find several executable files, including `verusd`, `verus`, `fetch-bootstrap`, and `fetch-params`, as well as accompanying text files for verifying signatures.\n\nTo start using the Verus CLI wallet, open a terminal and navigate to the directory where you extracted the package.\n\n**Starting the Verus Blockchain:**\nTo start the Verus blockchain, run the command `./verusd`. This will start the Verus daemon, which will run as a background process.\n\n**Starting the Testnet Blockchain:**\nIf you want to start the Verus testnet blockchain instead, run the command `./verusd -chain=VRSCTEST`.\n\n**Other Commands:**\nBefore starting the blockchain, you may need to run some additional commands. For example, if you are running a new system, you should run `fetch-params` to download the necessary zcash parameters. You can also speed up the blockchain download process by running `fetch-bootstrap` to bootstrap the blockchain.\n\n**Interacting with the Blockchain:**\nOnce the blockchain is running, you can use the `verus` command to interact with it. This command allows you to perform various actions, such as sending and receiving transactions, checking your balance, and more.\n\nSome examples of commands you can use with the `verus` command include:\n\n* `verus getbalance` to check your current balance\n* `verus send` to send a transaction to another Verus address\n* `verus receive` to receive a transaction from another Verus address\n* `verus listtransactions` to list all transactions in your wallet\n* `verus getnewaddress` to generate a new Verus address\n\nThese are just a few examples of the many commands you can use with the Verus CLI wallet. You can use the `verus help` command to see a full list of available commands and their usage.\n\nDo you have any questions about setting up or using the Verus CLI wallet? Or would you like more information on specific commands?"], "AI Assistant", "", "N/A", [["How do I set up and use the Verus command-line interface (CLI) wallet, and what are the different commands I can use to interact with the Verus blockchain?", "To set up and use the Verus CLI wallet, you will need to download the Verus CLI package for your operating system (Windows, macOS, or Linux) from the Verus website. Once downloaded, extract the package to a location on your computer where you can easily find it.\n\n Inside the extracted package, you will find several executable files, including `verusd`, `verus`, `fetch-bootstrap`, and `fetch-params`, as well as accompanying text files for verifying signatures.\n\nTo start using the Verus CLI wallet, open a terminal and navigate to the directory where you extracted the package.\n\n**Starting the Verus Blockchain:**\nTo start the Verus blockchain, run the command `./verusd`. This will start the Verus daemon, which will run as a background process.\n\n**Starting the Testnet Blockchain:**\nIf you want to start the Verus testnet blockchain instead, run the command `./verusd -chain=VRSCTEST`.\n\n**Other Commands:**\nBefore starting the blockchain, you may need to run some additional commands. For example, if you are running a new system, you should run `fetch-params` to download the necessary zcash parameters. You can also speed up the blockchain download process by running `fetch-bootstrap` to bootstrap the blockchain.\n\n**Interacting with the Blockchain:**\nOnce the blockchain is running, you can use the `verus` command to interact with it. This command allows you to perform various actions, such as sending and receiving transactions, checking your balance, and more.\n\nOverall, the Verus CLI wallet provides a powerful and flexible way to interact with the Verus blockchain, and can be a useful alternative to the Verus Desktop wallet.", "# Setup verus-cli\n\n### [Download verus-cli for Windows, macOS and Linux](https://verus.io/wallet/)\n\nThe CLI (command-line-interface) wallet is an alternative to Verus Desktop, and is used through the terminal.\n\nIn the packaged file you find ``verusd``, ``verus``, ``fetch-bootstrap``, ``fetch-params`` and accompanying text files to [verify](https://verus.io/signatures) signatures.\n\nRun ``verusd`` to start the blockchain. The ``d`` stands for daemon. A daemon is a program that runs as a background process.\n\nRun ``verus`` to interact with the blockchain.\n\n::: warning New System \nRun ``fetch-params`` before using ``verusd`` when you are running a new system. It downloads the zcash parameters needed to get started.\n:::\n\n::: tip Bootstrap Blockchain\nDownloading the blockchain can take up a long time, to speed it up you can bootstrap the blockchain. Run ``fetch-bootstrap``.\n:::\n\nExtract the packaged file on your computer, preferably where you can find it back easily.\n\n## Use Commands\nIn your terminal, go into the directory where you extracted verus-cli.\n\n### Start Verus Blockchain\n\n``` \n./verusd\n```\n\n### Start Testnet Blockchain\n``` \n./verusd -chain=VRSCTEST\n```", "./raw_text_input_docs/setup-cli.md"]]], [["User:: I've been exploring VerusID and I'm curious to know more about its features and capabilities. Can you tell me some of the key features and how they can be used in various scenarios?", "AI Assistant:: VerusID is a powerful decentralized identity system that offers several features that enable secure and flexible management of digital identities. Let me highlight three notable features: signatures, multisig, and messaging.\n\n**Signatures:**\nVerusID allows users to create unforgable and verifiable signatures for files, hashes, and messages. These signatures are tamper-evident and can be verified for free using the Verus protocol. This feature ensures the authenticity and integrity of digital data, enabling trustless transactions and interactions.\n\nImagine a scenario where a company wants to ensure the authenticity of a digital document. With VerusID signatures, the company can create a signature that verifies the document's integrity, ensuring that it hasn't been tampered with. This feature is particularly useful in industries like finance, healthcare, and government, where data integrity is critical.\n\n**Multisig:**\nThe multisig feature of VerusID enables multiple VerusIDs to have spending or signing abilities for a single VerusID. This means that multiple organizations or individuals can jointly manage a VerusID, enabling collaborative decision-making and secure asset management. Multisig provides an additional layer of security and flexibility, as it requires the consent of multiple parties to perform actions on a VerusID.\n\nFor example, a group of investors can use multisig to jointly manage a cryptocurrency fund. Each investor can have a VerusID that is part of the multisig setup, ensuring that no single individual can make decisions without the consent of the others.\n\n**Messages:**\nVerusID also enables users to send private messages to other VerusIDs. This feature ensures secure and private communication between parties, protecting sensitive information from unauthorized access. Private messaging is essential for various use cases, such as business negotiations, personal communications, or confidential data sharing.\n\nIn a business setting, VerusID messaging can be used to negotiate deals or share confidential information between parties. The encryption and security features of VerusID messaging ensure that sensitive information remains private and secure.\n\nIn summary, VerusID's features provide a robust and secure platform for managing digital identities, enabling secure transactions, collaborative decision-making, and private communication. These capabilities have numerous applications in various industries, including finance, healthcare, and government.\n\nDo you have any more questions about VerusID's features or how they can be used in different scenarios?"], "AI Assistant", "", "N/A", [["What are some of the key features and capabilities of VerusID, and how can they be used in various scenarios?", "VerusID, a decentralized identity system, offers several powerful features that enable secure and flexible management of digital identities. Three notable features of VerusID are signatures, multisig, and messaging.\n\n**Signatures:**\nVerusID allows users to create unforgable and verifiable signatures for files, hashes, and messages. These signatures are tamper-evident and can be verified for free using the Verus protocol. This feature ensures the authenticity and integrity of digital data, enabling trustless transactions and interactions.\n\n**Multisig:**\nThe multisig feature of VerusID enables multiple VerusIDs to have spending or signing abilities for a single VerusID. This means that multiple organizations or individuals can jointly manage a VerusID, enabling collaborative decision-making and secure asset management. Multisig provides an additional layer of security and flexibility, as it requires the consent of multiple parties to perform actions on a VerusID.\n\n**Messages:**\nVerusID also enables users to send private messages to other VerusIDs. This feature ensures secure and private communication between parties, protecting sensitive information from unauthorized access. Private messaging is essential for various use cases, such as business negotiations, personal communications, or confidential data sharing.\n\nIn summary, VerusID's features provide a robust and secure platform for managing digital identities, enabling secure transactions, collaborative decision-making, and private communication. These capabilities have numerous applications in various industries, including finance, healthcare, and government.", "## Signatures\nCreate unforgable, verifiable signatures with VerusID. Sign files, hashes and messages. Use the protocol to verify those signatures for free.\n\n## Multisig\nMultiple VerusIDs can have spending or signing ability of one VerusID. This means that multiple organizations or people can manage a VerusID.\n\n## Messages\nSend private messages to VerusIDs.", "./raw_text_input_docs/README_addresses.md"]]], [["User:: Hey, I'm interested in mining Verus, but I'm not sure what the differences are between solo mining and pool mining. Can you explain that to me, and also what devices are suitable for mining Verus?", "AI Assistant:: I'd be happy to help you with that. In Verus, there are two main ways to mine: solo mining and pool mining. Both methods have their own advantages and disadvantages.\n\nLet's start with solo mining. **Solo Mining** allows you to mine Verus using the Verus Desktop application without any additional software. With solo mining, you have the potential to receive full block rewards, but it may take a while to win a block depending on your hashrate. The advantages of solo mining include not having to share your rewards with anyone and having full control over your mining process. However, the disadvantage is that you may not receive regular rewards, and it may take a while to win a block.\n\nOn the other hand, **Pool Mining** allows you to participate in a group of miners to receive regular rewards. To start pool mining, you will need to set up a few things, which may be more difficult than solo mining. The advantages of pool mining include receiving regular rewards and having a higher chance of winning blocks. However, the disadvantage is that you will have to share your rewards with other miners in the pool.\n\nNow, about the suitable devices for mining Verus. Verus can be mined using various devices, including CPUs (processors), GPUs (graphics cards), mobile phones, and ARM devices (not Raspberry Pi 4). The profitability of mining Verus depends on the device's hashrate and electricity usage. CPUs and mobile phones are considered to have high profitability, while GPUs have medium profitability. ARM devices (not Raspberry Pi 4) also have high profitability. However, FPGA and ASIC devices are not suitable for mining Verus.\n\nIf you need help with mining or want to compare hashrates from different devices, you can check out the Community Reported Hashrates spreadsheet or join the Verus Discord #mining channel, where the community is happy to assist.\n\nDo you have any more questions about solo mining, pool mining, or the suitable devices for mining Verus?"], "AI Assistant", "", "N/A", [["What are the differences between solo mining and pool mining in Verus, and what are the suitable devices for mining Verus?", "In Verus, there are two main ways to mine: solo mining and pool mining. Both methods have their own advantages and disadvantages.\n\n**Solo Mining:**\nSolo mining allows you to mine Verus using the Verus Desktop application without any additional software. With solo mining, you have the potential to receive full block rewards, but it may take a while to win a block depending on your hashrate. The advantages of solo mining include not having to share your rewards with anyone and having full control over your mining process. However, the disadvantage is that you may not receive regular rewards, and it may take a while to win a block.\n\n**Pool Mining:**\nPool mining, on the other hand, allows you to participate in a group of miners to receive regular rewards. To start pool mining, you will need to set up a few things, which may be more difficult than solo mining. The advantages of pool mining include receiving regular rewards and having a higher chance of winning blocks. However, the disadvantage is that you will have to share your rewards with other miners in the pool.\n\n**Suitable Devices:**\nVerus can be mined using various devices, including CPUs (processors), GPUs (graphics cards), mobile phones, and ARM devices (not Raspberry Pi 4). The profitability of mining Verus depends on the device's hashrate and electricity usage. CPUs and mobile phones are considered to have high profitability, while GPUs have medium profitability. ARM devices (not Raspberry Pi 4) also have high profitability. However, FPGA and ASIC devices are not suitable for mining Verus.\n\n**Additional Resources:**\nIf you need help with mining or want to compare hashrates from different devices, you can check out the Community Reported Hashrates spreadsheet or join the Verus Discord #mining channel, where the community is happy to assist.", "---\nsidebarDepth: 2\n---# Mining## Solo vs Pool Mining### Solo MiningMine solo through Verus Desktop to receive full block rewards. Depending on hashrate it may take a while before winning a block. No additional software is needed to get started.### Pool MiningParticipate in pool mining to receive regular rewards. You will need to set up a few things before you can start.---Quick Comparison\n| | Solo mining | Pool mining |\n| -----------------------: | :--: | :----------: |\n| **Full Node** | yes | no |\n| **Regular Rewards** | no | yes |\n| **Setup Difficulty** | easy | intermediate |## Suitable DevicesMine Verus with various devices. Profitability **indication** means the electricity usage vs hashrate.| Device       |     Profitability Indication      |\n| :------------------ | :-----------------------------------------: |\n| CPU (processor)   |  <span style=\"color:green\">high</span>  |\n| GPU (graphics card) | <span style=\"color:orange\">medium</span>  |\n| Mobile Phone    |  <span style=\"color:green\">high</span>  |\n| ARM (not RP4)    |  <span style=\"color:green\">high</span>  |\n| FPGA        | <span style=\"color:red\">not possible</span> |\n| ASIC        | <span style=\"color:red\">not possible</span> |::: tip Hashrate Comparison\nCompare hashrates from different devices. See [Community Reported Hashrates](https://docs.google.com/spreadsheets/d/1RrSYJDV0Mjj3X-myMC3aQDGkcipivxHsD7ZxJ3r5f_A/edit#gid=10943314)\n:::## Mining Software\n::: warning Need help with mining? \u26cf\ufe0f\n[Go to the Verus Discord #mining channel. The community is happy to assist!](https://www.verus.io/discord). \n:::\n### \ud83d\udda5\ufe0f CPUSoftware to mine with a CPU (processor).#### CCminer", "./raw_text_input_docs/start-mining.md"]]], [["User:: I've been hearing a lot about Verus, but I'm not quite sure what it's all about. Can you tell me about the core principles and characteristics of Verus, and how it achieved a fair launch?", "AI Assistant:: Verus is a decentralized public blockchain that operates on a set of core principles, which are designed to promote openness, accessibility, and fairness. These principles include:\n\n* **Decentralization**: Verus is a community-driven project, which means that anyone can participate and contribute, regardless of their background or location.\n* **Openness**: Verus is an open system, allowing anyone to start mining and staking the Verus Protocol without any hurdles or restrictions.\n* **Borderlessness**: Verus is a global platform, accessible to anyone with an internet connection.\n* **Public**: Verus is a public blockchain, meaning that all transactions and data are transparent and publicly available.\n* **Neutrality**: Verus is a neutral platform, free from commercial interests and rent-seeking behavior.\n* **Censorship resistance**: Verus is designed to be resistant to censorship, ensuring that all participants have a voice and can operate freely.\n\nVerus achieved a fair launch by avoiding common practices that can create unequal opportunities or unfair advantages. Specifically:\n\n* **No ICO**: Verus did not hold an Initial Coin Offering (ICO), which means that there was no pre-sale of tokens to a select group of investors.\n* **No founder or developer fees/tax**: Verus does not charge any fees or taxes to its founders or developers, ensuring that all participants have equal access to the platform.\n* **No premine**: Verus did not pre-mine any tokens, which means that all coins were mined fairly and transparently by the community.\n* **No commercial interests**: Verus is not driven by commercial interests, ensuring that the platform is focused on serving the community rather than generating profits.\n* **No rent-seeking behavior**: Verus is designed to prevent rent-seeking behavior, which means that participants are rewarded based on their contributions to the network rather than their ability to accumulate wealth.\n\nThe launch of the Verus blockchain was announced publicly on the Bitcointalk.org forum, giving everyone equal opportunity to participate and start mining and staking the Verus Protocol. This fair launch approach has contributed to Verus being one of the most decentralized networks worldwide.\n\nDo you have any further questions about Verus or its core principles?"], "AI Assistant", "", "N/A", [["What are the core principles and characteristics of Verus, and how did it achieve a fair launch?", "Verus is a decentralized public blockchain that operates on a set of core principles, which are designed to promote openness, accessibility, and fairness. These principles include:\n\n* **Decentralization**: Verus is a community-driven project, which means that anyone can participate and contribute, regardless of their background or location.\n* **Openness**: Verus is an open system, allowing anyone to start mining and staking the Verus Protocol without any hurdles or restrictions.\n* **Borderlessness**: Verus is a global platform, accessible to anyone with an internet connection.\n* **Public**: Verus is a public blockchain, meaning that all transactions and data are transparent and publicly available.\n* **Neutrality**: Verus is a neutral platform, free from commercial interests and rent-seeking behavior.\n* **Censorship resistance**: Verus is designed to be resistant to censorship, ensuring that all participants have a voice and can operate freely.\n\nVerus achieved a fair launch by avoiding common practices that can create unequal opportunities or unfair advantages. Specifically:\n\n* **No ICO**: Verus did not hold an Initial Coin Offering (ICO), which means that there was no pre-sale of tokens to a select group of investors.\n* **No founder or developer fees/tax**: Verus does not charge any fees or taxes to its founders or developers, ensuring that all participants have equal access to the platform.\n* **No premine**: Verus did not pre-mine any tokens, which means that all coins were mined fairly and transparently by the community.\n* **No commercial interests**: Verus is not driven by commercial interests, ensuring that the platform is focused on serving the community rather than generating profits.\n* **No rent-seeking behavior**: Verus is designed to prevent rent-seeking behavior, which means that participants are rewarded based on their contributions to the network rather than their ability to accumulate wealth.\n\nThe launch of the Verus blockchain was announced publicly on the Bitcointalk.org forum, giving everyone equal opportunity to participate and start mining and staking the Verus Protocol. This fair launch approach has contributed to Verus being one of the most decentralized networks worldwide.", "## Decentralized & community-built\nVerus is a decentralized public blockchain, a community driven project in the true spirit of Bitcoin. Anyone can participate and contribute, no matter who you are or where you come from. Verus is:\n* **Open**\n* **Borderless**\n* **Public**\n* **Neutral**\n* **Censorship resistant**\n\nAnyone can start mining and staking the Verus Protocol. Mobile phones and ARMs (e.g. Orange Pi 5) are the most energy efficient devices to mine Verus (and 22 other PBaaS-chains) with. To stake there are no minimum requirements or locking of funds.\n\nThere is no company behind Verus, it is community-built. All protocol fees go to the block producers of the network (the miners and stakers).\n\nThese characteristics that anyone can participate in the Verus Protocol makes it one of the most decentralized networks worldwide.\n\n## Fair launch\nVerus had a fair launch, meaning that everyone had, and still has equal opportunity to collect its currency through mining and staking. For Verus this means:\n* **No ICO has been held**\n* **No founder or developer fees/tax**\n* **No premine**\n* **No commercial interests**\n* **No rent-seeking behavior**\n\nThe launch of the Verus blockchain was announced on the Bitcointalk.org forum [See post](https://bitcointalk.org/index.php?topic=4070404.0) 15 minutes before the first block could be mined.\n\n::: tip Rich List\n[Take a look at the richlist to see coin distribution.](https://dexstats.info/richlist.php?asset=VRSC) \n:::", "./raw_text_input_docs/README_overview.md"]]], [["User:: I'm looking for a blockchain solution that can meet my needs for scalability, security, and interoperability. What are the key benefits of using Verus, and how does it address these concerns?", "AI Assistant:: Verus is an excellent choice for those looking for a robust blockchain solution. Verus offers several key benefits that make it an attractive solution for blockchain and cryptocurrency development. These benefits can be categorized into three main areas: scalability, security, and interoperability.\n\n**Scalability:**\nVerus achieves practically unlimited scalability through its Public Blockchains as a Service (PBaaS) feature. This allows for the creation of an unlimited number of independent, interoperable, and interconnected Layer 1 (L1) blockchains, each inheriting all Verus L1 features. This means that Verus can scale out transactions per second (TPS) to reach high levels, with a single PBaaS chain capable of reaching between 75 and 800 TPS depending on block time. Moreover, a network of several thousand chains would have a total bandwidth of 1 million+ TPS, making Verus highly scalable.\n\n**Security:**\nVerus and its PBaaS blockchains are 51% hash attack resistant, thanks to its Verus Proof of Power consensus algorithm. This ensures that the protocol is secure for both developers and users. Additionally, Verus uses smart transactions instead of smart contracts, which eliminates the risks associated with smart contracts.\n\n**Interoperability:**\nVerus enables a world where all blockchains can communicate with each other seamlessly. All PBaaS chains are interoperable and interconnected, allowing for the free flow of data and assets between them. Furthermore, Verus and all PBaaS chains are connected to Ethereum in a trustless and non-custodial way, thanks to the Verus Internet Protocol (VIP) and the Verus-Ethereum Bridge. This enables decentralized cross-chain communication and opens up new possibilities for blockchain-based applications.\n\nOverall, Verus offers a powerful solution for blockchain and cryptocurrency development, with its scalability, security, and interoperability features making it an attractive choice for developers and users alike. Do you have any further questions about Verus or its features?"], "AI Assistant", "", "N/A", [["What are the key benefits of using Verus, including its scalability, security, and interoperability features?", "Verus offers several key benefits that make it an attractive solution for blockchain and cryptocurrency development. These benefits can be categorized into three main areas: scalability, security, and interoperability.\n\n**Scalability:**\nVerus achieves practically unlimited scalability through its Public Blockchains as a Service (PBaaS) feature. This allows for the creation of an unlimited number of independent, interoperable, and interconnected Layer 1 (L1) blockchains, each inheriting all Verus L1 features. This means that Verus can scale out transactions per second (TPS) to reach high levels, with a single PBaaS chain capable of reaching between 75 and 800 TPS depending on block time. Moreover, a network of several thousand chains would have a total bandwidth of 1 million+ TPS, making Verus highly scalable.\n\n**Security:**\nVerus and its PBaaS blockchains are 51% hash attack resistant, thanks to its Verus Proof of Power consensus algorithm. This ensures that the protocol is secure for both developers and users. Additionally, Verus uses smart transactions instead of smart contracts, which eliminates the risks associated with smart contracts.\n\n**Interoperability:**\nVerus enables a world where all blockchains can communicate with each other seamlessly. All PBaaS chains are interoperable and interconnected, allowing for the free flow of data and assets between them. Furthermore, Verus and all PBaaS chains are connected to Ethereum in a trustless and non-custodial way, thanks to the Verus Internet Protocol (VIP) and the Verus-Ethereum Bridge. This enables decentralized cross-chain communication and opens up new possibilities for blockchain-based applications.\n\nOverall, Verus offers a powerful solution for blockchain and cryptocurrency development, with its scalability, security, and interoperability features making it an attractive choice for developers and users alike.", "* **No programming needed for [blockchain](/blockchains/), [token and currency launches](/currencies/)**\n* **Low protocol fees**## Scalability\nVerus achieves practically unlimited scalability through its [Public Blockchains as a Service](/blockchains/). Verus PBaaS enables the provisioning of an unlimited number of independent, interoperable and interconnected L1 blockchains, which inherit all Verus L1 features.Verus' scale out TPS (transactions-per-second) is better than what other blockchains have today. A single PBaaS chain can reach between 75 and 800 TPS depending on blocktime; a network of several thousand chains would have a total bandwidth of 1 million+ TPS. But there is no maximum TPS metric because such a thing does not exist on an open fractal network like Verus.* **Create use case specific blockchains and currencies** \n* **Move activity between chains to avoid congestion**## Security\nVerus and its PBaaS-blockchains are 51% hash attack resistant. All functionality can be found in the consensus layer (L1), making the protocol secure for developers and users. No smart contract risks \u2014 Verus uses smart transactions, not smart contracts.* **51% hash attack resistant through [Verus Proof of Power](/overview/verus-proof-of-power/)**\n* Read: [Verus Smart Transactions vs. Smart Contracts](https://medium.com/veruscoin/verus-smart-transactions-vs-smart-contracts-f98079c00ed0)## Interoperability\nVerus enables a world where all blockchains communicate with each other. All PBaaS-chains are interoperable and interconnected. Verus and all PBaaS-chains are now also connected to Ethereum, in a trustless and non-custodial way.* Read: [Verus Internet Protocol (VIP) \u2014 Provable, Decentralized Cross-chain Communication](https://medium.com/veruscoin/verus-internet-protocol-vip-provable-decentralized-cross-chain-communication-8d9414a429c5)\n* [Verus-Ethereum Bridge](/eth-bridge/)", "./raw_text_input_docs/README_overview.md"]]], [["User:: Hi, I'm planning to launch a new currency on Verus and I'd like to know the requirements and steps to do so with a 1:1 mapping to an ERC-20 token on Ethereum. Can you guide me through the process?", "AI Assistant:: Launching a new currency on Verus with a 1:1 mapping to an ERC-20 token on Ethereum involves several steps. Here's a detailed guide to help you through the process:\n\n**Step 1: Create a VerusID**\nTo create a currency, you need a VerusID with the same name as the currency you want to launch. The controller of this VerusID is the only one who can create a currency of that name, and this can only be done once. The cost for a VerusID on Verus is 100 VRSC (or 80 VRSC when using a referral).\n\n**Step 2: Register a.vETH subID (Optional)**\nAlternatively, you can use a.vETH subID, which costs 0.01 vETH worth of Bridge.vETH to register.\n\n**Step 3: Prepare the VerusID namespace**\nBefore launching the currency, ensure you have enough VRSC in the namespace VerusID.\n\n**Step 4: Define the currency**\nTo define the currency, you need to map it to an ERC-20 token on Ethereum using a command like the one shown in the example. The `address` field should contain the Ethereum smart contract address of the ERC-20 token you want to map to.\n\n**Example Command:**\nThe command to map a currency 1:1 to an ERC-20 on Ethereum is:\n```\n./verus -chain=VRSCTEST definecurrency '{\"name\":\"MyUSDC\",\"options\":33, \"proofprotocol\":2,\"currencies\":[\"vrsctest\", \"usdc\"],\"minpreconversion\":[10000,5.1298]}, \"initialsupply\":20000}'\n```\n**Using the Verus-Ethereum Bridge:**\nTo use the Verus-Ethereum Bridge, you can access the testnet bridge at [https://ethbridge.verustest.net/](https://ethbridge.verustest.net/) or the mainnet bridge at [https://eth.verusbridge.io](https://eth.verusbridge.io).\n\n**Getting Help:**\nIf you need help setting up a currency launch, you can reach out to the Verus community on the #pbaas-development channel on Discord at [https://www.verus.io/discord](https://www.verus.io/discord).\n\nDo you have any questions about these steps or need further clarification on any of them?"], "AI Assistant", "", "N/A", [["What are the requirements and steps to launch a new currency on Verus with a 1:1 mapping to an ERC-20 token on Ethereum?", "Launching a new currency on Verus with a 1:1 mapping to an ERC-20 token on Ethereum involves several steps. Here's a detailed guide to help you through the process:\n\n**Step 1: Create a VerusID**\nTo create a currency, you need a VerusID with the same name as the currency you want to launch. The controller of this VerusID is the only one who can create a currency of that name, and this can only be done once. The cost for a VerusID on Verus is 100 VRSC (or 80 VRSC when using a referral).\n\n**Step 2: Register a.vETH subID (Optional)**\nAlternatively, you can use a.vETH subID, which costs 0.01 vETH worth of Bridge.vETH to register.\n\n**Step 3: Prepare the VerusID namespace**\nBefore launching the currency, ensure you have enough VRSC in the namespace VerusID.\n\n**Step 4: Define the currency**\nTo define the currency, you need to map it to an ERC-20 token on Ethereum using a command like the one shown in the example. The `address` field should contain the Ethereum smart contract address of the ERC-20 token you want to map to.\n\n**Example Command:**\nThe command to map a currency 1:1 to an ERC-20 on Ethereum is:\n```\n./verus -chain=VRSCTEST definecurrency '{\"name\":\"MyUSDC\",\"options\":33, \"proofprotocol\":2,\"currencies\":[\"vrsctest\", \"usdc\"],\"minpreconversion\":[10000,5.1298]}, \"initialsupply\":20000}'\n```\n**Using the Verus-Ethereum Bridge:**\nTo use the Verus-Ethereum Bridge, you can access the testnet bridge at [https://ethbridge.verustest.net/](https://ethbridge.verustest.net/) or the mainnet bridge at [https://eth.verusbridge.io](https://eth.verusbridge.io).\n\n**Getting Help:**\nIf you need help setting up a currency launch, you can reach out to the Verus community on the #pbaas-development channel on Discord at [https://www.verus.io/discord](https://www.verus.io/discord).", "# Launch currency with 1:1 mapping of ERC-20When defining a currency it can be mapped to an ERC-20 1:1. The currency on Verus and the ERC-20 on Ethereum are then always interchangeable 1 to 1. [More on the Verus-Ethereum Bridge.](/eth-bridge/)::: tip \u2194\ufe0f Verus-Ethereum Bridge \ud83d\udc68\u200d\ud83d\udd27 For Testnet!\n[\ud83d\udc49 Access the Verus-Ethereum Testnet Bridge](https://ethbridge.verustest.net/) (\u26a0\ufe0f Goerli testnet)\n:::::: tip \u2194\ufe0f Verus-Ethereum Bridge \u2705 For Mainnet!\n[\ud83d\udc49 Access the Verus-Ethereum Mainnet Bridge](https://eth.verusbridge.io)\n:::::: warning Need help setting up a currency launch? \ud83e\udd14\n[\ud83d\udc49 Go to the Verus Discord #pbaas-development channel. The community is happy to assist!](https://www.verus.io/discord)\n:::### Defining the currency\nTo create a currency of a specific name, we need a VerusID of the same name. The controller of this VerusID is the only one who can create a currency of that name, and we can only do so once.The cost for a VerusID on the Verus is ``100 VRSC`` (or 80 when using a referral). The cost to launch a currency is ``200 VRSC``. Before launching we need to have enough VRSC in the namespace VerusID.You can also use a .vETH subID. The cost to register a .vETH subID is an amount of Bridge.vETH (0.01 vETH worth).In our example we have a namespace ``MyUSDC`` with which we want to launch a currency that is mapped to the Ethereum ``USDC`` ERC-20 (on Goerli testnet, [see contract address](https://goerli.etherscan.io/address/0x98339D8C260052B7ad81c28c16C0b98420f2B46a)).Below is the command to map a currency 1:1 to an ERC-20 on Ethereum. The ``address`` field is the Ethereum smart contract address of the ERC-20 we want to map to.", "./raw_text_input_docs/mapping-1:1-eth.md"]]], [["User:: I'm interested in learning more about the Verus Marketplace. Can you explain how it enables private, escrow-free transactions for buying and selling VerusIDs and other assets, and what are the main RPC APIs used for this purpose?", "AI Assistant:: The Verus Marketplace is a powerful platform that enables secure, private, and trustless transactions for buying and selling VerusIDs and other assets.\n\nThe Verus Marketplace provides a platform for private, escrow-free transactions for buying and selling VerusIDs and other assets. This is achieved through the use of zero-knowledge transactions and a decentralized, peer-to-peer marketplace.\n\nHere's how it works: instead of posting an offer on the blockchain, parties can negotiate and agree on a transaction privately, and only then commit it to the blockchain. This allows for secure, trustless transactions without the need for intermediaries or escrow services.\n\nThe Verus Marketplace also enables the creation of complex contracts and agreements, such as those that grant access to exclusive content in exchange for payment. These contracts can be embedded in VerusIDs, which can represent any kind of asset.\n\nNow, to facilitate these private transactions, the Verus Marketplace uses several RPC APIs. The main ones are:\n\n* `makeoffer`: This API allows users to define what they are offering (e.g. funds, VerusIDs, or other currencies) and what they want in return. It also enables users to specify the VerusID or amount they want in exchange for their offer, and the currency they want to use.\n* `takeoffer`: This API allows users to accept a specific offer in exchange for its requested payment.\n* `getoffers`: This API allows users to search for offers related to a specific VerusID or currency. It returns all offers (buy and sell) in all currencies, sorted by highest to lowest price.\n* `closeoffers`: This API allows users to close expired or unexpired offers that they opened with `makeoffer`.\n* `listopenoffers`: This API lists all offers that a user has opened with `makeoffer`.\n\nIn addition to these APIs, VerusIDs can also contain pointers to private \"z-addresses\", which are not publicly visible on the blockchain. This adds an extra layer of privacy to transactions, as users can attach any z-address to a VerusID.\n\nDo you have any more questions about the Verus Marketplace, or would you like me to elaborate on any of these APIs?"], "AI Assistant", "", "N/A", [["How does the Verus Marketplace enable private, escrow-free transactions for buying and selling VerusIDs and other assets, and what are the main RPC APIs used for this purpose?", "The Verus Marketplace provides a platform for private, escrow-free transactions for buying and selling VerusIDs and other assets. This is achieved through the use of zero-knowledge transactions and a decentralized, peer-to-peer marketplace.\n\nHere's how it works: instead of posting an offer on the blockchain, parties can negotiate and agree on a transaction privately, and only then commit it to the blockchain. This allows for secure, trustless transactions without the need for intermediaries or escrow services.\n\nThe Verus Marketplace also enables the creation of complex contracts and agreements, such as those that grant access to exclusive content in exchange for payment. These contracts can be embedded in VerusIDs, which can represent any kind of asset.\n\nThe main RPC APIs used for this purpose are:\n\n* `makeoffer`: This API allows users to define what they are offering (e.g. funds, VerusIDs, or other currencies) and what they want in return. It also enables users to specify the VerusID or amount they want in exchange for their offer, and the currency they want to use.\n* `takeoffer`: This API allows users to accept a specific offer in exchange for its requested payment.\n* `getoffers`: This API allows users to search for offers related to a specific VerusID or currency. It returns all offers (buy and sell) in all currencies, sorted by highest to lowest price.\n* `closeoffers`: This API allows users to close expired or unexpired offers that they opened with `makeoffer`.\n* `listopenoffers`: This API lists all offers that a user has opened with `makeoffer`.\n\nIn addition to these APIs, VerusIDs can also contain pointers to private \"z-addresses\", which are not publicly visible on the blockchain. This adds an extra layer of privacy to transactions, as users can attach any z-address to a VerusID.", "In addition to advertising worldwide on the blockchain to buy or sell VerusIDs, you can also make an exchange with the Marketplace without ever posting the offer on the blockchain until it is agreed and signed by all parties. Combine that with zero knowledge transactions, and it's a great way to transact worldwide, escrow-free in private.:::tip Use Case Example\nA business sells subscriptions for exclusive content. They make VerusIDs with contracts that give access to the exclusive content. They now create a transaction that would pay for the VerusID. They give the transaction to the buyer who then executes it. The buyer now owns the VerusID that gives access to the exclusive content.\n:::Now imagine how you can do this for a VerusID that can be any kind of asset. A new way for everyone to engage in peer-to-peer, escrow-free commerce has arrived.### RPC APIs\n| API | What it does | \n| :- |:-----|\n| makeoffer | define what you offer and for what. What you offer can be funds, VerusIDs, or when PBaaS goes live even other currencies. What you want in return can also be funds, VerusIDs or currencies. In exchange for what you offer, you also define what VerusID or how much you want for it and in what currency | \n| takeoffer | take a specific offer in exchange for its request | \n| getoffers | specify which VerusID or currency you want to see offers for or on offer, and it returns all offers (buy and sell) in all currencies, sorted by highest to lowest price | \n| closeoffers | close expired or unexpired offers which you opened with makeoffer |\n| listopenoffers | list all offers that you have opened with makeoffer |## Privacy\nA VerusID can contain a pointer to a ``z-address``. These are private addresses that can not be checked on the public blockchain. Attach any z-address to a VerusID.", "./raw_text_input_docs/README_addresses.md"]]], [["User:: I've been wondering about the different types of addresses in Verus and how they impact transaction privacy. Can you explain the differences between public and private addresses in Verus, and how they impact transaction privacy?", "AI Assistant:: I'd be happy to clarify the differences between public and private addresses in Verus and their impact on transaction privacy.\n\nIn the Verus ecosystem, there are two main types of addresses: public and private. Understanding the distinctions between these address types is crucial for making informed decisions about transaction privacy.\n\n**Public Addresses:**\nPublic addresses are used to send and receive funds, and their transactions are visible on blockchain explorers because they are recorded on the public ledger. There are three types of public addresses in Verus:\n\n1. **R-address**: A R-address is a public cryptocurrency address derived from a private key. The private key is essential for accessing and controlling the R-address.\n2. **VerusID@**: A VerusID is a public friendly-name cryptocurrency address. It is controlled by a primary address, which is a R-address.\n3. **i-address**: An i-address is a public cryptocurrency address derived from a VerusID.\n\n**Private Addresses:**\nPrivate addresses, on the other hand, are used for confidential exchange of funds and data. There is one type of private address in Verus:\n\n1. **z-address**: A z-address is a private cryptocurrency address derived from a private key. The private key is essential for accessing and controlling the z-address. Only the person who has the private key can spend and see its balance, or provide visibility in the balance through a \"viewing key\".\n\n**Key Differences:**\nThe main differences between public and private addresses are:\n\n* **Transaction visibility**: Public addresses and their transactions are visible on blockchain explorers, while private addresses and their transactions are confidential and do not appear on the blockchain or any explorer.\n* **Address control**: Public addresses are controlled by a primary address, which is a R-address, while private addresses are controlled by a private key.\n* **Balance visibility**: Only the person who has the private key can see the balance of a private address, while the balance of a public address is visible to anyone.\n\nIt's worth noting that a VerusID can contain a pointer to a z-address, allowing you to send coins to \"VerusID@:private\", which provides an additional layer of privacy.\n\nDo you have any further questions about public and private addresses, or how they impact transaction privacy in Verus?"], "AI Assistant", "", "N/A", [["What are the differences between public and private addresses in Verus, and how do they impact transaction privacy?", "In the Verus ecosystem, there are two main types of addresses: public and private. Understanding the distinctions between these address types is crucial for making informed decisions about transaction privacy.\n\n**Public Addresses:**\nPublic addresses are used to send and receive funds, and their transactions are visible on blockchain explorers because they are recorded on the public ledger. There are three types of public addresses in Verus:\n\n1. **R-address**: A R-address is a public cryptocurrency address derived from a private key. The private key is essential for accessing and controlling the R-address.\n2. **VerusID@**: A VerusID is a public friendly-name cryptocurrency address. It is controlled by a primary address, which is a R-address.\n3. **i-address**: An i-address is a public cryptocurrency address derived from a VerusID.\n\n**Private Addresses:**\nPrivate addresses, on the other hand, are used for confidential exchange of funds and data. There is one type of private address in Verus:\n\n1. **z-address**: A z-address is a private cryptocurrency address derived from a private key. The private key is essential for accessing and controlling the z-address. Only the person who has the private key can spend and see its balance, or provide visibility in the balance through a \"viewing key\".\n\n**Key Differences:**\nThe main differences between public and private addresses are:\n\n* **Transaction visibility**: Public addresses and their transactions are visible on blockchain explorers, while private addresses and their transactions are confidential and do not appear on the blockchain or any explorer.\n* **Address control**: Public addresses are controlled by a primary address, which is a R-address, while private addresses are controlled by a private key.\n* **Balance visibility**: Only the person who has the private key can see the balance of a private address, while the balance of a public address is visible to anyone.\n\nIt's worth noting that a VerusID can contain a pointer to a z-address, allowing you to send coins to \"VerusID@:private\", which provides an additional layer of privacy.", "# Introduction\nIn Verus, there are two kinds of addresses: **public** and **private**. This doc guides you through understanding these address types and how they're involved in transactions.Understanding the distinctions between public and private addresses in the Verus ecosystem is crucial for making informed decisions about transaction privacy.## Public addresses\nYou can use the following public address types to send and receive funds.| Address type | Details | \n| :-----| :------ | \n| **R-address** | A R-address is a public cryptocurrency address derived from a private key. The private key is essential for accessing and controlling the R-address.| \n| [**VerusID@**](/verusid/) | A VerusID is a public friendly-name cryptocurrency address. It is controlled by a primary address, which is a R-address.| \n| **i-address** | An i-address is a public cryptocurrency address derived from a VerusID.|Public addresses and their transactions are visible on blockchain explorers because they're recorded on the public ledger, unlike private z-addresses.## Private addresses\nYou can use the following private address type for confidential exchange of funds and data.| Address type | Details | \n| :-----| :------ | \n| **z-address** | A z-address is a private cryptocurrency address derived from a private key. The private key is essential for accessing and controlling the z-address. Only the person who has the private key can spend and see its balance. Or provide visibility in the balance through a ``viewing key``. |Balances and transactions associated with private addresses are confidential. They do not appear on the blockchain or any explorer.\u2139\ufe0f A VerusID can contain a pointer to a z-address. You can then send coins to ``VerusID@:private``.", "./raw_text_input_docs/README.md"]]], [["User:: I'm trying to understand VerusIDs better. Can you tell me about the different types of VerusIDs, and how they're recognized on the Verus blockchain network or by compatible applications?", "AI Assistant:: I'd be happy to explain the different types of VerusIDs and how they're recognized.\n\nThere are two main types of VerusIDs: those defined on the Verus network and those defined on independent PBaaS (Public Blockchains as a Service) blockchains that are spawned from and registered on the Verus blockchain network. Additionally, there are VerusIDs that may exist on fully external systems that were created without any registration on the Verus network initially.\n\nFor a VerusID created on an external system to be recognized on the Verus blockchain network or by applications using the VDXF (Verus Data eXchange Format) that are compatible with the Verus blockchain network, the external system must provide a recognized bridge to the Verus blockchain.\n\nTo understand how VerusIDs are recognized, it's essential to understand the requirements of registered VerusID identity names. The VDXF only defines compatibility requirements for the naming systems and how those names translate into recognizable IDs on the Verus network, but does not require compatibility of the internal structure of IDs across different systems.\n\nA VDXF object is a serialized byte array that can be written to or interpreted by any system, given the appropriate libraries for handling its format. The serialization process transforms structured data into a byte stream, while deserialization reverses this process, reconstructing the original structured data from the byte stream.\n\nThe VDXF object consists of several key components encoded into bytes, which are essential for recognizing and verifying VerusIDs on the Verus blockchain network and by compatible applications.\n\nDo you have any further questions about VerusIDs, their types, or how they're recognized on the Verus network?"], "AI Assistant", "", "N/A", [["What are the different types of VerusIDs, and how are they recognized on the Verus blockchain network or by compatible applications?", "There are two main types of VerusIDs: those defined on the Verus network and those defined on independent PBaaS (Public Blockchains as a Service) blockchains that are spawned from and registered on the Verus blockchain network. Additionally, there are VerusIDs that may exist on fully external systems that were created without any registration on the Verus network initially.\n\nFor a VerusID created on an external system to be recognized on the Verus blockchain network or by applications using the VDXF (Verus Data eXchange Format) that are compatible with the Verus blockchain network, the external system must provide a recognized bridge to the Verus blockchain.\n\nIn order to understand how VerusIDs are recognized, it's essential to understand the requirements of registered VerusID identity names. The VDXF only defines compatibility requirements for the naming systems and how those names translate into recognizable IDs on the Verus network, but does not require compatibility of the internal structure of IDs across different systems.\n\nA VDXF object is a serialized byte array that can be written to or interpreted by any system, given the appropriate libraries for handling its format. The serialization process transforms structured data into a byte stream, while deserialization reverses this process, reconstructing the original structured data from the byte stream.\n\nThe VDXF object consists of several key components encoded into bytes, which are essential for recognizing and verifying VerusIDs on the Verus blockchain network and by compatible applications.", "Generally, one may think of two types of VerusIDs, those defined on the Verus network or on independent PBaaS (Public Blockchains as a Service) blockchains spawned originally from and registered on the Verus blockchain network, or VerusIDs, which may also exist on fully external systems that may have been created without any registration on the Verus network initially. In order for an externally created VerusID to be recognizable on the Verus blockchain network or by applications using the VDXF that are compatible with the Verus blockchain network that external system must provide a recognized bridge to the Verus blockchain.First, it is important to understand the requirements of registered VerusID identity names, which will also inform how externally generated VerusIDs are recognized as well. For the purposes of the VDXF, we do not require compatibility of the internal structure of IDs across different systems, and only define compatibility requirements of the naming systems and how those names translate into recognisable IDs on the Verus network.## ImplementationA VDXF object is fundamentally a serialized byte array that can be written to or interpreted by any system, given the appropriate libraries for handling its format. The serialization process transforms structured data into a byte stream, while deserialization reverses this process, reconstructing the original structured data from the byte stream.### Key ComponentsThe VDXF object comprises several key components encoded into bytes:", "./raw_text_input_docs/README_vdxf.md"]]], [["User:: I'm creating a new currency using Verus, and I'm not entirely sure about the \"preallocations\" and \"prelaunchcarveout\" parameters. Can you explain their purposes and effects when defining a currency? Additionally, what are some general guidelines for setting currency supplies?", "AI Assistant:: When defining a currency using Verus, the \"preallocations\" and \"prelaunchcarveout\" parameters serve important purposes, and I'd be happy to explain them in detail.\n\n**Preallocations:**\nThe \"preallocations\" parameter allows you to specify an amount of funds to be directed to a specific VerusID or R-address after the preconversion time frame has passed and the currency is launched. This can be used with both simple token currencies and basket currencies. When used with basket currencies, the reserve ratio of the currency will be lowered after launch, as new currency is minted and nothing is added to the reserves. For example, in the command `./verus -chain=VRSCTEST definecurrency '{ \"name\":\"SocialBrand\", \"options\":33, \"currencies\":[\"vrsctest\"], \"initialsupply\":500, \"preallocations\":[{\"Max@\":1000}]}', Max@ will receive 1000 SocialBrand after launch, reducing the reserve ratio of the currency.\n\n**Prelaunchcarveout:**\nThe \"prelaunchcarveout\" parameter only works with basket currencies (`options:33`). It allows you to redirect a percentage of preconverted reserves to the rootID after the preconversion time frame has passed and the currency is launched. This also lowers the reserve ratio, making the currency more volatile.\n\n**Guidelines for Setting Currency Supplies:**\nIt's essential to set currency supplies within a reasonable limit to prevent potential issues. The recommended absolute limit for all currency supplies is 10 billion (minus 1 satoshi) with 8 decimal places (9999999999.99999999). This limit applies to all currency supplies, including those that will be extended over time with conversions and tail emissions for blockchains.\n\nDo you have any more questions about these parameters or setting currency supplies?"], "AI Assistant", "", "N/A", [["What are the purposes and effects of the \"preallocations\" and \"prelaunchcarveout\" parameters when defining a currency using Verus, and what are some general guidelines for setting currency supplies?", "When defining a currency using Verus, the \"preallocations\" and \"prelaunchcarveout\" parameters serve important purposes.\n\n**Preallocations:**\nThe \"preallocations\" parameter allows you to specify an amount of funds to be directed to a specific VerusID or R-address after the preconversion time frame has passed and the currency is launched. This can be used with both simple token currencies and basket currencies. When used with basket currencies, the reserve ratio of the currency will be lowered after launch, as new currency is minted and nothing is added to the reserves. For example, in the command `./verus -chain=VRSCTEST definecurrency '{ \"name\":\"SocialBrand\", \"options\":33, \"currencies\":[\"vrsctest\"], \"initialsupply\":500, \"preallocations\":[{\"Max@\":1000}]}', Max@ will receive 1000 SocialBrand after launch, reducing the reserve ratio of the currency.\n\n**Prelaunchcarveout:**\nThe \"prelaunchcarveout\" parameter only works with basket currencies (`options:33`). It allows you to redirect a percentage of preconverted reserves to the rootID after the preconversion time frame has passed and the currency is launched. This also lowers the reserve ratio, making the currency more volatile.\n\n**Guidelines for Setting Currency Supplies:**\nIt's essential to set currency supplies within a reasonable limit to prevent potential issues. The recommended absolute limit for all currency supplies is 10 billion (minus 1 satoshi) with 8 decimal places (9999999999.99999999). This limit applies to all currency supplies, including those that will be extended over time with conversions and tail emissions for blockchains.", "Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"SocialBrand\", \n \"options\":33, \"currencies\":[\"vrsctest\"], \n \"initialsupply\":500, \n \"preallocations\":[{\"Max@\":1000}]\n}'\n```\n\u261d\ufe0f This is a basket currency called SocialBrand. People can preconvert VRSCTEST into its reserves and in return they get 500 SocialBrand distributed among them. Immediately after launch Max@ receives 1000 SocialBrand, lowering the reserve ratio of the currency.### **\"preallocations\"**\nUse this parameter to receive a chosen amount of funds after the preconversion time frame has passed and the currency is launched. Funds can be directed to VerusIDs and R-addresses. Works with simple token currencies and basket currencies.When using this parameter with basket currencies, after the preconversion time frame has passed and the currency is launched, the reserve ratio is lowered. This is because new currency has been minted after the initial supply (`\"initialsupply\"`) is distributed, and nothing was new added into the reserves.::: danger Limit for all currency supplies (10 billion)\n10 billion (minus 1 satoshi) with 8 decimal places (9999999999.99999999) is now the recommended absolute limit for all currency supplies, including over time with conversions and extended tail emissions for blockchains.\n:::### **\"prelaunchcarveout\"**\nOnly works with basket currencies (`options:33`). Use this to redirect a percentage of preconverted reserves to the rootID.\nAfter the preconversion time frame has passed and the currency is launched, a percentage of the reserves is taken and redirected to the rootID. This lowers the reserve ratio, making the currency more volatile.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I've been trying to understand how different systems and applications can exchange information with each other, and I came across the term Verus Data eXchange Format (VDXF). Can you explain what VDXF is and how it enables the exchange of information across different systems and programming languages?", "AI Assistant:: The Verus Data eXchange Format (VDXF) is a crucial component of the Verus ecosystem, and it's great that you're interested in learning more about it.\n\nThe Verus Data eXchange Format (VDXF) is a standardized format for representing and exchanging data between different systems and applications, whether they are centralized or decentralized. VDXF provides a way to define globally unique data types, which can consist of structured or unstructured data, and associate them with content or keys that can be used to retrieve the data from various storage locations.\n\nA VDXF object is a structured representation of data that is serialized into a byte format, making it easy to transmit or store. This format enables application developers to define data types and publish references to them, which can be used by other applications to understand and work with the data, even if they don't know how to process the entire dataset.\n\nVDXF type keys are globally unique identifiers that are defined as human-readable names, along with a specification for converting these names into collision-free 20-byte IDs. These IDs can be used as type keys associated with content or location values in various forms of data records.\n\nThe VDXF format is designed to be interoperable, meaning that applications can use the data in whole or in part, even if they don't understand the entire dataset. This is achieved by providing a way to define and exchange data types, along with the associated content or keys, which can be used to retrieve and process the data.\n\nIn summary, VDXF provides a standardized way to represent and exchange data between different systems and applications, enabling interoperability and facilitating the development of decentralized applications.\n\nDo you have any more questions about VDXF, or how it can be used in practice?"], "AI Assistant", "", "N/A", [["What is the Verus Data eXchange Format (VDXF), and how does it enable the exchange of information across different systems and programming languages?", "The Verus Data eXchange Format (VDXF) is a standardized format for representing and exchanging data between different systems and applications, whether they are centralized or decentralized. VDXF provides a way to define globally unique data types, which can consist of structured or unstructured data, and associate them with content or keys that can be used to retrieve the data from various storage locations.\n\nA VDXF object is a structured representation of data that is serialized into a byte format, making it easy to transmit or store. This format enables application developers to define data types and publish references to them, which can be used by other applications to understand and work with the data, even if they don't know how to process the entire dataset.\n\nVDXF type keys are globally unique identifiers that are defined as human-readable names, along with a specification for converting these names into collision-free 20-byte IDs. These IDs can be used as type keys associated with content or location values in various forms of data records.\n\nThe VDXF format is designed to be interoperable, meaning that applications can use the data in whole or in part, even if they don't understand the entire dataset. This is achieved by providing a way to define and exchange data types, along with the associated content or keys, which can be used to retrieve and process the data.\n\nIn summary, VDXF provides a standardized way to represent and exchange data between different systems and applications, enabling interoperability and facilitating the development of decentralized applications.", "# Verus Data eXchange Format (VDXF)The Verus Data Exchange Format provides a fully interoperable system for defining data types that may consist of structured or or unstructured data and associated content or keys that may be used to retrieve such data from centralized or decentralized storage for use in and across centralized or decentralized applications.The Verus Data eXchange Format (VDXF) object is a structured data representation of the Verus Data eXchange Format, designed to facilitate the exchange of information across different systems and programming languages. It encapsulates data in a serialized byte format, making it interoperable and easy to transmit or store. This document outlines the structure and functionality of a VDXF object, focusing on its serialized form rather than the methods used to manipulate it in any specific programming language.## OverviewThe Verus Data Exchange Format enables application developers to define globally unique data types and publish references to the same, which may refer to structured or unstructured data that can be located unambiguously via an URL, which implicitly provides both location and decoding information, enabling applications to use such data, in whole or in part, if they know how, or even ignore parts of the data, while remaining compatible with those parts they understand. VDXF typee keys are globally unique identifiers, which are defined as human readable names along with a specification of how to define and convert unlimited length, human readable type names into collison-free 20 byte IDs, which can be used as type keys associated with content or location values in various forms of data records. These data records, which may have application specific structures or no structure at all, besides length form the basis of an interoperable data exchange format across decentralized applications.", "./raw_text_input_docs/README_vdxf.md"]]], [["User:: I'm trying to update my VerusID with a timelock and a DelayLock, but I'm not sure how to do it. Could you walk me through the process and explain the implications of using these features?", "AI Assistant:: I'd be happy to help.\n\nTo update a VerusID with a timelock, you can use the `updateidentity` command in the Verus Desktop command-line interface. A timelock is a feature that locks a VerusID for a specified period of time, preventing the funds associated with it from being spent. To set a timelock, you need to specify the following parameters:\n\n* `name`: The name of your VerusID, without the `@` symbol.\n* `primaryaddress`: The R-address of your VerusID, which can be found in the \"VerusID\" tab of the Verus Desktop interface.\n* `timelock`: The number of blocks that the VerusID will be locked for. For example, to lock the VerusID for approximately 1 year, you would set `timelock` to `1534360`.\n\nHere is an example of the command:\n```json\nupdateidentity\n'{\n\"name\":\"youridentityname\",\n\"minimumsignatures\":1,\n\"primaryaddresses\":[\"primary-address-comes-here\"],\n\"flags\":0,\n\"timelock\":1534360\n}'\n```\nA DelayLock is a type of timelock that allows you to specify a delay period before the VerusID can be unlocked. To set a DelayLock, you need to specify the same parameters as for a timelock, but with a different value for `timelock`. For example, to set a DelayLock of 1 week, you would set `timelock` to `10080`, which is the number of blocks in a week (1440 blocks per day x 7 days).\n\nIt's important to note that you can always revoke and recover a locked VerusID, which means that you can regain control of the associated funds if needed.\n\nBy using a timelock or DelayLock, you can add an extra layer of security to your VerusID and prevent unauthorized access to your funds. However, it's essential to carefully consider the implications of using these features, as they can also limit your ability to access your funds for a specified period of time.\n\nDo you have any more questions about updating your VerusID with a timelock or DelayLock, or would you like me to clarify any of the implications of using these features?"], "AI Assistant", "", "N/A", [["How do I update a VerusID with a timelock and a DelayLock, and what are the implications of using these features?", "To update a VerusID with a timelock, you can use the `updateidentity` command in the Verus Desktop command-line interface. A timelock is a feature that locks a VerusID for a specified period of time, preventing the funds associated with it from being spent. To set a timelock, you need to specify the following parameters:\n\n* `name`: The name of your VerusID, without the `@` symbol.\n* `primaryaddress`: The R-address of your VerusID, which can be found in the \"VerusID\" tab of the Verus Desktop interface.\n* `timelock`: The number of blocks that the VerusID will be locked for. For example, to lock the VerusID for approximately 1 year, you would set `timelock` to `1534360`.\n\nHere is an example of the command:\n```json\nupdateidentity \n'{\n  \"name\":\"youridentityname\",\n  \"minimumsignatures\":1,\n  \"primaryaddresses\":[\"primary-address-comes-here\"],\n  \"flags\":0,\n  \"timelock\":1534360\n}'\n```\nA DelayLock is a type of timelock that allows you to specify a delay period before the VerusID can be unlocked. To set a DelayLock, you need to specify the same parameters as for a timelock, but with a different value for `timelock`. For example, to set a DelayLock of 1 week, you would set `timelock` to `10080`, which is the number of blocks in a week (1440 blocks per day x 7 days).\n\nIt's important to note that you can always revoke and recover a locked VerusID, which means that you can regain control of the associated funds if needed.\n\nBy using a timelock or DelayLock, you can add an extra layer of security to your VerusID and prevent unauthorized access to your funds. However, it's essential to carefully consider the implications of using these features, as they can also limit your ability to access your funds for a specified period of time.", "- Under ``timelock`` you put ``1508994``\n- Under ``name`` you put your VerusID name without ``@``\n- Under ``primaryaddress`` you put the R-address which is the primary address of your VerusID (you can find this address in the 'VerusID'-tab, open your VerusID and click `ID Info')So in our example your VerusID is locked for approximately for 1 year. After that period of time the funds can be spent again.``` json\nrun updateidentity \n'{\n  \"name\":\"youridentityname\",\n  \"minimumsignatures\":1,\n  \"primaryaddresses\":[\"primary-address-comes-here\"],\n  \"flags\":0,\n  \"timelock\":1534360\n}'\n```You can copy and paste this code snippet into the commandline interface of Verus Desktop and edit the necessary inputs for your needs. In the code snippet are the minimum requirements to update your VerusID with a lock.:::tip Revoke & Recover\nRemember: you can always revoke and recover a locked VerusID.\n:::## Vault with DelayLock\n![image-delaylock](/images/delaylock.png)\nNow let's put a DelayLock on a VerusID. This means that you lock the identity, and when you request the identity to be unlocked, a predetermined number of blocks have to pass before you can actually spend the funds again.### Set the DelayLock\nLet's say you want to put a Delaylock of 1 week. 1 week is ``10,080`` blocks (1440x7). This will lock the identity, and when you requested an unlock, it takes 1 week (or 10,080 blocks) before the funds can be spent again.- Under ``timelock`` you put ``10080``\n- Under ``name`` you put your VerusID name without ``@``\n- Under ``primaryaddress`` you put the R-address which is the primary address of your VerusID (you can find this address in the 'VerusID'-tab, open your VerusID and click `ID Info')", "./raw_text_input_docs/setup-vault.md"]]], [["User:: I've been hearing a lot about DeFi and its potential, but I'm also concerned about the security and fairness of these transactions. Can you explain how the Verus protocol improves security and fairness in DeFi transactions, and what are the benefits of its simultaneous transaction processing within a block?", "AI Assistant:: The Verus protocol takes a unique approach to DeFi transaction processing, which provides increased security and fairness for all users. By implementing DeFi at the protocol level, Verus ensures that the most critical security layers are integrated into the system itself, rather than relying on external applications or services.\n\nOne of the key benefits of the Verus protocol is its ability to process all transactions within a block simultaneously, rather than serially as is the case with other systems like Ethereum. This approach has several important implications:\n\n* **MEV-resistance**: Verus eliminates the possibility of front-running, back-running, and sandwich attacks, which are common vulnerabilities in traditional DeFi systems. These attacks rely on the serial processing of transactions, allowing malicious actors to exploit price differences or manipulate market conditions. By processing all transactions simultaneously, Verus removes the opportunity for these attacks to occur.\n* **Enhanced liquidity and reduced slippage**: When multiple conversions to and from a currency occur within the same block, they are offset against each other, enhancing system-wide liquidity and reducing slippage. This means that users can convert between currencies with greater efficiency and accuracy, reducing the impact of market fluctuations.\n* **Fair pricing**: The simultaneous processing of transactions within a block ensures that all users converting to and from a currency within that block receive the same fair price, with no spread. This eliminates the possibility of price manipulation or exploitation, providing a more equitable and transparent DeFi experience.\n\nOverall, the Verus protocol's simultaneous transaction processing and MEV-resistance features provide a more secure, fair, and efficient DeFi ecosystem, enabling users to transact with confidence and trust.\n\nDo you have any further questions about how Verus improves DeFi security and fairness, or would you like to know more about its implications for the DeFi space?"], "AI Assistant", "", "N/A", [["How does the Verus protocol improve security and fairness in DeFi transactions, and what are the benefits of its simultaneous transaction processing within a block?", "The Verus protocol takes a unique approach to DeFi transaction processing, which provides increased security and fairness for all users. By implementing DeFi at the protocol level, Verus ensures that the most critical security layers are integrated into the system itself, rather than relying on external applications or services.\n\nOne of the key benefits of the Verus protocol is its ability to process all transactions within a block simultaneously, rather than serially as is the case with other systems like Ethereum. This approach has several important implications:\n\n* **MEV-resistance**: Verus eliminates the possibility of front-running, back-running, and sandwich attacks, which are common vulnerabilities in traditional DeFi systems. These attacks rely on the serial processing of transactions, allowing malicious actors to exploit price differences or manipulate market conditions. By processing all transactions simultaneously, Verus removes the opportunity for these attacks to occur.\n* **Enhanced liquidity and reduced slippage**: When multiple conversions to and from a currency occur within the same block, they are offset against each other, enhancing system-wide liquidity and reducing slippage. This means that users can convert between currencies with greater efficiency and accuracy, reducing the impact of market fluctuations.\n* **Fair pricing**: The simultaneous processing of transactions within a block ensures that all users converting to and from a currency within that block receive the same fair price, with no spread. This eliminates the possibility of price manipulation or exploitation, providing a more equitable and transparent DeFi experience.\n\nOverall, the Verus protocol's simultaneous transaction processing and MEV-resistance features provide a more secure, fair, and efficient DeFi ecosystem, enabling users to transact with confidence and trust.", "* Increased security at the protocol level - Verus DeFi is implemented in the protocol as part of the consensus, following the fundamental systems design principle which says that the most important security layers should be located in the system/protocol itself.\n\n## MEV-resistance\n\nThe Verus protocol solves all transactions ``simultaneously`` within a block (as opposed to serially, in order, as is done on Ethereum and all other systems which use the VM-model). This has important implications for security, fairness, and efficiency:\n\n* Elimination of front-running, back-running and sandwich attacks.\n\n* Enhancing system-wide liquidity, thus reducing slippage, as conversions going to and from any given currency within the same block are offset against each other.\n\n* Providing all users converting to and from a currency within the same block the same fair price with no spread.", "./raw_text_input_docs/README_sendcurrency.md"]]], [["User:: I'm trying to understand the VerusPay Invoice specification. Can you explain what it is, and what are its core components and features?", "AI Assistant:: The VerusPay Invoice specification is a crucial aspect of the Verus ecosystem, and I'd be happy to break it down for you.\n\nThe VerusPay Invoice specification is a standardized format for creating, managing, and interpreting invoices across the Verus blockchain ecosystem and beyond. It is designed to be universally implementable across various programming languages, focusing on serialization and deserialization processes to ensure interoperability and consistency.\n\nThe VerusPay Invoice construct is the central component of this specification, encapsulating all necessary information for a comprehensive invoice system. The core components of a VerusPay Invoice include:\n\n1. **System ID**: If the invoice is signed by a VerusID, this is the ID system it is signed on.\n2. **Signing ID**: If the invoice is signed by a VerusID, this is the address of the VerusID that signed it.\n3. **Signature**: If the invoice is signed by a VerusID, this is the signature.\n4. **Details**: This component incorporates detailed transaction information through the VerusPay InvoiceDetails sub-component, covering aspects such as:\n* Payment amount\n* Destination\n* Currency\n5. **Version**: This component manages the invoice format version, facilitating future updates and backward compatibility through version flags and checks.\n\nThe VerusPay InvoiceDetails component is embedded within the VerusPay Invoice and provides specific transaction-related data. This specification provides a robust framework for blockchain invoice management, emphasizing interoperability, security, and ease of use. Its design facilitates a seamless payment experience across different blockchain ecosystems, making it a valuable tool for developers, merchants, and users within the Verus network and beyond.\n\nDo you have any further questions about the VerusPay Invoice specification, or would you like me to elaborate on any of its components?"], "AI Assistant", "", "N/A", [["What is the VerusPay Invoice specification, and what are its core components and features?", "The VerusPay Invoice specification is a standardized format for creating, managing, and interpreting invoices across the Verus blockchain ecosystem and beyond. It is designed to be universally implementable across various programming languages, focusing on serialization and deserialization processes to ensure interoperability and consistency.\n\nThe VerusPay Invoice construct is the central component of this specification, encapsulating all necessary information for a comprehensive invoice system. The core components of a VerusPay Invoice include:\n\n1. **System ID**: If the invoice is signed by a VerusID, this is the ID system it is signed on.\n2. **Signing ID**: If the invoice is signed by a VerusID, this is the address of the VerusID that signed it.\n3. **Signature**: If the invoice is signed by a VerusID, this is the signature.\n4. **Details**: This component incorporates detailed transaction information through the VerusPay InvoiceDetails sub-component, covering aspects such as:\n\t* Payment amount\n\t* Destination\n\t* Currency\n5. **Version**: This component manages the invoice format version, facilitating future updates and backward compatibility through version flags and checks.\n\nThe VerusPay InvoiceDetails component is embedded within the VerusPay Invoice and provides specific transaction-related data. This specification provides a robust framework for blockchain invoice management, emphasizing interoperability, security, and ease of use. Its design facilitates a seamless payment experience across different blockchain ecosystems, making it a valuable tool for developers, merchants, and users within the Verus network and beyond.", "# Invoice SpecificationThe VerusPay Invoice specification, introduced in VerusPay v3, outlines a standardized format for creating, managing, and interpreting invoices across the Verus blockchain ecosystem and beyond. It is designed to be universally implementable across various programming languages, focusing primarily on the serialization and deserialization processes to ensure interoperability and consistency. VerusPay invoices provide a robust framework for blockchain invoice management, emphasizing interoperability, security, and ease of use. Their design facilitates a seamless payment experience across different blockchain ecosystems, making it a valuable tool for developers, merchants, and users within the Verus network and beyond.## Core ComponentsThe VerusPay Invoice construct is central to this specification, encapsulating all necessary information for a comprehensive invoice system, including:- **System ID**: If the invoice is signed by a VerusID, this is the ID system it is signed on.\n- **Signing ID**: If the invoice is signed by a VerusID, this is the address of the VerusID that signed it.\n- **Signature**: If the invoice is signed by a VerusID, this is the signature.\n- **Details**: Incorporates detailed transaction information through the VerusPay InvoiceDetails sub-component, covering aspects such as the payment amount, destination, and currency.\n- **Version**: Manages the invoice format version, facilitating future updates and backward compatibility through version flags and checks.### VerusPay InvoiceDetailsEmbedded within the VerusPay Invoice, the VerusPay InvoiceDetails component provides specific transaction-related data:", "./raw_text_input_docs/invoices.md"]]], [["User:: Hi, I'm interested in bridging from Ethereum to Verus. Can you walk me through the process using either Verus Mobile or MetaMask?", "AI Assistant:: Bridging between Ethereum and Verus is a great way to expand your ecosystem. I'd be happy to guide you through the process. To bridge from Ethereum to Verus, you can use either Verus Mobile or MetaMask. Here's a step-by-step guide to help you through the process:\n\n**Using Verus Mobile:**\n1. Set up your Verus Mobile wallet and prepare it for bridging.\n2. Follow the instructions for bridging from Ethereum to Verus using Verus Mobile.\n\n**Using MetaMask:**\n1. Set up and configure MetaMask correctly.\n2. Follow the instructions for bridging from Ethereum to Verus using MetaMask.\n\n**General Bridging Process:**\nBridging from Ethereum to Verus involves creating a connection between your Ethereum wallet and your Verus wallet. This allows you to transfer assets from one chain to the other.\n\n**Importance of Bridging:**\nBridging between Ethereum and Verus enables the transfer of assets between these two chains, allowing for greater flexibility and interoperability.\n\n**Security and Safety:**\nWhen bridging between chains, ensure the security and safety of your assets by using a reputable and trusted tool and following all instructions carefully.\n\nDo you have any questions about the bridging process or would you like me to elaborate on any of the steps?"], "AI Assistant", "", "N/A", [["How can I bridge from Ethereum to Verus using either Verus Mobile or MetaMask?", "To bridge from Ethereum to Verus, you can use either Verus Mobile or MetaMask. Here's a step-by-step guide to help you through the process:\n\n**Using Verus Mobile:**\n1. Set up your Verus Mobile wallet and prepare it for bridging.\n2. Follow the instructions for bridging from Ethereum to Verus using Verus Mobile.\n\n**Using MetaMask:**\n1. Set up and configure MetaMask correctly.\n2. Follow the instructions for bridging from Ethereum to Verus using MetaMask.\n\n**General Bridging Process:**\nBridging from Ethereum to Verus involves creating a connection between your Ethereum wallet and your Verus wallet. This allows you to transfer assets from one chain to the other.\n\n**Importance of Bridging:**\nBridging between Ethereum and Verus enables the transfer of assets between these two chains, allowing for greater flexibility and interoperability.\n\n**Security and Safety:**\nWhen bridging between chains, ensure the security and safety of your assets by using a reputable and trusted tool and following all instructions carefully.", "# How to bridge from Ethereum to Verus\n\n## Verus Mobile\nPlease read the first parts of [this article](https://medium.com/veruscoin/how-to-participate-in-the-verus-ethereum-bridge-launch-73aeeae1c76a). You can skip the part on preconverting.\n\n## MetaMask\nPlease read the first parts of [this article](https://medium.com/veruscoin/how-to-participate-in-the-verus-ethereum-bridge-launch-73aeeae1c76a). You can skip the part on preconverting.", "./raw_text_input_docs/ethereum-to-verus.md"]]], [["User:: Hey, I'm interested in launching a new currency on Verus. Can you walk me through the steps to do that, and also explain how I define and use a currency definition to launch a new currency?", "AI Assistant:: Launching a new currency on Verus involves a few steps, but I'll break it down for you.\n\nThe process of launching a new currency on Verus involves defining the currency parameters, creating a currency definition, and then using that definition to launch the currency. Here's a step-by-step guide on how to do it.\n\n**Defining the Currency Parameters:**\nFirst, you need to define the parameters of your new currency. This includes the name of the currency, the options, proof protocol, and any preallocations. You can do this by creating a JSON object that includes these parameters. For example:\n\n```json\n{\n\"name\":\"MyBrand\",\n\"options\":32,\n\"proofprotocol\":2,\n\"preallocations\":[{\"Influencer@\":100}]\n}\n```\n\n**Creating the Currency Definition:**\nOnce you have defined the parameters, you need to create a currency definition using the `definecurrency` command. This command takes the JSON object you created as an argument. Here's an example:\n\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"MyBrand\",\n\"options\":32,\n\"proofprotocol\":2,\n\"preallocations\":[{\"Influencer@\":100}]\n}'\n```\n\nThis command will output a HEX value, which you will need to use in the next step.\n\n**Launching the Currency:**\nTo launch the currency, you need to use the `sendrawtransaction` command and pass the HEX value as an argument. Here's an example:\n\n```json\n./verus -chain=VRSCTEST sendrawtransaction \"HEX\"\n```\n\nThis command will start the currency launch process. Note that you need to have enough funds in the rootID to cover the currency fee (200.0002 VRSC) and the initial contribution.\n\n**Checking Currency Information:**\nAfter launching the currency, you can check its status and information using the `getcurrency` command. Here's an example:\n\n```json\n./verus -chain=VRSCTEST getcurrency \"MyBrand\"\n```\n\nThis command will display information about the currency, such as its name, options, and preallocations.\n\n**Important Notes:**\n\n* It's highly recommended to test your currency on the Verus Testnet before launching it on the mainnet.\n* The currency launch process takes a minimum of 20 blocks to complete.\n* You need to have enough funds in the rootID to cover the currency fee and initial contribution.\n* You can use the `getcurrency` command to check the status and information of your currency during the preconversion time frame and after the launch.\n\nDid that help? Do you have any more questions about launching a new currency on Verus, or any specific steps in the process?"], "AI Assistant", "", "N/A", [["What are the steps to launch a new currency on Verus, and how do I define and use a currency definition to launch a new currency?", "The process of launching a new currency on Verus involves defining the currency parameters, creating a currency definition, and then using that definition to launch the currency. Here's a step-by-step guide on how to do it.\n\n**Defining the Currency Parameters:**\nFirst, you need to define the parameters of your new currency. This includes the name of the currency, the options, proof protocol, and any preallocations. You can do this by creating a JSON object that includes these parameters. For example:\n\n```json\n{\n \"name\":\"MyBrand\",\n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Influencer@\":100}]\n}\n```\n\n**Creating the Currency Definition:**\nOnce you have defined the parameters, you need to create a currency definition using the `definecurrency` command. This command takes the JSON object you created as an argument. Here's an example:\n\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBrand\",\n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Influencer@\":100}]\n}'\n```\n\nThis command will output a HEX value, which you will need to use in the next step.\n\n**Launching the Currency:**\nTo launch the currency, you need to use the `sendrawtransaction` command and pass the HEX value as an argument. Here's an example:\n\n```json\n./verus -chain=VRSCTEST sendrawtransaction \"HEX\"\n```\n\nThis command will start the currency launch process. Note that you need to have enough funds in the rootID to cover the currency fee (200.0002 VRSC) and the initial contribution.\n\n**Checking Currency Information:**\nAfter launching the currency, you can check its status and information using the `getcurrency` command. Here's an example:\n\n```json\n./verus -chain=VRSCTEST getcurrency \"MyBrand\"\n```\n\nThis command will display information about the currency, such as its name, options, and preallocations.\n\n**Important Notes:**\n\n* It's highly recommended to test your currency on the Verus Testnet before launching it on the mainnet.\n* The currency launch process takes a minimum of 20 blocks to complete.\n* You need to have enough funds in the rootID to cover the currency fee and initial contribution.\n* You can use the `getcurrency` command to check the status and information of your currency during the preconversion time frame and after the launch.", "### **\"nativecurrencyid\"**\nUse this parameter for mapped ERC-20 tokens. The parameter includes the Ethereum contract address for the ERC-20. [Read more](/currencies/mapping-1:1-eth)\n\n::: warning Need help setting up a currency launch? \ud83e\udd14\n[Go to the Verus Discord #pbaas-development channel. The community is happy to assist!](https://www.verus.io/discord)\n:::\n\n## How to launch\nNow you know how to create a currency definition with all its options and parameters. Next up: how to actually use the definition to launch a currency.\n\nHere we use the command-line interface. If you want to use the built-in terminal from Verus Desktop, just replace ``./verus -chain=VRSCTEST`` with ``run``.\n\n::: tip Use Verus Testnet first! \ud83d\udc77\nBefore launching your currency or token on Verus (or any other PBaaS-chain), it is highly recommended to try it out on testnet first. \n:::\n\nLet's use this example definition to launch the currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBrand\",\n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Influencer@\":100}]\n}'\n```\n\nEntering the above command into the command-line interface wallet gives a `HEX` value as output. Take that HEX and do the following command below. \u26a0\ufe0f IMPORTANT: make sure there are enough funds in the rootID for the currency fee (200.0002 VRSC) and the initial contribution (when in parameters).\n\n``` json\n./verus -chain=VRSCTEST sendrawtransaction \"HEX\"\n```\n\nAfter doing the command above the currency has started, the funds from the rootID are taken, and it takes a minimum of 20 blocks (or startblock) to actually launch it (and if all preconversion goals are met).\n\nDuring the preconversion time frame and after the launch you can lookup all kinds of information on the currency with the following command:\n\n``` json\n./verus -chain=VRSCTEST getcurrency \"MyBrand\"\n```", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I'm interested in creating my own private blockchain on the Verus network. Can you walk me through the process of defining a new currency and setting up a Public Blockchain as a Service (PBaaS) chain using the `definecurrency` command?", "AI Assistant:: Defining a new currency and setting up a PBaaS chain on the Verus network can be done using the `definecurrency` command. This command takes two JSON objects as input: one for the PBaaS chain definition, and another for the bridge definition defaults.\n\nLet's break down the components of the PBaaS chain definition:\n\n1. **Name and Options**: The \"name\" field specifies the name of the currency, and the \"options\" field is an integer that determines various settings for the currency.\n2. **Currencies**: The \"currencies\" field specifies the currencies that can be converted to the new currency.\n3. **Preallocations**: The \"preallocations\" field allows you to pre-allocate a certain amount of the new currency to specific VerusIDs.\n4. **Conversions**: The \"conversions\" field defines the conversion ratios between the new currency and other currencies on the chain.\n5. **Eras**: The \"eras\" field defines the block reward, reward decay, halving, and end of each \"era\" in the chain's lifecycle.\n6. **Block Time**: The \"blocktime\" field specifies the time, in seconds, between blocks on the chain.\n7. **ID Registration Fees**: The \"idregistrationfees\" field specifies the fees, in the new currency, for registering a new VerusID on the chain.\n8. **Notaries**: The \"notaries\" field specifies the VerusIDs of the notaries on the chain.\n9. **Start Block**: The \"startblock\" field specifies the block number at which the chain will start.\n10. **Minimum Notaries Confirm**: The \"minnotariesconfirm\" field specifies the minimum number of notaries required to confirm a block.\n11. **Nodes**: The \"nodes\" field specifies the network addresses and VerusIDs of the nodes on the chain.\n12. **Gateway Converter**: The \"gatewayconvertername\" and \"gatewayconverterissuance\" fields specify the name and initial issuance of the gateway converter, which is used to move funds on and off the PBaaS chain.\n\nThe bridge definition defaults specify the currencies supported by the bridge, the initial liquidity for each currency, and the initial supply of the bridge's native token.\n\nIf you need help setting up a blockchain launch, you can reach out to the Verus community on the #pbaas-development channel on Discord for assistance.\n\nDo you have any questions about the `definecurrency` command or the process of setting up a PBaaS chain on the Verus network?"], "AI Assistant", "", "N/A", [["How do I define a new currency and set up a Public Blockchain as a Service (PBaaS) chain on the Verus network, using the `definecurrency` command?", "To define a new currency and set up a Public Blockchain as a Service (PBaaS) chain on the Verus network, you will need to use the `definecurrency` command. This command takes two JSON objects as input: one for the PBaaS chain definition, and another for the bridge definition defaults.\n\nLet's break down the components of the PBaaS chain definition:\n\n1. **Name and Options**: The \"name\" field specifies the name of the currency, and the \"options\" field is an integer that determines various settings for the currency.\n2. **Currencies**: The \"currencies\" field specifies the currencies that can be converted to the new currency.\n3. **Preallocations**: The \"preallocations\" field allows you to pre-allocate a certain amount of the new currency to specific VerusIDs.\n4. **Conversions**: The \"conversions\" field defines the conversion ratios between the new currency and other currencies on the chain.\n5. **Eras**: The \"eras\" field defines the block reward, reward decay, halving, and end of each \"era\" in the chain's lifecycle.\n6. **Block Time**: The \"blocktime\" field specifies the time, in seconds, between blocks on the chain.\n7. **ID Registration Fees**: The \"idregistrationfees\" field specifies the fees, in the new currency, for registering a new VerusID on the chain.\n8. **Notaries**: The \"notaries\" field specifies the VerusIDs of the notaries on the chain.\n9. **Start Block**: The \"startblock\" field specifies the block number at which the chain will start.\n10. **Minimum Notaries Confirm**: The \"minnotariesconfirm\" field specifies the minimum number of notaries required to confirm a block.\n11. **Nodes**: The \"nodes\" field specifies the network addresses and VerusIDs of the nodes on the chain.\n12. **Gateway Converter**: The \"gatewayconvertername\" and \"gatewayconverterissuance\" fields specify the name and initial issuance of the gateway converter, which is used to move funds on and off the PBaaS chain.\n\nThe bridge definition defaults specify the currencies supported by the bridge, the initial liquidity for each currency, and the initial supply of the bridge's native token.\n\nIf you need help setting up a blockchain launch, you can reach out to the Verus community on the #pbaas-development channel on Discord for assistance.", "``` json\n./verus -chain=vrsctest definecurrency '{\n  \"name\":\"v2\",\n  \"options\":264,\n  \"currencies\":[\"vrsctest\"],\n  \"preallocations\":[\n    {\n      \"allnotary1@\":800000\n    }\n  ],\n  \"conversions\":[1],\n  \"eras\":[\n    {\n      \"reward\":76800000000,\n      \"decay\":0,\n      \"halving\":525000,\n      \"eraend\":0\n    }\n  ],\n  \"blocktime\":10,\n  \"idregistrationfees\":25,\n  \"notaries\":[\n    \"allnotary1@\",\n    \"allnotary2@\",\n    \"allnotary3@\"\n    ],\n  \"startblock\":9500,\n  \"minnotariesconfirm\":2,\n  \"nodes\":[\n    {\n      \"networkaddress\":\"45.76.168.133:20022\",\n      \"nodeidentity\": \"allnotary1@\"\n    },\n    {\n      \"networkaddress\":\"149.28.95.28:20022\",\n      \"nodeidentity\":\"allnotary2@\"\n    },\n    {\n      \"networkaddress\":\"45.63.58.171:20022\",\n      \"nodeidentity\":\"allnotary3@\"\n    }\n  ],\n  \"gatewayconvertername\":\"Bridge\",\n  \"gatewayconverterissuance\":800000\n  }' \n  '{\n    \"currencies\":[\"VRSCTEST\",\"v2\"],\n    \"initialcontributions\":[2500,0],\n    \"initialsupply\":800000\n  }'\n```\n\n::: warning Need help setting up a blockchain launch? \ud83e\udd14\n[Go to the Verus Discord #pbaas-development channel. The community is happy to assist!](https://www.verus.io/discord)\n:::", "./raw_text_input_docs/define-pbaas.md"]]], [["User:: Hi, I'm interested in getting a Verus address, but I'm not sure where to start. Can you walk me through the process and explain the differences between using Verus Mobile and Verus Desktop?", "AI Assistant:: Getting a Verus address is a great step in exploring the Verus ecosystem. I'd be happy to guide you through the process and explain the differences between Verus Mobile and Verus Desktop.\n\nTo get a Verus address, you have two options: using Verus Mobile or Verus Desktop.\n\n**Verus Mobile:**\nVerus Mobile is a mobile application that allows you to bridge from Ethereum to Verus (or vice versa) within the application. This means you can easily convert between these two blockchain networks directly from your mobile device. Additionally, Verus Mobile enables MEV-resistant and low-cost conversions, making it a convenient and cost-effective option. You can download Verus Mobile from the App Store or Play Store, depending on your device.\n\n**Verus Desktop:**\nVerus Desktop is a desktop application that can be downloaded for Windows, macOS, Linux, or Linux ARM devices. By running a full node in native mode, you can experience all the features of the Verus protocol. This means you have full control over your node and can utilize all the capabilities of the Verus network.\n\n**Key differences:**\nThe main difference between Verus Mobile and Verus Desktop is the level of control and functionality. Verus Mobile is designed for ease of use and convenience, allowing you to bridge between Ethereum and Verus with minimal setup. Verus Desktop, on the other hand, provides a more advanced experience, giving you full control over your node and access to all protocol features. Ultimately, the choice between Verus Mobile and Verus Desktop depends on your specific needs and preferences.\n\nDo you have any further questions about getting a Verus address or the differences between Verus Mobile and Verus Desktop?"], "AI Assistant", "", "N/A", [["How can I get a Verus address, and what are the differences between using Verus Mobile and Verus Desktop?", "To get a Verus address, you have two options: using Verus Mobile or Verus Desktop.\n\n**Verus Mobile:**\nVerus Mobile is a mobile application that allows you to bridge from Ethereum to Verus (or vice versa) within the application. This means you can easily convert between these two blockchain networks directly from your mobile device. Additionally, Verus Mobile enables MEV-resistant and low-cost conversions, making it a convenient and cost-effective option. You can download Verus Mobile from the App Store or Play Store, depending on your device.\n\n**Verus Desktop:**\nVerus Desktop is a desktop application that can be downloaded for Windows, macOS, Linux, or Linux ARM devices. By running a full node in native mode, you can experience all the features of the Verus protocol. This means you have full control over your node and can utilize all the capabilities of the Verus network.\n\n**Key differences:**\nThe main difference between Verus Mobile and Verus Desktop is the level of control and functionality. Verus Mobile is designed for ease of use and convenience, allowing you to bridge between Ethereum and Verus with minimal setup. Verus Desktop, on the other hand, provides a more advanced experience, giving you full control over your node and access to all protocol features. Ultimately, the choice between Verus Mobile and Verus Desktop depends on your specific needs and preferences.", "# Get a Verus address\nThere are a few ways to get a Verus address on desktop and on mobile.\n\n## Verus Mobile\nDownload Verus Mobile from the [App Store](https://apps.apple.com/en/app/verus-mobile/id6447361908) or [Play Store](https://play.google.com/store/apps/details?id=org.autonomoussoftwarefoundation.verusmobile.android&hl=en&gl=US)\n\nUse Verus Mobile to bridge from Ethereum to Verus (or vice versa) all within the application. And use it for MEV-resistant and low-cost conversions: [more on Verus DeFi](/sendcurrency)\n\n## Verus Desktop\nDownload Verus Desktop for Windows, macOS, Linux or Linux ARM [here](https://verus.io/wallet).\n\nRun a full node (native mode) to experience all protocol features.", "./raw_text_input_docs/getwallet.md"]]], [["User:: I've been reading about the Verus blockchain and I'm curious about its consensus mechanism. Can you explain what Verus Proof of Power (VerusPoP) is and how it provides a secure and decentralized consensus mechanism for the Verus blockchain?", "AI Assistant:: Verus Proof of Power (VerusPoP) is a fascinating topic. I'd be happy to dive into the details.\n\nVerus Proof of Power (VerusPoP) is a hybrid consensus algorithm that combines the benefits of both Proof of Work (PoW) and Proof of Stake (PoS) to validate each block on the Verus blockchain. This innovative consensus mechanism ensures that 50% of all blocks are validated by miners (using PoW) and the other 50% are validated by stakers (using PoS).\n\nThe VerusPoP algorithm uses a statistical function to combine the two forms of proof, making it a unique and secure way to validate transactions on the blockchain. To successfully attack the Verus blockchain, an attacker would need to control more than 50% of the validation power, which is known as \"Chain Power\". This would require a combined value of over 50% of both the chain's hashpower and its coin supply, making it extremely difficult to launch a 51% attack.\n\nOne of the key benefits of VerusPoP is its decentralized nature, which incentivizes holders to keep nodes online to support the network. Even if there is a change in network hashrate, the PoW/PoS ratio remains the same, ensuring that the network remains decentralized and secure.\n\nVerusPoP also utilizes a custom hash function called VerusHash 2.2, which is designed to be CPU-friendly and allows CPUs and GPUs to compete on an economically comparable level. This makes it the fastest known cryptocurrency hash algorithm available to modern CPUs.\n\nOverall, VerusPoP provides a secure, decentralized, and efficient consensus mechanism for the Verus blockchain, making it an attractive option for users and developers alike.\n\nDo you have any further questions about VerusPoP or its implementation on the Verus blockchain?"], "AI Assistant", "", "N/A", [["What is Verus Proof of Power (VerusPoP), and how does it provide a secure and decentralized consensus mechanism for the Verus blockchain?", "Verus Proof of Power (VerusPoP) is a hybrid consensus algorithm that combines the benefits of both Proof of Work (PoW) and Proof of Stake (PoS) to validate each block on the Verus blockchain. This innovative consensus mechanism ensures that 50% of all blocks are validated by miners (using PoW) and the other 50% are validated by stakers (using PoS).\n\nThe VerusPoP algorithm uses a statistical function to combine the two forms of proof, making it a unique and secure way to validate transactions on the blockchain. To successfully attack the Verus blockchain, an attacker would need to control more than 50% of the validation power, which is known as \"Chain Power\". This would require a combined value of over 50% of both the chain's hashpower and its coin supply, making it extremely difficult to launch a 51% attack.\n\nOne of the key benefits of VerusPoP is its decentralized nature, which incentivizes holders to keep nodes online to support the network. Even if there is a change in network hashrate, the PoW/PoS ratio remains the same, ensuring that the network remains decentralized and secure.\n\nVerusPoP also utilizes a custom hash function called VerusHash 2.2, which is designed to be CPU-friendly and allows CPUs and GPUs to compete on an economically comparable level. This makes it the fastest known cryptocurrency hash algorithm available to modern CPUs.\n\nOverall, VerusPoP provides a secure, decentralized, and efficient consensus mechanism for the Verus blockchain, making it an attractive option for users and developers alike.", "# Verus Proof of Power\nVerusPoP is a 50% proof-of-work, 50% proof-of-stake consensus algorithm.\n[More information on the Verus miner and staker ecosystem](/economy/).## Hybrid Consensus\nVerus Proof of Power, or VerusPoP, is a hybrid consensus algorithm which uses a statistical function that combines Proof of Work (PoW) and Proof of Stake (PoS) to validate each block by either PoW or PoS, while averaging to a target percentage of blocks being validated by each form of proof.In short, it a unique consensus mechanism with 50% of all blocks validated by miners, and the other 50% by stakers.## Attack Resistant\nTo successfully attack the Verus blockchain, more than 50% of the validation power is needed, called ``Chain Power``. A 51% attack would require a combined value of over 50% of both the chain\u2019s hashpower and its coin supply. [For technical information on VerusPoP read the whitepaper](https://verus.io/docs/VerusPoP.pdf).VerusPoP provides a decentralizing effect on the network, incentivizing holders to keep nodes online to support the network. Even if a change in network hashrate happens, the PoW/PoS ratio stays the same: 50/50%.## VerusHash 2.2\n[From the VerusPoP whitepaper](https://verus.io/docs/VerusPoP.pdf):\"VerusHash is specifically developed to deliver a competitive advantage for CPUs with GPUs. It is an exceedingly CPU-friendly long input hash function that uses the quantum-secure, short input Haraka512 V2 as its core compression algorithm. The result is the fastest known cryptocurrency hash algorithm available to modern CPUs and the only hash algorithm which enables today\u2019s CPUs and GPUs to compete on an economically comparable level.", "./raw_text_input_docs/verus-proof-of-power.md"]]], [["User:: I've been trying to wrap my head around the different types of destinations in Verus. Could you explain the different types of destination types in Verus, and how they can be used in transactions and cross-chain interactions?", "AI Assistant:: I'd be happy to break down the different destination types in Verus for you.\n\nIn Verus, destination types are used to specify the type of address or entity that a transaction is being sent to. There are several types of destinations, each with its own unique characteristics and use cases.\n\nLet's go through each of the destination types:\n\n**DEST_INVALID (0)**: This is an invalid or unspecified destination type, used as a default or error state.\n\n**DEST_PK (1)**: This indicates a public key destination, typically used for transactions directly to a public key.\n\n**DEST_PKH (2)**: This stands for a public key hash destination, common in many blockchain platforms for sending transactions to a hashed version of a public key (e.g. an r-address).\n\n**DEST_SH (3)**: This represents a script hash destination, used for transactions that should be processed by a specific script, enabling smart contracts or complex spending conditions.\n\n**DEST_ID (4)**: This identifies a VerusID destination.\n\n**DEST_FULLID (5)**: This destination type is used for a full VerusID.\n\n**DEST_REGISTERCURRENCY (6)**: This destination is used for registering a new currency.\n\n**DEST_QUANTUM (7)**: This is used for quantum-resistant addresses.\n\n**DEST_NESTEDTRANSFER (8)**: This destination type is used for nested transfers.\n\n**DEST_ETH (9)**: This specifies an Ethereum account as the destination, facilitating cross-chain transactions with Ethereum.\n\n**DEST_ETHNFT (10)**: This indicates a destination for an Ethereum-compatible Non-Fungible Token (NFT), enabling the mapping of NFTs across different blockchain systems.\n\n**DEST_RAW (11)**: This represents a raw data destination, allowing for arbitrary data to be included as a destination, offering maximum flexibility.\n\nIn addition to these destination types, Verus also supports the use of flags to indicate additional attributes of a destination. These flags include:\n\n**FLAG_DEST_AUX (64)**: This indicates the presence of auxiliary destinations, allowing for the specification of additional destinations within a single Transfer Destination construct.\n\n**FLAG_DEST_GATEWAY (128)**: This specifies that the destination is associated with a gateway, relevant for cross-chain transactions or interactions with external systems.\n\nThe serialization and deserialization process in Verus allows for the efficient and secure transmission of destination information in transactions, enabling the use of these different destination types and flags in a variety of applications and use cases.\n\nDo you have any further questions about destination types in Verus, or how they can be used in transactions and cross-chain interactions?"], "AI Assistant", "", "N/A", [["What are the different types of destination types in Verus, and how can they be used in transactions and cross-chain interactions?", "In Verus, destination types are used to specify the type of address or entity that a transaction is being sent to. There are several types of destinations, each with its own unique characteristics and use cases.\n\n**DEST_INVALID (0)**: This is an invalid or unspecified destination type, used as a default or error state.\n\n**DEST_PK (1)**: This indicates a public key destination, typically used for transactions directly to a public key.\n\n**DEST_PKH (2)**: This stands for a public key hash destination, common in many blockchain platforms for sending transactions to a hashed version of a public key (e.g. an r-address).\n\n**DEST_SH (3)**: This represents a script hash destination, used for transactions that should be processed by a specific script, enabling smart contracts or complex spending conditions.\n\n**DEST_ID (4)**: This identifies a VerusID destination.\n\n**DEST_FULLID (5)**: This destination type is used for a full VerusID.\n\n**DEST_REGISTERCURRENCY (6)**: This destination is used for registering a new currency.\n\n**DEST_QUANTUM (7)**: This is used for quantum-resistant addresses.\n\n**DEST_NESTEDTRANSFER (8)**: This destination type is used for nested transfers.\n\n**DEST_ETH (9)**: This specifies an Ethereum account as the destination, facilitating cross-chain transactions with Ethereum.\n\n**DEST_ETHNFT (10)**: This indicates a destination for an Ethereum-compatible Non-Fungible Token (NFT), enabling the mapping of NFTs across different blockchain systems.\n\n**DEST_RAW (11)**: This represents a raw data destination, allowing for arbitrary data to be included as a destination, offering maximum flexibility.\n\nIn addition to these destination types, Verus also supports the use of flags to indicate additional attributes of a destination. These flags include:\n\n**FLAG_DEST_AUX (64)**: This indicates the presence of auxiliary destinations, allowing for the specification of additional destinations within a single Transfer Destination construct.\n\n**FLAG_DEST_GATEWAY (128)**: This specifies that the destination is associated with a gateway, relevant for cross-chain transactions or interactions with external systems.\n\nThe serialization and deserialization process in Verus allows for the efficient and secure transmission of destination information in transactions, enabling the use of these different destination types and flags in a variety of applications and use cases.", "- **DEST_INVALID (0)**: Represents an invalid or unspecified destination type, used as a default or error state.\n- **DEST_PK (1)**: Indicates a public key destination, typically used for transactions directly to a public key.\n- **DEST_PKH (2)**: Stands for a public key hash destination, common in many blockchain platforms for sending transactions to a hashed version of a public key (e.g. an r-address).\n- **DEST_SH (3)**: Represents a script hash destination, used for transactions that should be processed by a specific script, enabling smart contracts or complex spending conditions.\n- **DEST_ID (4)**: Identifies a [**VerusID**](/verusid/) destination.\n- **DEST_FULLID (5)**:\n- **DEST_REGISTERCURRENCY (6)**:\n- **DEST_QUANTUM (7)**: Used for quantum-resistant addresses.\n- **DEST_NESTEDTRANSFER (8)**:\n- **DEST_ETH (9)**: Specifies an Ethereum account as the destination, facilitating cross-chain transactions with Ethereum.\n- **DEST_ETHNFT (10)**: Indicates a destination for an Ethereum-compatible Non-Fungible Token (NFT), enabling the mapping of NFTs across different blockchain systems.\n- **DEST_RAW (11)**: Represents a raw data destination, allowing for arbitrary data to be included as a destination, offering maximum flexibility.### FlagsTransfer Destination also supports the use of flags to indicate additional attributes of a destination:- **FLAG_DEST_AUX (64)**: Indicates the presence of auxiliary destinations, allowing for the specification of additional destinations within a single Transfer Destination construct.\n- **FLAG_DEST_GATEWAY (128)**: Specifies that the destination is associated with a gateway, relevant for cross-chain transactions or interactions with external systems.## Serialization and Deserialization Process", "./raw_text_input_docs/transfer-destination.md"]]], [["User:: I'm trying to understand the notary witness system in Verus and how it works with the Bridge.vETH currency. Can you explain the key features and benefits of the notary witness system and how Bridge.vETH facilitates asset bridging?", "AI Assistant:: The notary witness system and Bridge.vETH are indeed crucial components of the Verus ecosystem. Let me break it down for you.\n\nIn the Verus protocol, notary witnesses play a crucial role in ensuring the security and integrity of the network. One of the key features of the notary witness system is that they are also responsible for monitoring notarizations. If a notary witness were to sign for something that they do not agree with, they have the ability to auto-revoke their identities using the VerusID protocol. This auto-revocation mechanism is designed to prevent stolen key attacks, making it extremely difficult for an attacker to compromise a notary witness. To achieve this, the notary witness would need to have both the keys for the notary ID and those for its revocation ID.\n\nNow, let's talk about Bridge.vETH. This currency is designed to facilitate the bridging of assets across different chains. Bridge.vETH is a 100% backed currency, meaning that its value is backed by a reserve of four currencies: VRSC, ETH, DAI, and MKR. This basket of currencies ensures that the value of Bridge.vETH is stable and secure.\n\nOne of the key benefits of Bridge.vETH is that it makes it easy to bridge assets from one side of the bridge to the other. When you send Bridge.vETH, it automatically converts the fees that you need, making the process seamless. Moreover, the value of Bridge.vETH increases relative to its reserves when fees or interest are added to the reserves without new Bridge.vETH being minted. This means that the value of Bridge.vETH is designed to appreciate over time, making it a valuable tool for facilitating asset bridging in the Verus ecosystem.\n\nDo you have any further questions about the notary witness system or Bridge.vETH? Would you like me to elaborate on any of these points?"], "AI Assistant", "", "N/A", [["What are the key features and benefits of the notary witness system in Verus, and how does the Bridge.vETH currency work in facilitating asset bridging?", "In the Verus protocol, notary witnesses play a crucial role in ensuring the security and integrity of the network. One of the key features of the notary witness system is that they are also responsible for monitoring notarizations. If a notary witness were to sign for something that they do not agree with, they have the ability to auto-revoke their identities using the VerusID protocol. This auto-revocation mechanism is designed to prevent stolen key attacks, making it extremely difficult for an attacker to compromise a notary witness. To achieve this, the notary witness would need to have both the keys for the notary ID and those for its revocation ID.\n\nIn addition to the notary witness system, Verus also features a currency called Bridge.vETH, which is designed to facilitate the bridging of assets across different chains. Bridge.vETH is a 100% backed currency, meaning that its value is backed by a reserve of four currencies: VRSC, ETH, DAI, and MKR. This basket of currencies ensures that the value of Bridge.vETH is stable and secure.\n\nOne of the key benefits of Bridge.vETH is that it makes it easy to bridge assets from one side of the bridge to the other. When you send Bridge.vETH, it automatically converts the fees that you need, making the process seamless. Moreover, the value of Bridge.vETH increases relative to its reserves when fees or interest are added to the reserves without new Bridge.vETH being minted. This means that the value of Bridge.vETH is designed to appreciate over time, making it a valuable tool for facilitating asset bridging in the Verus ecosystem.", "The notary witnesses are also monitoring notarizations, and if they were to sign for something that they themselves do not agree with, they can auto-revoke their identities, using the VerusID protocol, which cannot be stopped by an attacker unless they have stolen both the keys for the notary ID and those for its revocation ID as well. This serves as a prevention for stolen key attacks, ensuring that notaries are extremely hard targets to compromise.## Bridge.vETH currency\nBridge.vETH is a 100% backed currency with 4 currencies in its reserves (VRSC, ETH, DAI, MKR), [read more on basket currencies](/currencies/). The Bridge.vETH currency function is to make the bridging of assets simple. From wherever side on the bridge you send it converts the fees that you need seamlessly.The value of Bridge.vETH increases relative to reserves when fees or interest are added to the reserves without there being new Bridge.vETH minted.", "./raw_text_input_docs/README_eth-bridge.md"]]], [["User:: Hey, I'm interested in mining Verus cryptocurrency. Can you tell me about the various options for mining Verus, including software for different operating systems, mobile mining, and mining pools?", "AI Assistant:: Mining Verus cryptocurrency can be done through various software and mining pools. Here's an overview of the options:\n\nMining Verus can be a fun and rewarding experience. Let me break down the different options for you.\n\n**Desktop Mining Software:**\nFor Windows, macOS, Linux, and ARM operating systems, you can use CCminer, a popular mining software. The version and availability of CCminer vary by operating system. For example, the latest version available for Windows and Linux is v3.8.3a, while macOS (Apple silicon) does not have a version available yet. You can download the software from the provided links.\n\n**Mobile Mining:**\nIf you want to mine Verus using your mobile phone, you can use VerusMiner, a mobile mining software. You can download it from the provided link.\n\n**GPU Mining:**\nUnfortunately, there is no software available for GPU mining yet. But who knows, maybe someone will develop one soon!\n\n**Mining Pools:**\nA mining pool allows multiple miners to combine their computing power to increase their chances of solving complex mathematical problems and earning Verus cryptocurrency. There are several mining pools available, each with its own fee percentage. Here are some of the popular mining pools for Verus:\n\n* Verus Pool: This pool donates its fees to the Verus foundation and has a fee percentage of 5%.\n* LuckPool: This pool has a fee percentage of 1%.\n* ZergPool: This pool has a fee percentage of 0.5%.\n* CiscoTech: This pool has a fee percentage of 1%.\n* LePool: This pool has a fee percentage of 1%.\n* Zhuaao: This pool has a fee percentage of 1%.\n* AlphatechIT: This pool has a fee percentage of 0.2%.\n* Wattpool: This pool has a fee percentage of 0.5%.\n* 011Data: This pool has a fee percentage of 0.5%.\n* vipor.net: This pool has a fee percentage of 0.1%.\n* cloudiko.io: This pool has a fee percentage of 0%.\n\nWhen choosing a mining pool, consider the fee percentage and the pool's reputation.\n\nDo you have any more questions about mining Verus or any of these options?"], "AI Assistant", "", "N/A", [["What are the various options for mining Verus cryptocurrency, including software for different operating systems, mobile mining, and mining pools?", "Mining Verus cryptocurrency can be done through various software and mining pools. Here's an overview of the options:\n\n**Desktop Mining Software:**\nFor Windows, macOS, Linux, and ARM operating systems, you can use CCminer, a popular mining software. The version and availability of CCminer vary by operating system. For example, the latest version available for Windows and Linux is v3.8.3a, while macOS (Apple silicon) does not have a version available yet. You can download the software from the provided links.\n\n**Mobile Mining:**\nIf you want to mine Verus using your mobile phone, you can use VerusMiner, a mobile mining software. You can download it from the provided link.\n\n**GPU Mining:**\nUnfortunately, there is no software available for GPU mining yet.\n\n**Mining Pools:**\nA mining pool allows multiple miners to combine their computing power to increase their chances of solving complex mathematical problems and earning Verus cryptocurrency. There are several mining pools available, each with its own fee percentage. Here are some of the popular mining pools for Verus:\n\n* Verus Pool: This pool donates its fees to the Verus foundation and has a fee percentage of 5%.\n* LuckPool: This pool has a fee percentage of 1%.\n* ZergPool: This pool has a fee percentage of 0.5%.\n* CiscoTech: This pool has a fee percentage of 1%.\n* LePool: This pool has a fee percentage of 1%.\n* Zhuaao: This pool has a fee percentage of 1%.\n* AlphatechIT: This pool has a fee percentage of 0.2%.\n* Wattpool: This pool has a fee percentage of 0.5%.\n* 011Data: This pool has a fee percentage of 0.5%.\n* vipor.net: This pool has a fee percentage of 0.1%.\n* cloudiko.io: This pool has a fee percentage of 0%.\n\nWhen choosing a mining pool, consider the fee percentage and the pool's reputation.", "| OS   |  Name | Version |   Download |\n| :------ | ------: | ------: | -----------: |\n| Windows | CCminer | v3.8.3a | [Download](https://github.com/monkins1010/ccminer/releases/tag/v3.8.3a) |\n| macOS (Apple silicon)| CCminer | -- | not (yet) available |\n| Linux  | CCminer | v3.8.3a | [Download](https://github.com/Oink70/ccminer-verus/releases/tag/v3.8.3a-CPU) |\n| ARM   | CCminer | v3.8.3a | [Download](https://github.com/Oink70/ccminer-verus/releases/tag/v3.8.3a-CPU) |\n\n### \ud83d\udcf1 Mobile\nStart mining with your phone.\n\n**VerusMiner** [Download here](https://pangz-lab.github.io/verusminer/)\n\n### GPU\n\nNo software yet.\n\n## Mining Pools\n\n| Pool Name                    | Fee % |\n| :---------------------------------------------- | ----: |\n| [Verus Pool](https://pool.verus.io/) <span style=\"color:green\">Fees donated to the Verus foundation</span>   |  <span style=\"color:green\"> <b>5%</b></span>|\n| [LuckPool](https://luckpool.net/verus/)     |  1% |\n| [ZergPool](https://zergpool.com/)        | 0.5% |\n| [CiscoTech](https://vrsc.ciscotech.dk/)     |  1% |\n| [LePool](http://vrsc.lepool.com.cn:8088/)    |  1% |\n| [Zhuaao](http://www.zhuaao.com:8880/)      |  1% |\n| [AlphatechIT](https://verus.alphatechit.co.uk/) | 0.2% |\n| [Wattpool](https://wattpool.net/ui/verus/stats) | 0.5% |\n| [011Data](https://verusna.011data.com/) | 0.5% |\n| [vipor.net](https://vipor.net) | 0.1% |\n| [cloudiko.io](https://cloudiko.io) | 0% |", "./raw_text_input_docs/start-mining.md"]]], [["User:: I'm interested in learning more about the Verus ecosystem and its components. Can you tell me about Transfer Destination and how it enables the development of decentralized applications and systems?", "AI Assistant:: Transfer Destination is a crucial aspect of the Verus ecosystem, and I'd be happy to explain it in detail.\n\nTransfer Destination is a fundamental component in the Verus ecosystem that allows blockchain developers to define flexible, interoperable, and sophisticated transaction pathways. Its design enables a wide range of blockchain operations, from simple transfers to complex cross-chain and multi-step transactions. This makes it an essential tool in the development of decentralized applications and systems.\n\nTransfer Destination provides a powerful way to facilitate various blockchain operations, offering a high degree of flexibility and customization. By enabling the definition of complex transaction pathways, it allows developers to create sophisticated decentralized applications and systems that can interact with multiple blockchains and execute complex transactions.\n\nThe implementation of Transfer Destination can be seen in various codebases across the Verus ecosystem, including the VerusCoin core GitHub repository and the verus-typescript-primitives utility library. This demonstrates its importance and versatility in the development of decentralized applications and systems.\n\nIn essence, Transfer Destination is a critical component in the Verus ecosystem, providing a robust and flexible framework for developers to build complex decentralized applications and systems that can operate seamlessly across multiple blockchains.\n\nDo you have any further questions about Transfer Destination or its role in the Verus ecosystem? Would you like to know more about how it enables decentralized application development?"], "AI Assistant", "", "N/A", [["What is Transfer Destination, and how does it enable the development of decentralized applications and systems in the Verus ecosystem?", "Transfer Destination is a fundamental component in the Verus ecosystem that allows blockchain developers to define flexible, interoperable, and sophisticated transaction pathways. Its design enables a wide range of blockchain operations, from simple transfers to complex cross-chain and multi-step transactions. This makes it an essential tool in the development of decentralized applications and systems.\n\nTransfer Destination provides a powerful way to facilitate various blockchain operations, offering a high degree of flexibility and customization. By enabling the definition of complex transaction pathways, it allows developers to create sophisticated decentralized applications and systems that can interact with multiple blockchains and execute complex transactions.\n\nThe implementation of Transfer Destination can be seen in various codebases across the Verus ecosystem, including the VerusCoin core GitHub repository and the verus-typescript-primitives utility library. This demonstrates its importance and versatility in the development of decentralized applications and systems.\n\nIn essence, Transfer Destination is a critical component in the Verus ecosystem, providing a robust and flexible framework for developers to build complex decentralized applications and systems that can operate seamlessly across multiple blockchains.", "Transfer Destination is a foundational component for blockchain developers, enabling the definition of flexible, interoperable, and sophisticated transaction pathways. Its design facilitates a wide range of blockchain operations, from simple transfers to complex cross-chain and multi-step transactions, making it an essential tool in the development of decentralized applications and systems.\n\n## Implementation Examples\n\nThe Transfer Destination construct is implemented in a number of codebases accross the Verus ecosystem:\n\n- [The VerusCoin core GitHub repository (as CTransferDestination)](https://github.com/VerusCoin/VerusCoin/blob/master/src/pbaas/crosschainrpc.h)\n- [The verus-typescript-primitives utility library (as TransferDestination)](https://github.com/VerusCoin/verus-typescript-primitives/blob/master/src/pbaas/TransferDestination.ts)", "./raw_text_input_docs/transfer-destination.md"]]], [["User:: Hey, I'm having some trouble setting up Verus Vault in Verus Desktop. Can you walk me through the process of locking funds in my VerusID, and explain the different lock types available?", "AI Assistant:: I'd be happy to help you with that. To set up Verus Vault in Verus Desktop, you'll need the latest version of Verus Desktop and a VerusID on the Verus mainchain or any other chain when PBaaS is live. Verus Vault allows you to lock funds in your VerusID, making them unspendable, but still stakable and receivable. There are two types of locks: TimeLock and DelayLock.\n\n**TimeLock:**\nA TimeLock locks funds until a predetermined number of blocks have passed. To set up a TimeLock, you'll need to know the blockheight of the blockchain. For example, let's say the blockchain's blockheight is at 1,000,000 blocks, and you want to lock your VerusID for 1 year, which is approximately 508,994 blocks. You can use the command line interface in Verus Desktop to set up the TimeLock.\n\n**DelayLock:**\nA DelayLock locks funds and unlocks them with a delay. Funds cannot be spent until an unlock has been requested and a predetermined number of blocks have passed.\n\n**Getting Started:**\nTo set up Verus Vault, access the command line interface in Verus Desktop by going to \"settings\" (the cogwheel top right corner) and selecting \"Coin Settings\". Fill in the commands to set up your Vault.\n\n**Important Note:**\nFor long-term locking, it's best to take an average block time of 62 seconds into account. However, there are variables that make it difficult to predict an exact time, such as leap years. Over long-term, there are an average of 1394.5484 blocks per day.\n\nBy following these steps, you can set up Verus Vault in Verus Desktop and lock funds in your VerusID using either TimeLock or DelayLock. Do you have any more questions about Verus Vault or the lock types available?"], "AI Assistant", "", "N/A", [["How do I set up Verus Vault in Verus Desktop to lock funds in my VerusID, and what are the different lock types available?", "To set up Verus Vault in Verus Desktop, you need the latest version of Verus Desktop and a VerusID on the Verus mainchain or any other chain when PBaaS is live. Verus Vault allows you to lock funds in your VerusID, making them unspendable, but still stakable and receivable. There are two types of locks: TimeLock and DelayLock.\n\n**TimeLock:**\nA TimeLock locks funds until a predetermined number of blocks have passed. To set up a TimeLock, you need to know the blockheight of the blockchain. Let's say the blockchain's blockheight is at 1,000,000 blocks, and you want to lock your VerusID for 1 year, which is approximately 508,994 blocks. You can use the command line interface in Verus Desktop to set up the TimeLock.\n\n**DelayLock:**\nA DelayLock locks funds and unlocks them with a delay. Funds cannot be spent until an unlock has been requested and a predetermined number of blocks have passed.\n\n**Getting Started:**\nTo set up Verus Vault, access the command line interface in Verus Desktop by going to \"settings\" (the cogwheel top right corner) and selecting \"Coin Settings\". Fill in the commands to set up your Vault.\n\n**Important Note:**\nFor long-term locking, it's best to take an average block time of 62 seconds into account. However, there are variables that make it difficult to predict an exact time, such as leap years. Over long-term, there are an average of 1394.5484 blocks per day.\n\nBy following these steps, you can set up Verus Vault in Verus Desktop and lock funds in your VerusID using either TimeLock or DelayLock.", "# Set up Verus Vault in Verus Desktop (flags)\n![image-vaulteasy](/images/lockfunds.png)\nVerus Vault is not yet accessible with clickable interfaces. You can still set up Vault in Verus Desktop. Here's how.What do you need:\n- Latest version Verus Desktop\n- VerusID (on the Verus mainchain, or when PBaaS is live on any other chain)With Verus Vault you can lock funds in your VerusID. When your funds are locked in the Vault you can not spend them anymore, they cannot leave the VerusID. You can still always continue to stake and receive coins.You can lock a VerusID in two different ways that cannot be circumvented by anyone, except the ``revocation and recovery authorities`` together.| Lock type | How it works | \n| - |:-----|:-----|\n| TimeLock | Locks the funds and unlocks until a predetermined number of blocks have passed. | \n| DelayLock | Locks the funds and unlocks with a delay. Funds can not be spent until an unlock has been requested + a predetermined number of blocks have passed. |### Get Started\nWe need to access the commandline interface in Verus Desktop. Go to ``settings`` (the cogwheel top right corner), then select ``Coin Settings``. Here we can fill in the commands to set up your Vault.## Vault with TimeLock\n![image-timelock](/images/timeock.png)\nNow let's put a Timelock on a VerusID. For a TimeLock you need to know the blockheight of the blockchain. Let's say the blockchain's blockheight is at ``1,000,000`` blocks. You want to lock your VerusID for 1 year. 1 year is ``508994`` blocks.::: warning Long-Term Locking\n**For long-term locking it's best to take an average block time of 62 seconds. Yet there are some variables that make it difficult to predict an exact time, leap years for example. Over long-term there are an average of 1394.5484 blocks per day.**\n:::", "./raw_text_input_docs/setup-vault.md"]]], [["User:: Hey, I'm really interested in exploring the payment capabilities of the Verus ecosystem. Can you tell me more about VerusPay and how it enables seamless payment experiences across different blockchain ecosystems?", "AI Assistant:: VerusPay is a fantastic innovation in the Verus ecosystem, and I'd be happy to explain it in detail.\n\nVerusPay is a sophisticated blockchain payment platform within the Verus ecosystem, designed to facilitate the creation, management, and processing of invoices using blockchain technology. It standardizes the format for invoices through the VerusPay Invoice specification, ensuring interoperability, security, and ease of use across different blockchain systems. This specification enables users to include detailed transaction information such as payment amounts, destinations, and requested currencies, as well as to handle conversions and accept payments from various PBaaS blockchains.\n\nVerusPay's functionality allows for the packaging of invoices into deeplinks and QR codes, making them easily accessible and usable within the Verus Mobile wallet and potentially other applications. This opens up a wide array of possibilities for merchants, developers, and users within the Verus network and beyond, offering a seamless payment experience across different blockchain ecosystems.\n\nIf you're interested in integrating VerusPay into your own project, you can refer to the verusid-ts-client helper library, which provides the necessary tools and resources to get started. Overall, VerusPay enables a secure, efficient, and user-friendly payment experience, empowering users to make transactions across different blockchain networks with ease.\n\nDo you have any further questions about VerusPay or how to integrate it into your project?"], "AI Assistant", "", "N/A", [["What is VerusPay, and how does it enable seamless payment experiences across different blockchain ecosystems?", "VerusPay is a sophisticated blockchain payment platform within the Verus ecosystem, designed to facilitate the creation, management, and processing of invoices using blockchain technology. It standardizes the format for invoices through the VerusPay Invoice specification, ensuring interoperability, security, and ease of use across different blockchain systems. This specification enables users to include detailed transaction information such as payment amounts, destinations, and requested currencies, as well as to handle conversions and accept payments from various PBaaS blockchains.\n\nVerusPay's functionality allows for the packaging of invoices into deeplinks and QR codes, making them easily accessible and usable within the Verus Mobile wallet and potentially other applications. This opens up a wide array of possibilities for merchants, developers, and users within the Verus network and beyond, offering a seamless payment experience across different blockchain ecosystems.\n\nTo utilize VerusPay in your own application or service, you can refer to the verusid-ts-client helper library, which provides the necessary tools and resources to integrate VerusPay into your project. Overall, VerusPay enables a secure, efficient, and user-friendly payment experience, empowering users to make transactions across different blockchain networks with ease.", "# VerusPay\n\nVerusPay represents a sophisticated blockchain payment platform within the Verus ecosystem, designed to facilitate the creation, management, and processing of invoices utilizing blockchain technology. Through the introduction of the VerusPay Invoice specification in VerusPay v3, it standardizes the format for invoices, ensuring interoperability, security, and ease of use across different blockchain systems. This specification enables users to include detailed transaction information such as payment amounts, destinations, and requested currencies, as well as to handle conversions and accept payments from various [PBaaS](/blockchains/) blockchains. Notably, it supports packaging these invoices into deeplinks and QR codes, making them easily accessible and usable within the Verus Mobile wallet and potentially other applications. This functionality opens up a wide array of possibilities for merchants, developers, and users within the Verus network and beyond, offering a seamless payment experience across different blockchain ecosystems.\n\n## Usage\n\nTo use VerusPay in your own application or service, refer to the [verusid-ts-client helper library.](https://github.com/VerusCoin/verusid-ts-client/tree/master)", "./raw_text_input_docs/README_veruspay.md"]]], [["User:: I'm trying to understand how to define a currency supply in Verus, and I'd love some guidance on the limitations and considerations involved. Additionally, could you walk me through the process of defining a PBaaS chain using the `definecurrency` command?", "AI Assistant:: Defining a currency supply in Verus requires careful consideration of the absolute limit for all currency supplies, which is set at 10 billion (-1 SATOSHI) with 8 decimal places (9999999999.99999999). This limit applies to all currency supplies, including those that may change over time due to conversions and extended tail emissions for blockchains.\n\nWhen defining a PBaaS chain, you'll need to use the `definecurrency` command with two JSON objects. The first object defines the properties of the PBaaS chain, and the second object defines the overridable defaults for the bridge.\n\nHere's an example of how to define a PBaaS chain named `PBaaSChain`:\n```shell\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"PBaaSChain\",\n\"options\":264,\n\"currencies\":[\"VRSCTEST\"],\n\"conversions\":[1],\n\"eras\":[\n{\n\"reward\":1200000000,\n\"decay\":0,\n\"halving\":0,\n\"eraend\":0\n}\n],\n\"notaries\":[\n\"Notary1@\",\n\"Notary2@\",\n\"Notary3@\"\n],\n\"minnotariesconfirm\":2,\n\"nodes\":[\n{\n\"networkaddress\":\"111.111.111.111:10000\",\n\"nodeidentity\":\"Node1@\"\n},\n{\n\"networkaddress\":\"111.111.111.112:10000\",\n\"nodeidentity\":\"Node2@\"\n}\n],\n\"gatewayconvertername\":\"Bridge\",\n\"gatewayconverterissuance\":1000000\n}'\n'{\n\"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\n\"initialcontributions\":[371747.20398827,0,1000000],\n\"initialsupply\":3000000\n}'\n```\nLet me break down what each part of the JSON objects does:\n\nThe first JSON object defines the PBaaS chain properties, including:\n\n* `name`: the name of the chain\n* `options`: an integer that configures the chain's properties\n* `currencies`: an array of currencies that can be converted to the chain's native currency\n* `conversions`: an array of conversion ratios between the chain's native currency and each currency on the chain\n* `eras`: an array of block reward, reward decay, halving, and end of each era in the chain's lifecycle\n* `notaries`: an array of VerusIDs that serve as notaries on the chain\n* `minnotariesconfirm`: the minimum number of notaries needed to confirm a block\n* `nodes`: an array of nodes on the chain, including their network addresses and IDs\n* `gatewayconvertername`: the name of the bridge\n* `gatewayconverterissuance`: the initial supply of the bridge's native token\n\nThe second JSON object defines the overridable defaults for the bridge, including:\n\n* `currencies`: an array of currencies supported by the bridge\n* `initialcontributions`: an array of initial liquidity for each currency in the bridge\n* `initialsupply`: the initial supply of the bridge's native token\n\nDo you have any further questions about defining a currency supply or creating a PBaaS chain with `definecurrency`?"], "AI Assistant", "", "N/A", [["What are the limitations and considerations when defining a currency supply in Verus, and how do you define a PBaaS chain using the `definecurrency` command?", "When defining a currency supply in Verus, it is essential to be aware of the absolute limit for all currency supplies. This limit is set at 10 billion (-1 SATOSHI) with 8 decimal places (9999999999.99999999). This limit applies to all currency supplies, including those that may change over time due to conversions and extended tail emissions for blockchains.\n\nTo define a PBaaS chain using the `definecurrency` command, you need to provide two JSON objects. The first object defines the properties of the PBaaS chain, and the second object defines the overridable defaults for the bridge.\n\nHere's an example of how to define a PBaaS chain named `PBaaSChain`:\n```shell\n./verus -chain=VRSCTEST definecurrency '{\n  \"name\":\"PBaaSChain\",\n  \"options\":264,\n  \"currencies\":[\"VRSCTEST\"],\n  \"conversions\":[1],\n  \"eras\":[\n    {\n      \"reward\":1200000000,\n      \"decay\":0,\n      \"halving\":0,\n      \"eraend\":0\n    }\n  ],\n  \"notaries\":[\n    \"Notary1@\",\n    \"Notary2@\",\n    \"Notary3@\"\n  ],\n  \"minnotariesconfirm\":2,\n  \"nodes\":[\n    {\n      \"networkaddress\":\"111.111.111.111:10000\",\n      \"nodeidentity\":\"Node1@\"\n    },\n    {\n      \"networkaddress\":\"111.111.111.112:10000\",\n      \"nodeidentity\":\"Node2@\"\n    }\n  ],\n  \"gatewayconvertername\":\"Bridge\",\n  \"gatewayconverterissuance\":1000000\n  }' \n  '{\n    \"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\n    \"initialcontributions\":[371747.20398827,0,1000000],\n    \"initialsupply\":3000000\n  }'\n```\nThe first JSON object defines the PBaaS chain properties, including:\n\n* `name`: the name of the chain\n* `options`: an integer that configures the chain's properties\n* `currencies`: an array of currencies that can be converted to the chain's native currency\n* `conversions`: an array of conversion ratios between the chain's native currency and each currency on the chain\n* `eras`: an array of block reward, reward decay, halving, and end of each era in the chain's lifecycle\n* `notaries`: an array of VerusIDs that serve as notaries on the chain\n* `minnotariesconfirm`: the minimum number of notaries needed to confirm a block\n* `nodes`: an array of nodes on the chain, including their network addresses and IDs\n* `gatewayconvertername`: the name of the bridge\n* `gatewayconverterissuance`: the initial supply of the bridge's native token\n\nThe second JSON object defines the overridable defaults for the bridge, including:\n\n* `currencies`: an array of currencies supported by the bridge\n* `initialcontributions`: an array of initial liquidity for each currency in the bridge\n* `initialsupply`: the initial supply of the bridge's native token", "::: danger Limit for all currency supplies (10 billion)\n10 billion (-1 SATOSHI) with 8 decimal places (9999999999.99999999) is now the recommended absolute limit for all currency supplies, including over time with conversions and extended tail emissions for blockchains.\n:::### Blockchain 1``` json\n./verus -chain=VRSCTEST definecurrency '{\n  \"name\":\"PBaaSChain\",\n  \"options\":264,\n  \"currencies\":[\"VRSCTEST\"],\n  \"conversions\":[1],\n  \"eras\":[\n    {\n      \"reward\":1200000000,\n      \"decay\":0,\n      \"halving\":0,\n      \"eraend\":0\n    }\n  ],\n  \"notaries\":[\n    \"Notary1@\",\n    \"Notary2@\",\n    \"Notary3@\"\n  ],\n  \"minnotariesconfirm\":2,\n  \"nodes\":[\n    {\n      \"networkaddress\":\"111.111.111.111:10000\",\n      \"nodeidentity\":\"Node1@\"\n    },\n    {\n      \"networkaddress\":\"111.111.111.112:10000\",\n      \"nodeidentity\":\"Node2@\"\n    }\n  ],\n  \"gatewayconvertername\":\"Bridge\",\n  \"gatewayconverterissuance\":1000000\n  }' \n  '{\n    \"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\n    \"initialcontributions\":[371747.20398827,0,1000000],\n    \"initialsupply\":3000000\n  }'\n```### Blockchain 2", "./raw_text_input_docs/define-pbaas.md"]]], [["User:: Hey there, I'm trying to figure out how to perform various transactions using the `sendcurrency` command in Verus. Can you walk me through how to use this command for converting between VRSCTEST and a PBaaS chain, sending VRSCTEST to other addresses, and sending VRSCTEST cross-chain to a PBaaS chain?", "AI Assistant:: The `sendcurrency` command in Verus is a powerful tool for performing various transactions. Here are some examples of how to use this command:\n\n**Converting VRSCTEST to PBaaSChain:**\nTo convert VRSCTEST to a PBaaS chain, you can use the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n\"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n\"amount\":10,\n\"convertto\":\"PBaaSChain\",\n\"exportto\":\"Bridge.PBaaSChain\",\n\"via\":\"Bridge.PBaaSChain\"\n}]'\n```\nThis command converts 10 units of VRSCTEST to the PBaaSChain, using the Bridge.PBaaSChain as the conversion path.\n\n**Converting PBaaSChain to VRSCTEST:**\nTo convert PBaaSChain to VRSCTEST, you can use the following command:\n```json\n./verus -chain=PBaaSChain sendcurrency \"*\" '[{\n\"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n\"amount\":10,\n\"convertto\":\"VRSCTEST\",\n\"exportto\":\"VRSCTEST\",\n\"via\":\"Bridge.PBaaSChain\"\n}]'\n```\nThis command converts 10 units of PBaaSChain to VRSCTEST, using the Bridge.PBaaSChain as the conversion path.\n\n**Sending VRSCTEST:**\nYou can send VRSCTEST from one address to another using the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"bob@\" '[{\n\"currency\":\"vrsctest\",\n\"address\":\"alice@\",\n\"amount\":10\n}]'\n```\nThis command sends 10 units of VRSCTEST from the address `bob@` to the address `alice@`.\n\n**Sending VRSCTEST to Multiple Recipients:**\nYou can send VRSCTEST to multiple recipients using the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*Z\" '[{\n\"currency\":\"vrsctest\",\n\"address\":\"alice@:private\",\n\"amount\":10\n},\n{\n\"currency\":\"VRSCTEST\",\n\"address\":\"bob@:private\",\n\"amount\":10\n}]'\n```\nThis command sends 10 units of VRSCTEST to each of the addresses `alice@:private` and `bob@:private`.\n\n**Sending VRSCTEST Cross-Chain:**\nYou can send VRSCTEST cross-chain to a PBaaS chain using the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n\"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n\"amount\":10,\n\"exportto\":\"Bridge.PBaaSChain\"\n}]'\n```\nThis command sends 10 units of VRSCTEST cross-chain to the PBaaSChain, using the Bridge.PBaaSChain as the conversion path.\n\nDo you have any questions about these examples, or would you like more information on using the `sendcurrency` command?"], "AI Assistant", "", "N/A", [["How do I perform various transactions using the `sendcurrency` command in Verus, including converting between VRSCTEST and a PBaaS chain, sending VRSCTEST to other addresses, and sending VRSCTEST cross-chain to a PBaaS chain?", "The `sendcurrency` command in Verus allows you to perform various transactions, including converting between VRSCTEST and a PBaaS chain, sending VRSCTEST to other addresses, and sending VRSCTEST cross-chain to a PBaaS chain. Here are some examples of how to use this command:\n\n**Converting VRSCTEST to PBaaSChain:**\nTo convert VRSCTEST to a PBaaS chain, you can use the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n  \"amount\":10,\n  \"convertto\":\"PBaaSChain\",\n  \"exportto\":\"Bridge.PBaaSChain\",\n  \"via\":\"Bridge.PBaaSChain\"\n}]'\n```\nThis command converts 10 units of VRSCTEST to the PBaaSChain, using the Bridge.PBaaSChain as the conversion path.\n\n**Converting PBaaSChain to VRSCTEST:**\nTo convert PBaaSChain to VRSCTEST, you can use the following command:\n```json\n./verus -chain=PBaaSChain sendcurrency \"*\" '[{\n  \"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n  \"amount\":10,\n  \"convertto\":\"VRSCTEST\",\n  \"exportto\":\"VRSCTEST\",\n  \"via\":\"Bridge.PBaaSChain\"\n}]'\n```\nThis command converts 10 units of PBaaSChain to VRSCTEST, using the Bridge.PBaaSChain as the conversion path.\n\n**Sending VRSCTEST:**\nYou can send VRSCTEST from one address to another using the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"bob@\" '[{\n  \"currency\":\"vrsctest\",\n  \"address\":\"alice@\",\n  \"amount\":10\n}]'\n```\nThis command sends 10 units of VRSCTEST from the address `bob@` to the address `alice@`.\n\n**Sending VRSCTEST to Multiple Recipients:**\nYou can send VRSCTEST to multiple recipients using the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*Z\" '[{\n  \"currency\":\"vrsctest\",\n  \"address\":\"alice@:private\",\n  \"amount\":10\n},\n{\n  \"currency\":\"VRSCTEST\",\n  \"address\":\"bob@:private\",\n  \"amount\":10\n}]'\n```\nThis command sends 10 units of VRSCTEST to each of the addresses `alice@:private` and `bob@:private`.\n\n**Sending VRSCTEST Cross-Chain:**\nYou can send VRSCTEST cross-chain to a PBaaS chain using the following command:\n```json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n  \"amount\":10,\n  \"exportto\":\"Bridge.PBaaSChain\"\n}]'\n```\nThis command sends 10 units of VRSCTEST cross-chain to the PBaaSChain, using the Bridge.PBaaSChain as the conversion path.", "### Converting VRSCTEST cross-chain to PBaaS-chain\n``` json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n  \"amount\":10,\n  \"convertto\":\"PBaaSChain\",\n  \"exportto\":\"Bridge.PBaaSChain\",\n  \"via\":\"Bridge.PBaaSChain\"\n}]'\n```\n\n### Converting PBaaS-chain to VRSCTEST\n``` json\n./verus -chain=PBaaSChain sendcurrency \"*\" '[{\n  \"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n  \"amount\":10,\n  \"convertto\":\"VRSCTEST\",\n  \"exportto\":\"VRSCTEST\",\n  \"via\":\"Bridge.PBaaSChain\"\n}]'\n```\n\n## Sending\nSending VRSCTEST from a single address (bob@) to a single recipient (alice@):\n``` json\n./verus -chain=VRSCTEST sendcurrency \"bob@\" '[{\n  \"currency\":\"vrsctest\",\n  \"address\":\"alice@\",\n  \"amount\":10\n}]'\n```\n\nSending VRSCTEST from all private wallet funds to two recipients with friendly-name z-addresses (alice@:private and bob@:private):\n``` json\n./verus -chain=VRSCTEST sendcurrency \"*Z\" '[{\n  \"currency\":\"vrsctest\",\n  \"address\":\"alice@:private\",\n  \"amount\":10\n},\n{\n  \"currency\":\"VRSCTEST\",\n  \"address\":\"bob@:private\",\n  \"amount\":10\n}]'\n```\n\nSending VRSCTEST cross-chain to PBaaSChain:\n``` json\n./verus -chain=VRSCTEST sendcurrency \"*\" '[{\n  \"address\":\"RXLYm4J6qi7yam9zXtkEkRwbvCrnWKGZuv\",\n  \"amount\":10,\n  \"exportto\":\"Bridge.PBaaSChain\"\n}]'\n```", "./raw_text_input_docs/sendcurrency-examples.md"]]], [["User:: I'm interested in learning more about how VerusIDs can help with managing funds. How do VerusIDs provide secure and private ways to manage funds, and what are some potential use cases for these features?", "AI Assistant:: VerusIDs offer a range of features that enable secure and private management of funds. Here are some examples:\n\nVerusIDs can be used to lock funds using Vault, which allows you to set a delay of 10,080 blocks (approximately 1 week) before the funds can be spent. This provides an additional layer of security, as even if someone gains access to the private keys of the locked VerusID, they will have to unlock the identity before they can spend the funds. During this time, the original owner can be warned and take action to safeguard their funds.\n\nAnother example is **Trusts:** VerusIDs can be used to set up trust funds for beneficiaries, such as children. By locking the VerusID with funds, you can ensure that the funds are only accessible when the beneficiary reaches a certain age or meets specific conditions. Meanwhile, you can maintain control over the revocation and recovery authorities to ensure the funds are protected.\n\n**Vesting Periods:** VerusIDs can be used to manage development funds or other types of funds that need to be locked for a specific period. By locking the funds in a VerusID, you can ensure that they are only accessible after a certain period, such as two years, and only with the signatures of authorized parties.\n\nThe VerusID Marketplace protocol is another feature that enables peer-to-peer buying and selling of VerusIDs without the need for intermediaries or contract controllers. This decentralized marketplace allows users to find offers on any VerusID and make deals directly on the blockchain. For added privacy, users can utilize private addresses and zero-knowledge transactions based on the Zcash Sapling protocol.\n\nThese features provide a range of potential use cases, from secure staking and trust funds to vesting periods and decentralized marketplaces. By leveraging the capabilities of VerusIDs, users can manage their funds in a secure, private, and flexible manner.\n\nDo you have any questions about these features or potential use cases, or would you like to know more about how VerusIDs can help with fund management?"], "AI Assistant", "", "N/A", [["How do VerusIDs provide secure and private ways to manage funds, and what are some potential use cases for these features?", "VerusIDs offer various features that enable secure and private management of funds. Here are some examples:\n\n**Safe Staking:** VerusIDs can be locked using Vault, which allows you to set a delay of 10,080 blocks (approximately 1 week) before the funds can be spent. This provides an additional layer of security, as even if someone gains access to the private keys of the locked VerusID, they will have to unlock the identity before they can spend the funds. During this time, the original owner can be warned and take action to safeguard their funds.\n\n**Trusts:** VerusIDs can be used to set up trust funds for beneficiaries, such as children. By locking the VerusID with funds, you can ensure that the funds are only accessible when the beneficiary reaches a certain age or meets specific conditions. Meanwhile, you can maintain control over the revocation and recovery authorities to ensure the funds are protected.\n\n**Vesting Periods:** VerusIDs can be used to manage development funds or other types of funds that need to be locked for a specific period. By locking the funds in a VerusID, you can ensure that they are only accessible after a certain period, such as two years, and only with the signatures of authorized parties.\n\n**Marketplace:** The VerusID Marketplace protocol enables peer-to-peer buying and selling of VerusIDs without the need for intermediaries or contract controllers. This decentralized marketplace allows users to find offers on any VerusID and make deals directly on the blockchain. For added privacy, users can utilize private addresses and zero-knowledge transactions based on the Zcash Sapling protocol.\n\nThese features provide a range of potential use cases, from secure staking and trust funds to vesting periods and decentralized marketplaces. By leveraging the capabilities of VerusIDs, users can manage their funds in a secure, private, and flexible manner.", ":::tip Safe Staking\nPut funds to stake with on a VerusID. Use Vault to lock the identity with a delay of 10,080 blocks ( ~1 week). Now whenever someone gains access to the private keys of the locked VerusID, they have to unlock the identity in order to spend the funds. When someone makes an unlock request that isn't you, you are warned. The intruder has to wait 10,080 blocks before he can spend the funds. If you have set up revocation and recovery authorities, you now have one week to safeguard your funds away from prying hands, back into your control.\n::::::tip Trusts\nSetting up a trust fund for your children. Give your child a time locked VerusID with funds on them. When he or she turns 18, the VerusID unlocks and the funds can be spent. Keep revocation and recovery authorities with yourself or a trustee.\n::::::tip Vesting Periods\nWhen doing a currency or chain launch, development funds can be diverted to a locked VerusID. After two years the VerusID unlocks and the funds can only be spent with signatures of other developers. You can also spread the funds across multiple identities with different unlock periods.\n:::## Marketplace\nWith the VerusID Marketplace protocol, anyone is able to buy and sell VerusIDs. You can look for offers on any VerusID (buy or sell offers). If you like the best offer on your VerusID, or if someone likes an offer you made on theirs, the deal is made 100% peer-to-peer, decentralized on the blockchain, without any middleman or contract controller.For total payment privacy, you can even pay or receive payment using private addresses and zero knowledge transactions based on the Zcash Sapling protocol.### Exchanging in\u00a0Private", "./raw_text_input_docs/README_addresses.md"]]], [["User:: Hey, I'm trying to update my VerusID to add a lock, and then unlock it later. Can you walk me through the process using the Verus Desktop command line interface?", "AI Assistant:: I'd be happy to help you with that.\n\nTo update a VerusID to add a lock, you can use the `updateidentity` command in the Verus Desktop command line interface. Here's an example of how to do it:\n\nYou can copy and paste the following code snippet into the command line interface of Verus Desktop, and then edit the necessary inputs for your needs:\n```json\nrun updateidentity\n'{\n\"name\":\"youridentityname\",\n\"minimumsignatures\":1,\n\"primaryaddresses\":[\"primary-address-comes-here\"],\n\"flags\":2,\n\"timelock\":10080\n}'\n```\nIn this code snippet, you need to replace `\"youridentityname\"` with the name of your VerusID, and `\"primary-address-comes-here\"` with your primary address. The `\"flags\"` property is set to 2, which indicates that a lock is being added. The `\"timelock\"` property specifies the number of blocks that need to pass before the lock can be removed.\n\nOnce the lock is added, you will not be able to spend the funds associated with your VerusID until the predetermined number of blocks has passed.\n\nTo unlock your VerusID, you can use a similar `updateidentity` command, but with the `\"flags\"` property set to 0:\n```json\nrun updateidentity\n'{\n\"name\":\"youridentityname\",\n\"minimumsignatures\":1,\n\"primaryaddresses\":[\"primary-address-comes-here\"],\n\"flags\":0\n}'\n```\nAgain, you need to replace `\"youridentityname\"` with the name of your VerusID, and `\"primary-address-comes-here\"` with your primary address. After running this command, you will need to wait for the predetermined number of blocks to pass before you can spend the funds associated with your VerusID again.\n\nIt's worth noting that you can always revoke and recover a locked VerusID if needed.\n\nDo you have any questions about this process, or would you like more information on using locks with VerusIDs?"], "AI Assistant", "", "N/A", [["Explain how to update a VerusID to add a lock, and then unlock it, using the Verus Desktop command line interface?", "To update a VerusID to add a lock, you can use the `updateidentity` command in the Verus Desktop command line interface. Here's an example of how to do it:\n\nYou can copy and paste the following code snippet into the command line interface of Verus Desktop, and then edit the necessary inputs for your needs:\n```json\nrun updateidentity \n'{ \n  \"name\":\"youridentityname\",\n  \"minimumsignatures\":1,\n  \"primaryaddresses\":[\"primary-address-comes-here\"],\n  \"flags\":2,\n  \"timelock\":10080\n  }'\n```\nIn this code snippet, you need to replace `\"youridentityname\"` with the name of your VerusID, and `\"primary-address-comes-here\"` with your primary address. The `\"flags\"` property is set to 2, which indicates that a lock is being added. The `\"timelock\"` property specifies the number of blocks that need to pass before the lock can be removed.\n\nOnce the lock is added, you will not be able to spend the funds associated with your VerusID until the predetermined number of blocks has passed.\n\nTo unlock your VerusID, you can use a similar `updateidentity` command, but with the `\"flags\"` property set to 0:\n```json\nrun updateidentity \n'{ \n  \"name\":\"youridentityname\",\n  \"minimumsignatures\":1,\n  \"primaryaddresses\":[\"primary-address-comes-here\"],\n  \"flags\":0\n  }'\n```\nAgain, you need to replace `\"youridentityname\"` with the name of your VerusID, and `\"primary-address-comes-here\"` with your primary address. After running this command, you will need to wait for the predetermined number of blocks to pass before you can spend the funds associated with your VerusID again.\n\nIt's worth noting that you can always revoke and recover a locked VerusID if needed.", "``` json\nrun updateidentity \n'{ \n  \"name\":\"youridentityname\",\n  \"minimumsignatures\":1,\n  \"primaryaddresses\":[\"primary-address-comes-here\"],\n  \"flags\":2,\n  \"timelock\":10080\n  }'\n```\n\nYou can copy and paste this code snippet into the commandline interface of Verus Desktop and edit the necessary inputs for your needs. In the code snippet are the minimum requirements to update your VerusID with a lock.\n\n:::tip Revoke & Recover\nRemember: you can always revoke and recover a locked VerusID.\n:::\n\n### Request an unlock\nAbove you locked a VerusID with a DelayLock. Now let's request an unlock. When an unlock has been requested you have to wait the predetermined number of blocks before you can spend the funds again.\n\nFill in your VerusID ``name``, the ``primary address`` and set ``flags`` to 0. Now you only have to wait for your predetermined number of blocks (10,080 in our example) to run out so you can spend the funds again.\n\n``` json\nrun updateidentity \n'{ \n  \"name\":\"youridentityname\",\n  \"minimumsignatures\":1,\n  \"primaryaddresses\":[\"primary-address-comes-here\"],\n  \"flags\":0\n  }'\n```\n\nYou can copy and paste this code snippet into the commandline interface of Verus Desktop and edit the necessary inputs for your needs. In the code snippet are the minimum requirements to unlock your VerusID.", "./raw_text_input_docs/setup-vault.md"]]], [["User:: I'm trying to understand more about VerusIDs, and I was wondering if you could explain what information the `getidentity` command provides, and what's the significance of the various fields in the output?", "AI Assistant:: The `getidentity` command in Verus is a powerful tool that provides detailed information about a specific identity on the Verus network. The command takes a VerusID as input, and returns a JSON object containing various fields that describe the identity.\n\nThe output of the `getidentity` command provides a wealth of information about the identity, including:\n\n* `fullyqualifiedname`: The fully qualified name of the identity, which includes the identity name and the namespace (e.g., `Verus Coin Foundation.VRSC@`).\n* `identity`: A nested object that contains detailed information about the identity.\n* `version`: The version number of the identity.\n* `flags`: A set of flags that indicate the properties of the identity.\n* `primaryaddresses`: An array of addresses that are associated with the identity.\n* `minimumsignatures`: The minimum number of signatures required to authorize transactions or actions on behalf of the identity.\n* `name`: The human-readable name of the identity.\n* `identityaddress`: The address of the identity on the Verus network.\n* `parent`: The parent identity of the current identity (if applicable).\n* `systemid`: The system ID of the identity (if applicable).\n* `contentmap` and `contentmultimap`: Objects that contain additional metadata about the identity, such as key-value pairs and multi-valued items.\n* `revocationauthority` and `recoveryauthority`: The addresses that are authorized to revoke or recover the identity, respectively.\n* `privateaddress`: The private address associated with the identity.\n* `timelock`: A timestamp that indicates when the identity was last updated.\n\nThe significance of these fields lies in the fact that they provide a comprehensive view of the identity, including its properties, relationships, and permissions. This information is essential for users to manage their identities effectively and securely on the Verus network.\n\nIn addition, the output of the `getidentity` command highlights the decentralized nature of the VerusID system, where users have full control over their identities and can manage them without relying on a central authority. This is particularly important in the context of revoking and recovering identities, which are critical operations that require careful management to ensure the security and integrity of the identity system.\n\nDo you have any further questions about the `getidentity` command or the information it provides?"], "AI Assistant", "", "N/A", [["What information does the `getidentity` command in Verus provide, and what is the significance of the various fields in the output?", "The `getidentity` command in Verus is used to retrieve detailed information about a specific identity on the Verus network. The command takes a VerusID as input, and returns a JSON object containing various fields that describe the identity.\n\nThe output of the `getidentity` command provides a wealth of information about the identity, including:\n\n* `fullyqualifiedname`: The fully qualified name of the identity, which includes the identity name and the namespace (e.g., `Verus Coin Foundation.VRSC@`).\n* `identity`: A nested object that contains detailed information about the identity.\n* `version`: The version number of the identity.\n* `flags`: A set of flags that indicate the properties of the identity.\n* `primaryaddresses`: An array of addresses that are associated with the identity.\n* `minimumsignatures`: The minimum number of signatures required to authorize transactions or actions on behalf of the identity.\n* `name`: The human-readable name of the identity.\n* `identityaddress`: The address of the identity on the Verus network.\n* `parent`: The parent identity of the current identity (if applicable).\n* `systemid`: The system ID of the identity (if applicable).\n* `contentmap` and `contentmultimap`: Objects that contain additional metadata about the identity, such as key-value pairs and multi-valued items.\n* `revocationauthority` and `recoveryauthority`: The addresses that are authorized to revoke or recover the identity, respectively.\n* `privateaddress`: The private address associated with the identity.\n* `timelock`: A timestamp that indicates when the identity was last updated.\n\nThe significance of these fields lies in the fact that they provide a comprehensive view of the identity, including its properties, relationships, and permissions. This information is essential for users to manage their identities effectively and securely on the Verus network.\n\nIn addition, the output of the `getidentity` command highlights the decentralized nature of the VerusID system, where users have full control over their identities and can manage them without relying on a central authority. This is particularly important in the context of revoking and recovering identities, which are critical operations that require careful management to ensure the security and integrity of the identity system.", "Input:\n```\n./verus getidentity \"Verus Coin Foundation@\"\n```\nOutput:\n``` json\n{\n\"fullyqualifiedname\": \"Verus Coin Foundation.VRSC@\",\n\"identity\": {\n\"version\": 3,\n\"flags\": 0,\n\"primaryaddresses\": [\"REpxm9bCLMiHRNVPA9unPBWixie7uHFA5C\"],\n\"minimumsignatures\": 1,\n\"name\": \"Verus Coin Foundation\",\n\"identityaddress\": \"i5v3h9FWVdRFbNHU7DfcpGykQjRaHtMqu7\",\n\"parent\": \"i5w5MuNik5NtLcYmNzcvaoixooEebB6MGV\",\n\"systemid\": \"i5w5MuNik5NtLcYmNzcvaoixooEebB6MGV\",\n\"contentmap\": {},\n\"contentmultimap\": {\n\"i5Zkx5Z7tEfh42xtKfwbJ5LgEWE9rEgpFY\": [{\n\"i5Zkx5Z7tEfh42xtKfwbJ5LgEWE9rEgpFY\": {\n\"version\": 1,\n\"action\": 2,\n\"entrykey\": \"73960afaad96f923c616b26f9646c059021d4ffa\",\n\"valuehash\": \"10230fb3df7c507f062593c55d94d1442f937b68b71e045c442e1e49647cfc6a\"\n}\n},\n{\n\"i5Zkx5Z7tEfh42xtKfwbJ5LgEWE9rEgpFY\": {\n\"version\": 1,\n\"action\": 2,\n\"entrykey\": \"73960afaad96f923c616b26f9646c059021d4ffa\",\n\"valuehash\": \"9ed2b3516d4ccd2d419bfb12f325902e1a3f566d222445c97005e4e8fee5903a\"\n}\n}],\n\"iSJ38vYX7qoCtotc9wBHb1vZdR3oTgoHCX\": [\"0186ff9300d99a27d51944ef1563b8c3b7445bc67ce91cebc8809cff0000\"]\n},\n\"revocationauthority\": \"i5v3h9FWVdRFbNHU7DfcpGykQjRaHtMqu7\",\n\"recoveryauthority\": \"i5v3h9FWVdRFbNHU7DfcpGykQjRaHtMqu7\",\n\"privateaddress\": \"zs1dycegwse0x67qvy2fksukcng3ekkgvly2qwjckj8fxraam33xu2y5jyh3yva0e4ywec9quedcud\",\n\"timelock\": 0\n},\n\"status\": \"active\",\n\"canspendfor\": false,\n\"cansignfor\": false,\n\"blockheight\": 2588672,\n\"txid\": \"802e3e5e928038bdabae648f0690d919bce85759b3ecc845db458cc1dba0fe83\",\n\"vout\": 0\n}\n```## Revoke & Recover\nRevoking and recovering identities are essentials in a decentralized system. Users need to have full self-sovereignty to move around in an ecosystem without central control. VerusID is the first decentralized identity system where users have full control over their identities.", "./raw_text_input_docs/README_addresses.md"]]], [["User:: Hey, I'm trying to understand how to define a currency in Verus using the `definecurrency` command. Can you explain the key components and parameters that can be specified, and how they affect the behavior of the currency?", "AI Assistant:: When defining a currency using the `definecurrency` command in Verus, there are several key components and parameters that can be specified to customize the behavior of the currency.\n\nLet's break them down:\n\n**Name and Options:**\nThe `name` parameter specifies the name of the currency, while the `options` parameter is an integer that can be used to customize the behavior of the currency.\n\n**Currencies and Weights:**\nThe `currencies` parameter specifies an array of currencies that can be converted into the reserves of the currency being defined. The `weights` parameter specifies the relative weights of each currency in the reserves. For example, in the example given, VRSCTEST has a weight of 0.5, while BusinessBrand and DiscountBrand each have a weight of 0.25.\n\n**Initial Supply:**\nThe `initialsupply` parameter specifies the initial supply of the currency.\n\n**Start Block:**\nThe `startblock` parameter specifies the block height at which the currency should be launched. If this parameter is omitted, the currency will have a preconversion time frame of 20 blocks before launch. The preconversion time frame is always at least 20 blocks and cannot be less.\n\n**End Block:**\nThe `endblock` parameter is only applicable to centralized (`proofprotocol:2`) simple token currencies. When the end block is reached, it turns the centralized currency into a decentralized one, removing minting and burning capabilities. It does nothing for basket currencies.\n\n**ID Registration Fees:**\nThe `idregistrationfees` parameter specifies the cost of registering subIDs under the rootID. The default registration fee is 100. When the currency is decentralized, the fees are burned, reducing the supply of the currency and increasing its value. When the currency is centralized, the fees go to the rootID.\n\nIn summary, these parameters allow for customization of the currency's behavior, including its reserves, launch timing, and fees.\n\nDo you have any more questions about defining a currency in Verus, or would you like me to elaborate on any of these parameters?"], "AI Assistant", "", "N/A", [["What are the key components and parameters that can be specified when defining a currency using the `definecurrency` command in Verus, and how do they affect the behavior of the currency?", "When defining a currency using the `definecurrency` command in Verus, there are several key components and parameters that can be specified to customize the behavior of the currency.\n\n**Name and Options:**\nThe `name` parameter specifies the name of the currency, while the `options` parameter is an integer that can be used to customize the behavior of the currency.\n\n**Currencies and Weights:**\nThe `currencies` parameter specifies an array of currencies that can be converted into the reserves of the currency being defined. The `weights` parameter specifies the relative weights of each currency in the reserves. For example, in the example given, VRSCTEST has a weight of 0.5, while BusinessBrand and DiscountBrand each have a weight of 0.25.\n\n**Initial Supply:**\nThe `initialsupply` parameter specifies the initial supply of the currency.\n\n**Start Block:**\nThe `startblock` parameter specifies the block height at which the currency should be launched. If this parameter is omitted, the currency will have a preconversion time frame of 20 blocks before launch. The preconversion time frame is always at least 20 blocks and cannot be less.\n\n**End Block:**\nThe `endblock` parameter is only applicable to centralized (`proofprotocol:2`) simple token currencies. When the end block is reached, it turns the centralized currency into a decentralized one, removing minting and burning capabilities. It does nothing for basket currencies.\n\n**ID Registration Fees:**\nThe `idregistrationfees` parameter specifies the cost of registering subIDs under the rootID. The default registration fee is 100. When the currency is decentralized, the fees are burned, reducing the supply of the currency and increasing its value. When the currency is centralized, the fees go to the rootID.\n\nIn summary, these parameters allow for customization of the currency's behavior, including its reserves, launch timing, and fees.", "Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBusiness\", \n \"options\":33, \n \"currencies\":[\"vrsctest\",\"BusinessBrand\",\"DiscountBrand\"], \n \"initialsupply\":100, \n \"weights\":[0.5,0.25,0.25]\n}'\n```\n\u261d\ufe0f This is a basket currency called MyBusiness. During the preconversion time frame there are various currencies that can be converted into its reserves. They have different weights to them. 0.5 for VRSCTEST, 0.25 for both BusinessBrand and DiscountBrand.### **\"startblock\"**\nUse this parameter to define the block height when the currency should be launched. There is a preconversion time frame before the currency is launched. When omitting this parameter it uses a 20 block preconversion time frame before the currency is launched.The preconversion time frame is always 20 blocks, this can not be less.\u26a0\ufe0f IMPORTANT: Fill in the absolute block height you want the currency to launch on.### **\"endblock\"**\nEndblock can not be defined on basket currencies. It does nothing. It could be set as a signal to software that might use the basket currency.It can be set on centralized (`proofprotcol:2`) simple token currencies. When the endblock is reached, it turns the centralized currency into a decentralized one (no more minting and burning capabilities.)### **\"idregistrationfees\"**\nUse this parameter to change the costs of registering subIDs under the rootID. The default registration fee is `100`.\nWhen it\u2019s a decentralized currency the fees are burned (and the basket currency becomes worth more because there is less supply, yet the reserves stay the same), when it\u2019s centralized the fees go to the rootID.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: Hi, I'm interested in learning more about VerusHash and its role in ensuring security. Can you explain how VerusHash ensures security, and what are the key benefits of Verus' staking algorithm in solving Proof of Stake (PoS) problems?", "AI Assistant:: I'd be happy to explain!\n\nVerusHash is a unique algorithm that takes any length of input and produces a 256-bit hash result, providing the same security guarantees as Haraka512 V2. This makes VerusHash 256-bit secure for classical computing attacks and 128-bit secure against quantum computers for pre-image and second pre-image attacks.\n\nTo understand VerusHash, it's helpful to separate the digest from the core. The Haraka512 V2 core acts as an abstract digest function that takes 512 bits of input and produces 256 bits of output. The VerusHash algorithm can be implemented concisely in any language using this digest function. For example, in Python, the VerusHash hash digest can be implemented as follows:\n\n```py\n# verus_hash\ndef verus_hash(msg):\nbuf = [0] * 64\nlength = len(msg)\nfor i in range(0, length, 32):\nclen = min(32, length - i)\nbuf[32:64] = [b for b in msg[i:i + clen]] + [0] * (32 - clen)\nbuf[0:32] = haraka512256(buf)\nreturn bytes(buf[0:32])\n```\n\nRegarding Verus' staking algorithm, it's designed to solve two major theoretical issues undermining other PoS systems: \"Nothing at Stake\" and \"Weak Subjectivity\". These problems are addressed by leveraging smart transaction capabilities to remove any incentive to attempt cheating, making it a losing proposition. This ensures that the staking algorithm is secure and reliable.\n\nThe key benefits of Verus' staking algorithm are that it prevents common PoS problems, making the network more secure and reliable for users. Does that answer your question? Do you have any more questions about VerusHash or the staking algorithm?"], "AI Assistant", "", "N/A", [["How does VerusHash ensure security, and what are the key benefits of Verus' staking algorithm in solving Proof of Stake (PoS) problems?", "VerusHash is a unique algorithm that takes any length of input and produces a 256-bit hash result, providing the same security guarantees as Haraka512 V2. This makes VerusHash 256-bit secure for classical computing attacks and 128-bit secure against quantum computers for pre-image and second pre-image attacks.\n\nTo understand VerusHash, it's helpful to separate the digest from the core. The Haraka512 V2 core acts as an abstract digest function that takes 512 bits of input and produces 256 bits of output. The VerusHash algorithm can be implemented concisely in any language using this digest function. For example, in Python, the VerusHash hash digest can be implemented as follows:\n\n```py\n# verus_hash\ndef verus_hash(msg):\n  buf = [0] * 64\n  length = len(msg)\n  for i in range(0, length, 32):\n    clen = min(32, length - i)\n    buf[32:64] = [b for b in msg[i:i + clen]] + [0] * (32 - clen)\n    buf[0:32] = haraka512256(buf)\n  return bytes(buf[0:32])\n```\n\nVerus' staking algorithm is designed to solve two major theoretical issues undermining other PoS systems: \"Nothing at Stake\" and \"Weak Subjectivity\". These problems are addressed by leveraging smart transaction capabilities to remove any incentive to attempt cheating, making it a losing proposition. This ensures that the staking algorithm is secure and reliable.", "Haraka512 V2 is designed as a short input hash to exclusively consume one chunk of 512 bits and produce 256 bits of a hash result. Utilizing Haraka512 V2 VerusHash takes any length of input and produces a 256 bit hash result, unique to VerusHash, that also provides the same security guarantees as Haraka512 V2. This makes VerusHash 256 bit secure for classical computing attacks and 128 bit secure against quantum computers for pre-image and second pre-image attacks.\n\nTo understand the VerusHash algorithm it helps to first separate the digest from the core. We then consider the Haraka512 V2 core as an abstract digest function that takes 512 bits (64 bytes) of input and produces 256 bits (32 bytes) of output. Given such a digest function, referred to as haraka512256, the most concise implementation of VerusHash, in any language to-date, is the following Python code for the VerusHash hash digest as follows:\"\n\n``` py\n# verus_hash\n    def verus_hash(msg):\n      buf = [0] * 64\n      length = len(msg)\n      for i in range(0, length, 32):\n        clen = min(32, length - i)\n        buf[32:64] = [b for b in msg[i:i + clen]] + [0] * (32 - clen)\n        buf[0:32] = haraka512256(buf)\n      return bytes(buf[0:32])\n```\n\n## PoS Problems Solved\nVerus\u2019 staking algorithm solves the two major theoretical issues undermining other PoS systems, ``Nothing at Stake`` and ``Weak Subjectivity`` by leveraging its smart transaction capabilities to remove any incentive to attempt cheating, making it a losing proposition. [Read: How Verus Solved Proof of Stake\u2019s Two Biggest Problems: Nothing at Stake and Weak Subjectivity](https://medium.com/veruscoin/how-verus-solved-nothing-at-stake-and-weak-subjectivity-proof-of-stake-problems-b4dd6a85086e)", "./raw_text_input_docs/verus-proof-of-power.md"]]], [["User:: I'm interested in creating a new currency on the Verus platform. Could you explain how to launch a new currency, and what are the requirements and costs associated with it?", "AI Assistant:: Launching a new currency on Verus is a fascinating topic! I'd be happy to walk you through the process.\n\nTo launch a new currency on Verus, you need to define the currency using the `definecurrency` command, which is processed into a HEX and broadcasted to the network. The fees for launching a currency are taken from the rootID and distributed among the block producers. After a minimum period of 20 blocks, the currency is launched and ready to be used by the worldwide network.\n\nBefore launching a currency, you need a namespace, which is a VerusID. This VerusID is the name of the currency, and it can have subIDs. The controller of this VerusID is the only one who can create a currency of that name, and they can only do so once.\n\nThe costs of launching a currency on Verus include the registration of the VerusID, which costs between 20 and 100 VRSC, and the launch of the currency itself, which costs 200 VRSC. These costs are always paid in the chain's native coin to the worldwide miners and stakers.\n\nWhen defining a currency, you need to choose options that combine to meet the needs of the currency. These options are added together in the currency definition, and they determine the characteristics of the currency. For example, the `proofprotocol` option determines the type of proof used to secure the currency, and the `preallocations` option determines the initial distribution of the currency.\n\nHere's an example of a simple currency definition:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"MyBrand\",\n\"options\":32,\n\"proofprotocol\":2,\n\"preallocations\":[{\"Klaus@\":100}]\n}'\n```\nThis command defines a currency called \"MyBrand\" with options 32, proof protocol 2, and an initial allocation of 100 units to the address \"Klaus@\".\n\nDo you have any questions about this process, or would you like more information on the available options for defining a currency?"], "AI Assistant", "", "N/A", [["How do I launch a new currency on Verus, and what are the requirements and costs associated with it?", "To launch a new currency on Verus, you need to define the currency using the `definecurrency` command, which is processed into a HEX and broadcasted to the network. The fees for launching a currency are taken from the rootID and distributed among the block producers. After a minimum period of 20 blocks, the currency is launched and ready to be used by the worldwide network.\n\nBefore launching a currency, you need a namespace, which is a VerusID. This VerusID is the name of the currency, and it can have subIDs. The controller of this VerusID is the only one who can create a currency of that name, and they can only do so once.\n\nThe costs of launching a currency on Verus include the registration of the VerusID, which costs between 20 and 100 VRSC, and the launch of the currency itself, which costs 200 VRSC. These costs are always paid in the chain's native coin to the worldwide miners and stakers.\n\nWhen defining a currency, you need to choose options that combine to meet the needs of the currency. These options are added together in the currency definition, and they determine the characteristics of the currency. For example, the `proofprotocol` option determines the type of proof used to secure the currency, and the `preallocations` option determines the initial distribution of the currency.\n\nHere is an example of a simple currency definition:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBrand\", \n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Klaus@\":100}]\n}'\n```\nThis command defines a currency called \"MyBrand\" with options 32, proof protocol 2, and an initial allocation of 100 units to the address \"Klaus@\".", "# Launch currencies::: warning Need help setting up a currency launch? \ud83e\udd14\n[Go to the Verus Discord #pbaas-development channel. The community is happy to assist!](https://www.verus.io/discord)\n:::![image-currencies-launching](/images/launching-currencies.png)This is what a (simple) currency definition looks like:``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBrand\", \n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Klaus@\":100}]\n}'\n```The above command is processed into a HEX, and that HEX is broadcasted to the network. Simultaneously the fees are taken from the rootID (and distributed among the block producers) and after waiting a minimum period of 20 blocks the currency is launched and ready to be used by the worldwide network.## VerusID namespace\nTo launch a currency on Verus (and any other PBaaS-chain) a namespace is needed. That namespace is a VerusID. The namespace is the name of the currency (e.g. ``MyBrand@``). That namespace can also have subIDs (e.g. ``product.MyBrand@``, ``user.MyBrand@``). The controller of this VerusID is the only one who can create a currency of that name, and they can only do so once.On Verus a VerusID registration costs between 20 and 100 VRSC, and the launch of a currency costs 200 VRSC. These costs are always paid in the chain\u2019s native coin (to the worldwide miners and stakers). On other PBaaS-chains these costs can differ since the chain launcher can define its own costs for VerusID registrations and currency launches.## Defining options\nTo define a currency, choose options. Then combine these options to whatever the currency needs to be. Just add the numbers together in the currency definition. The currency options are listed below.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I'm interested in creating a new currency on the Verus network, similar to USDC. Can you walk me through the steps involved in defining and launching a new currency, and how I can export it to Ethereum?", "AI Assistant:: Creating a new currency on the Verus network is a straightforward process. Here are the steps you need to follow:\n\nTo define and launch a new currency on the Verus network, you need to follow these steps:\n\n**Defining the Currency**\nFirst, you need to define the currency using the `definecurrency` command. This command takes a JSON object as an argument, which specifies the properties of the currency. For example, to define a USDC-like currency called \"MyUSDC\", you would use the following command:\n\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"MyUSDC\",\n\"options\":32,\n\"systemid\":\"veth\",\n\"parent\":\"vrsctest\",\n\"launchsystemid\":\"vrsctest\",\n\"nativecurrencyid\":{\n\"type\":9,\n\"address\":\"0x98339D8C260052B7ad81c28c16C0b98420f2B46a\"\n},\n\"initialsupply\":0,\n\"proofprotocol\":3\n}'\n```\n\nThis command defines a new currency called \"MyUSDC\" with the specified properties.\n\n**Launching the Currency**\nAfter defining the currency, you need to launch it on the network. To do this, you need to take the HEX returned by the `definecurrency` command and use it with the `sendrawtransaction` command. For example:\n\n``` json\n./verus -chain=VRSCTEST sendrawtransaction \"HEX\"\n```\n\nThis command launches the currency on the network.\n\n**Waiting for Confirmation**\nAfter launching the currency, you need to wait for a few blocks to be confirmed on the network. This allows the currency to be fully available on the network.\n\n**Exporting to Ethereum (Optional)**\nFinally, if you want to make the currency available on Ethereum as well, you need to export it. This involves additional steps, which are explained in more detail in a separate guide.\n\nBy following these steps, you can define and launch a new currency on the Verus network, and optionally export it to Ethereum.\n\nDo you have any questions about these steps, or would you like more information on exporting your new currency to Ethereum?"], "AI Assistant", "", "N/A", [["What are the steps involved in defining and launching a new currency, specifically a USDC-like currency, on the Verus network, and how do you export it to Ethereum?", "To define and launch a new currency on the Verus network, you need to follow these steps:\n\n**Step 1: Define the Currency**\nFirst, you need to define the currency using the `definecurrency` command. This command takes a JSON object as an argument, which specifies the properties of the currency. For example, to define a USDC-like currency called \"MyUSDC\", you would use the following command:\n\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n  \"name\":\"MyUSDC\", \n  \"options\":32, \n  \"systemid\":\"veth\", \n  \"parent\":\"vrsctest\", \n  \"launchsystemid\":\"vrsctest\", \n  \"nativecurrencyid\":{\n    \"type\":9, \n    \"address\":\"0x98339D8C260052B7ad81c28c16C0b98420f2B46a\"\n  }, \n  \"initialsupply\":0, \n  \"proofprotocol\":3\n}'\n```\n\nThis command defines a new currency called \"MyUSDC\" with the specified properties.\n\n**Step 2: Launch the Currency**\nAfter defining the currency, you need to launch it on the network. To do this, you need to take the HEX returned by the `definecurrency` command and use it with the `sendrawtransaction` command. For example:\n\n``` json\n./verus -chain=VRSCTEST sendrawtransaction \"HEX\"\n```\n\nThis command launches the currency on the network.\n\n**Step 3: Wait for Confirmation**\nAfter launching the currency, you need to wait for a few blocks to be confirmed on the network. This allows the currency to be fully available on the network.\n\n**Step 4: Export to Ethereum (Optional)**\nFinally, if you want to make the currency available on Ethereum as well, you need to export it. This involves additional steps, which are explained in more detail in a separate guide.\n\nBy following these steps, you can define and launch a new currency on the Verus network, and optionally export it to Ethereum.", "``` json\n./verus -chain=VRSCTEST definecurrency '{\n  \"name\":\"MyUSDC\", \n  \"options\":32, \n  \"systemid\":\"veth\", \n  \"parent\":\"vrsctest\", \n  \"launchsystemid\":\"vrsctest\", \n  \"nativecurrencyid\":{\n    \"type\":9, \n    \"address\":\"0x98339D8C260052B7ad81c28c16C0b98420f2B46a\"\n  }, \n  \"initialsupply\":0, \n  \"proofprotocol\":3\n}'\n```\n\nAfter we put in the command, we get returned a HEX. We use this HEX to launch the currency on the network. Use the command below to launch the currency:\n\n``` json\n./verus -chain=VRSCTEST sendrawtransaction \"HEX\"\n```\n\nNow we have to wait a few blocks for the currency to be available on the network.\n\n### Export to Ethereum\nThe last step is to export the currency to Ethereum so we can see it there too. [\ud83d\udc49 Read it here](/currencies/export-to-eth/)", "./raw_text_input_docs/mapping-1:1-eth.md"]]], [["User:: I need some help with claiming refunds on the Verus-Ethereum Bridge. Could you walk me through the process, and explain the steps for both Ethereum to Ethereum and Verus to Ethereum transactions?", "AI Assistant:: Claiming refunds on the Verus-Ethereum Bridge can be a bit tricky, but don't worry, I'm here to guide you through it.\n\nClaiming refunds on the Verus-Ethereum Bridge is a process that involves importing your Ethereum private key into a Verus wallet. Here's a step-by-step guide on how to claim refunds for both Ethereum to Ethereum and Verus to Ethereum transactions.\n\n**Ethereum to Ethereum Transactions:**\nWhen using the Bridge website for Ethereum to Ethereum transactions, you sign a message that creates a refund address based on your Ethereum wallet's private key. To claim refunds, follow these steps:\n\n**Using Verus Mobile:**\n\n1. Export your Ethereum private key from the wallet you used for the conversion (e.g., MetaMask).\n2. Download and install Verus Mobile from the Play Store or App Store.\n3. Add a new profile, choosing a username and password.\n4. Import the Ethereum private key by selecting \"Enter key/seed\" and entering the private key.\n5. Add the currency you want to get back by clicking the plus-button corner-right and selecting \"Add PBaaS currency\".\n\n**Using Verus Desktop:**\n\n1. Make sure you're running native mode (full node) Verus Desktop.\n2. Go to Settings (gear-icon top right), then Coin Settings, and select the Verus blockchain.\n3. Type the following command: `run importprivkey \"ETH_PRIVATE_KEY\" \"\" true`\n4. Note that Verus Desktop will not show any progress on the import, and it will take some time for the process to finish in the background.\n\n**Verus to Ethereum Transactions:**\nFor Verus to Ethereum transactions, you need to use the refund address you filled in on the Bridge website. Simply go to the Bridge website and use that refund address to claim the funds back.\n\nIn both cases, it's essential to have your Ethereum private key to claim refunds on the Verus-Ethereum Bridge. By following these steps, you can successfully claim your refunds and get back any excess funds.\n\nDo you have any further questions about claiming refunds on the Verus-Ethereum Bridge, or need more clarification on any of these steps?"], "AI Assistant", "", "N/A", [["How do I claim refunds on the Verus-Ethereum Bridge, and what are the steps to follow for both Ethereum to Ethereum and Verus to Ethereum transactions?", "Claiming refunds on the Verus-Ethereum Bridge is a process that involves importing your Ethereum private key into a Verus wallet. Here's a step-by-step guide on how to claim refunds for both Ethereum to Ethereum and Verus to Ethereum transactions.\n\n**Ethereum to Ethereum Transactions:**\nWhen using the Bridge website for Ethereum to Ethereum transactions, you sign a message that creates a refund address based on your Ethereum wallet's private key. To claim refunds, follow these steps:\n\n**Using Verus Mobile:**\n\n1. Export your Ethereum private key from the wallet you used for the conversion (e.g., MetaMask).\n2. Download and install Verus Mobile from the Play Store or App Store.\n3. Add a new profile, choosing a username and password.\n4. Import the Ethereum private key by selecting \"Enter key/seed\" and entering the private key.\n5. Add the currency you want to get back by clicking the plus-button corner-right and selecting \"Add PBaaS currency\".\n\n**Using Verus Desktop:**\n\n1. Make sure you're running native mode (full node) Verus Desktop.\n2. Go to Settings (gear-icon top right), then Coin Settings, and select the Verus blockchain.\n3. Type the following command: `run importprivkey \"ETH_PRIVATE_KEY\" \"\" true`\n4. Note that Verus Desktop will not show any progress on the import, and it will take some time for the process to finish in the background.\n\n**Verus to Ethereum Transactions:**\nFor Verus to Ethereum transactions, you need to use the refund address you filled in on the Bridge website. Simply go to the Bridge website and use that refund address to claim the funds back.\n\nIn both cases, it's essential to have your Ethereum private key to claim refunds on the Verus-Ethereum Bridge. By following these steps, you can successfully claim your refunds and get back any excess funds.", "# Claim refunds on the Verus-Ethereum Bridge\nCrossing the bridge costs Ethereum gas fees. Gas fees can swing in price quite dramatically in a short period of time. It can happen that when you pay for a bridge crossing the gas fees jumped up higher than what you paid for the crossing, resulting in a refund. Learn here how you can claim your refunds back.\n\n## Ethereum to Ethereum\nWhen using the Bridge website and making a conversion that goes from Ethereum to Verus and back to Ethereum, you have signed a message that created a refund address based on your Ethereum wallet's private key.\n\nThese are the steps to claim refunds when you did an Ethereum to Ethereum transaction:\n\n### Verus Mobile\n1. Export your Ethereum private key from the wallet you did the conversion with (probably MetaMask)\n2. Import that private key into a Verus wallet. The easiest way to do that is with Verus Mobile. \n- Download Verus Mobile on the Play Store or App Store\n- Add a new profile (choose username and password)\n- Choose \"import wallet\"\n- Choose \"Enter key/seed\"\n- Enter the Ethereum private key here\n- Add the currency you want to get back (click the plus-button corner-right, \"Add PBaaS currency\" and choose the one for you)\n\n### Verus Desktop\nIf you are running native mode (full node) Verus Desktop then you can import the Ethereum's private key in this way:\n\nGo to ``Settings (gear-icon top right)``, then ``Coin Settings``, then select the Verus blockchain and type the following:\n\n```json\nrun importprivkey \"ETH_PRIVATE_KEY\" \"\" true\n```\n\n::: warning Important!\nVerus Desktop will not show any progress on the import. It will take some time for the process to finish in the background.\n:::\n\n## Verus to Ethereum\nWhen bridging with Verus Desktop from the Verus blockchain to the Ethereum blockchain you had to fill in a refund address.\n\nOn the Bridge website you can use that refund address to claim the funds back.", "./raw_text_input_docs/refunds.md"]]], [["User:: Hi there! I'm still getting to grips with the Verus ecosystem. Can you tell me more about VerusIDs? What makes them unique and powerful assets on the Verus blockchain?", "AI Assistant:: VerusIDs are a fascinating aspect of the Verus ecosystem, and I'd be happy to explain them in more detail.\n\nVerusIDs are digital identities that can be bound to various things, such as individuals, other VerusIDs, content, data, and provable information. They can hold funds, serve as personal profiles, corporate websites, or government portals, and are owned assets on the Verus blockchain. VerusIDs offer a range of features, including revocation and recovery, time locks, and control by multiple identities. They also enable private communication through z-addresses and message sending and receiving. Additionally, VerusIDs support standardized communication through the Verus Data Exchange Format (VDXF).\n\nOne of the most significant aspects of VerusIDs is their role in creating PBaaS-chains, tokens, and currencies on the Verus blockchain. A VerusID is required to create these assets, and the name assigned to the VerusID becomes the name of the PBaaS-chain, token, or currency. Each PBaaS-chain has standard VerusID support, and creators can set the costs of identities, which are paid in the native coin of the PBaaS-chain.\n\nVerusIDs also offer a unique feature called \"Friendly Names,\" which allows users to choose an easy-to-remember name for their VerusID. This makes it simpler to send and receive funds. Furthermore, VerusIDs support worldwide adoption by allowing the use of all characters from all character sets, with a few exceptions.\n\nOverall, VerusIDs are premium assets on the Verus blockchain, offering a range of features and capabilities that make them powerful and versatile tools for individuals and organizations alike.\n\nDo you have any more questions about VerusIDs, or would you like to know more about a specific feature or capability?"], "AI Assistant", "", "N/A", [["What are VerusIDs, and what makes them unique and powerful assets on the Verus blockchain?", "VerusIDs are digital identities that can be bound to various things, such as individuals, other VerusIDs, content, data, and provable information. They can hold funds, serve as personal profiles, corporate websites, or government portals, and are owned assets on the Verus blockchain. VerusIDs offer a range of features, including revocation and recovery, time locks, and control by multiple identities. They also enable private communication through z-addresses and message sending and receiving. Additionally, VerusIDs support standardized communication through the Verus Data Exchange Format (VDXF).\n\nOne of the most significant aspects of VerusIDs is their role in creating PBaaS-chains, tokens, and currencies on the Verus blockchain. A VerusID is required to create these assets, and the name assigned to the VerusID becomes the name of the PBaaS-chain, token, or currency. Each PBaaS-chain has standard VerusID support, and creators can set the costs of identities, which are paid in the native coin of the PBaaS-chain.\n\nVerusIDs also offer a unique feature called \"Friendly Names,\" which allows users to choose an easy-to-remember name for their VerusID. This makes it simpler to send and receive funds. Furthermore, VerusIDs support worldwide adoption by allowing the use of all characters from all character sets, with a few exceptions.\n\nOverall, VerusIDs are premium assets on the Verus blockchain, offering a range of features and capabilities that make them powerful and versatile tools for individuals and organizations alike.", "VerusIDs can be anything you want. They can be bound digitally to many things. They can be bound to you, or other VerusIDs they have authority or ownership of. They can be bound to an unlimited amount of content, data, and provable information, both public and private. Including provable contracts and rights that can be bound to ownership of the VerusID itself.VerusIDs can hold funds. They can be personal profiles, corporate websites, or government portals. VerusIDs are much more than identities or today's NFTs. They are owned assets of all kinds on the Verus blockchain.A VerusID can be revoked and recovered, set (time)locks and can be controlled by any number of identities. Sign and verify data, files and messages. VerusID has privacy through added z-addresses and can send and receive messages. Identities can communicate in standardized ways through the novel [Verus Data Exchange Format (VDXF)](/vdxf/README).## Real Estate\nA VerusID is **premium** real estate on the Verus blockchain. To create PBaaS-chains, tokens and currencies on the Verus blockchain, a VerusID is necessary. The name you assign to the VerusID is also the name of the PBaaS-chain, token or currency.Each PBaaS-chain has standard VerusID support and creators of these chains can assign the costs of identites themselves. The costs will then be paid in the native coin of the PBaaS-chain.## Friendly Name\nEach VerusID can have an easy to remember name, chosen by the user. It has never been easier to send and receive funds.::: tip Supporting Worldwide Adoption\nAll characters from **all character sets** (except ``/`` ``:`` ``*`` ``?`` ``\"`` ``<`` ``>`` ``|`` ``@`` ``.`` ) are available to create a VerusID.\n:::", "./raw_text_input_docs/README_addresses.md"]]], [["User:: Hey, I'm staking with funds on a VerusID that's locked with Vault, and I want to divert my staking rewards to a different wallet using Verus Desktop. Can you walk me through the process?", "AI Assistant:: I'd be happy to help. To divert your staking rewards to a different wallet using Verus Desktop, you'll need to follow a few steps. This process involves setting up two devices: a staking device and a hot wallet device.\n\nLet me break it down for you:\n\n**Step 1: Set up your hot wallet device**\nOn your hot wallet device, open Verus Desktop and go to the \"Wallet\" tab. Click \"Receive\" under Transparent Balance, then click the three dots next to the address you want to use. Click \"Copy public key\" and save the pubkey somewhere, as you'll need it later.\n\n**Step 2: Set up your staking device**\nOn your staking device, open Verus Desktop and go to \"Settings\" (the cogwheel in the top right corner). Select \"Profile Settings\" (default) and click on \"Custom native mode launch options\". Select \"Verus\".\n\n**Step 3: Add launch options**\nIn the launch options field, add the following two lines:\n\n1. `minetolocalwallet=0`\n2. `pubkey=xxx` (replace \"xxx\" with the pubkey from your hot wallet device)\n\nClick \"Add launch option\" after each line, and then click \"Save Changes\". **Don't forget to save your changes!**\n\n**Step 4: Restart Verus Desktop**\nClose Verus Desktop and reopen it. Your staking rewards should now be diverted to your hot wallet device.\n\nBy following these steps, you can successfully divert your staking rewards to a different wallet using Verus Desktop, even if your staking funds are locked with Vault.\n\nDo you have any questions about these steps or need further clarification?"], "AI Assistant", "", "N/A", [["How can I divert my staking rewards to a different wallet using Verus Desktop, if I'm staking with funds on a VerusID that's locked with Vault?", "To divert your staking rewards to a different wallet using Verus Desktop, you'll need to follow a few steps. This process involves setting up two devices: a staking device and a hot wallet device.\n\n**Step 1: Set up your hot wallet device**\nOn your hot wallet device, open Verus Desktop and go to the \"Wallet\" tab. Click \"Receive\" under Transparent Balance, then click the three dots next to the address you want to use. Click \"Copy public key\" and save the pubkey somewhere, as you'll need it later.\n\n**Step 2: Set up your staking device**\nOn your staking device, open Verus Desktop and go to \"Settings\" (the cogwheel in the top right corner). Select \"Profile Settings\" (default) and click on \"Custom native mode launch options\". Select \"Verus\".\n\n**Step 3: Add launch options**\nIn the launch options field, add the following two lines:\n\n1. `minetolocalwallet=0`\n2. `pubkey=xxx` (replace \"xxx\" with the pubkey from your hot wallet device)\n\nClick \"Add launch option\" after each line, and then click \"Save Changes\". **Don't forget to save your changes!**\n\n**Step 4: Restart Verus Desktop**\nClose Verus Desktop and reopen it. Your staking rewards should now be diverted to your hot wallet device.\n\nBy following these steps, you can successfully divert your staking rewards to a different wallet using Verus Desktop, even if your staking funds are locked with Vault.", "# Divert staking rewards to different wallet\n![image-divert](/images/divert-stakes.png)\nIf you are staking with funds on a VerusID, and that VerusID is locked with Vault, yet you want to spend your won stakes, this might be for you. Let's explain how you can divert your won stakes to a different wallet with Verus Desktop.\n\nWe have two devices with two different wallets:\n- Your staking device\n- Your hot wallet device\n\n### Hot wallet\nThe hot wallet is the device you want your stakes to arrive on. On the hot wallet we need to lookup the ``pubkey`` for the address you want your won stakes to arrive.\n\nGo to the ``Wallet-tab``, click ``receive`` under Transparent Balance. Then click the three-dots next to the address you want to use. Click ``Copy public key`` as seen in the image below. Paste and save this somewhere, we will need it later.\n\n![image-pubkey](/images/copy-pubkey.png)\n\n### Staking device\nThis device is staking happily, and your funds are secured with the Vault ([read here how to set up](/guides/setup-vault/)). Let's make sure your won stakes are sent to your hot wallet device.\n\nGo to ``settings`` (the cogwheel top right corner), then select ``Profile Settings`` (default). Here you see the option ``Custom native mode launch options``. Select ``Verus``.\n\nFirst copy and paste the code from below into the textfield and click ``Add launch option``.\n\n```\nminetolocalwallet=0\n```\n\nNext, copy and paste the code below. Change ``xxx`` to the ``public key`` we have from the hot wallet. Click ``Add launch option``.\n```\npubkey=xxx\n```\n\nAt last, click the ``Save Changes`` button. **Don't forget this step!** Now close the wallet and open it again. Congratulations, your stakes will now be diverted to your hot wallet.", "./raw_text_input_docs/divert-rewards.md"]]], [["User:: I'm interested in getting started with Verus, but I'm not sure where to begin. What are some available guides for using Verus, and what topics do they cover?", "AI Assistant:: There are several guides available to help you get started with Verus and make the most of the platform. Here are some of the guides available:\n\n**1. Setting up Verus-cli for beginners:** This guide is designed for new users who want to set up the Verus command-line interface (CLI) from scratch. It takes you through the step-by-step process of installing and configuring the CLI, so you can start using Verus right away.\n\n**2. Setting up Verus Vault (flags) and (easy):** Verus Vault is a secure and convenient way to manage your Verus assets. There are two guides available for setting up Verus Vault: one for advanced users who want to use flags, and another for beginners who want a simpler, more user-friendly experience.\n\n**3. Diverting staking rewards to different wallet:** If you're staking Verus coins, you can earn rewards. This guide shows you how to divert those rewards to a different wallet, giving you more control over your assets.\n\n**4. Claiming refunds from Verus-Ethereum Bridge:** The Verus-Ethereum Bridge allows you to move assets between the Verus and Ethereum networks. This guide explains how to claim refunds from the bridge, in case you need to recover funds.\n\n**5. Getting a Verus address:** Finally, there's a guide on how to get a Verus address, which is essential for receiving and managing Verus coins.\n\nThese guides are designed to be easy to follow and provide step-by-step instructions for using Verus. They're a great resource for anyone who wants to get started with the platform or learn more about its features and capabilities.\n\nHave you found the guide that best suits your needs? Do you have any further questions about getting started with Verus or using these guides?"], "AI Assistant", "", "N/A", [["What are some available guides for using Verus, and what topics do they cover?", "There are several guides available for using Verus, covering a range of topics to help users get started and make the most of the platform. Here are some of the guides available:\n\n**1. Setting up Verus-cli for beginners:** This guide is designed for new users who want to set up the Verus command-line interface (CLI) from scratch. It takes you through the step-by-step process of installing and configuring the CLI, so you can start using Verus right away.\n\n**2. Setting up Verus Vault (flags) and (easy):** Verus Vault is a secure and convenient way to manage your Verus assets. There are two guides available for setting up Verus Vault: one for advanced users who want to use flags, and another for beginners who want a simpler, more user-friendly experience.\n\n**3. Diverting staking rewards to different wallet:** If you're staking Verus coins, you can earn rewards. This guide shows you how to divert those rewards to a different wallet, giving you more control over your assets.\n\n**4. Claiming refunds from Verus-Ethereum Bridge:** The Verus-Ethereum Bridge allows you to move assets between the Verus and Ethereum networks. This guide explains how to claim refunds from the bridge, in case you need to recover funds.\n\n**5. Getting a Verus address:** Finally, there's a guide on how to get a Verus address, which is essential for receiving and managing Verus coins.\n\nThese guides are designed to be easy to follow and provide step-by-step instructions for using Verus. They're a great resource for anyone who wants to get started with the platform or learn more about its features and capabilities.", "# Overview\n\n| Guides | \n| :----------------------- |\n| [Set up verus-cli for beginners](/guides/setup-cli/) | \n| [Set up Verus Vault (flags)](/guides/setup-vault/) | \n| [Set up Verus Vault (easy)](/guides/setup-vault-v2/) | \n| [Divert staking rewards to different wallet](/guides/divert-rewards/)   |\n| [Claim refunds from Verus-Ethereum Bridge](/guides/refunds/) |\n| [Get Verus address](/guides/getwallet/)", "./raw_text_input_docs/README_guides.md"]]], [["User:: Hi, I'm trying to understand how to define a currency on the Verus network. Can you explain the key components of defining a currency, and how subID referrals and registration fees work in a currency definition?", "AI Assistant:: Defining a currency on the Verus network is a straightforward process, and I'd be happy to walk you through it.\n\nDefining a currency on the Verus network involves specifying several key components, including the currency's name, options, currencies, initial contributions, initial supply, and ID registration fees. Additionally, a currency can have subID referrals enabled, which allows for the distribution of subID registration fees to multiple levels of referrals.\n\nLet's break down each of these components. The `options` parameter in a currency definition determines the behavior of the currency. For example, setting `options` to 8 enables referrals, while setting `options` to 40 or 41 defines a centralized simple token currency or a basket currency, respectively.\n\nThe `idregistrationfees` parameter specifies the fee required to register a subID, and this fee can be distributed to multiple levels of referrals using the `idreferrallevels` parameter. The `idreferrallevels` parameter determines the number of levels of referrals that can receive a portion of the subID registration fee, with a minimum of 0 levels and a maximum of 5 levels.\n\nWhen a currency is launched, the initial supply of the currency is distributed to the rootID, and any preconverters may also receive a portion of the initial supply. The currency owner can also specify preallocations, which allow for the distribution of a certain amount of the currency to specific VerusIDs at launch.\n\nIn a currency with referrals enabled, when a subID is registered using a referral, the registration fee is distributed to the referred subID and the rootID. The specific distribution of the fee depends on the `idreferrallevels` parameter and the currency's definition.\n\nOverall, defining a currency on the Verus network involves specifying a range of parameters that determine the behavior and properties of the currency, including its supply, distribution, and referral structure.\n\nDo you have any further questions about defining a currency on the Verus network, or how subID referrals and registration fees work?"], "AI Assistant", "", "N/A", [["What are the key components of defining a currency on the Verus network, and how do subID referrals and registration fees work in a currency definition?", "Defining a currency on the Verus network involves specifying several key components, including the currency's name, options, currencies, initial contributions, initial supply, and ID registration fees. Additionally, a currency can have subID referrals enabled, which allows for the distribution of subID registration fees to multiple levels of referrals.\n\nThe `options` parameter in a currency definition determines the behavior of the currency. For example, setting `options` to 8 enables referrals, while setting `options` to 40 or 41 defines a centralized simple token currency or a basket currency, respectively.\n\nThe `idregistrationfees` parameter specifies the fee required to register a subID, and this fee can be distributed to multiple levels of referrals using the `idreferrallevels` parameter. The `idreferrallevels` parameter determines the number of levels of referrals that can receive a portion of the subID registration fee, with a minimum of 0 levels and a maximum of 5 levels.\n\nWhen a currency is launched, the initial supply of the currency is distributed to the rootID, and any preconverters may also receive a portion of the initial supply. The currency owner can also specify preallocations, which allow for the distribution of a certain amount of the currency to specific VerusIDs at launch.\n\nIn a currency with referrals enabled, when a subID is registered using a referral, the registration fee is distributed to the referred subID and the rootID. The specific distribution of the fee depends on the `idreferrallevels` parameter and the currency's definition.\n\nOverall, defining a currency on the Verus network involves specifying a range of parameters that determine the behavior and properties of the currency, including its supply, distribution, and referral structure.", "Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"InternetCommunity\", \n \"options\":41, \n \"currencies\":[\"vrsctest\"],\n \"initialcontributions\":[25],\n \"initialsupply\":5000, \n \"idregistrationfees\":1\n}'\n```\n\u261d\ufe0f The is a basket currency called InternetCommunity with subID referrals enabled. The launcher of the currency wanted to make initial contributions to its reserves. There needs to be 225.0002 VRSCTEST in the rootID at the moment of broadcasting the currency to the network (currency launch fee + initial contributions + txfees). The initial supply of 5000 went to the rootID (if there weren\u2019t any more preconverters). The base fee to register a subID is 1 InternetCommunity.### **\"idreferrallevels\"**\n![image-referralsID](/images/referralsID2.png)\nUse this parameter to change the levels of referrals used when registering subIDs. The image above shows the division and distribution of subID registration fees, depending on the chosen level. Minimum is 0 levels, maximum is 5. The default is `3` levels.To enable referrals, add `\"options\":8` to the currency definition.Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"PremiumAccess\", \n \"options\":40, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Klaus@\":2000}],\n \"idregistrationfees\":300,\n \"idreferrallevels\":1\n}'\n```\n\u261d\ufe0f This is a centralized simple token currency called PremiumAccess. The owner of the rootID can mint and burn tokens at will. It has referrals enabled. When the currency is launched 2000 PremiumAccess go to the Klaus@ VerusID. It costs a 300 PremiumAccess fee to register a subID. These fees go to the rootID because it is a centralized token currency. When someone registers a subID using a referral they pay 200 of which 100 goes to the referred subID, and 100 to the rootID.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I'm curious about how PBaaS chains function within the Verus ecosystem. Can you explain that to me, and what DeFi capabilities they offer?", "AI Assistant:: PBaaS chains are a crucial part of the Verus ecosystem, and they offer several benefits to projects that join the Verus community. Let me break it down for you.\n\n**PBaaS Chains:**\nAll PBaaS chains run from the same Verus daemon, which means that projects can join the Verus community and contribute to the development of the daemon. This, in turn, provides them with a complete, multi-currency, VerusID-capable blockchain that offers DeFi capabilities. The blockchain is merge-mineable and stakeable with other blockchains in the Verus network, allowing for seamless connectivity and interaction between different chains.\n\n**DeFi Capabilities:**\nOne of the key DeFi capabilities offered by PBaaS chains is the ability to define basket currencies. Any VerusID owner can create a basket currency with one or more reserves backing it, with a fractional percentage ranging from 5% to 100% backing. This allows for the creation of complex, asset-backed currencies that can be used for various purposes.\n\nThe Verus DeFi protocol ensures that all currency conversions using a particular basket currency, and mined into one block, are solved and priced simultaneously. This addresses the problems of miner extracted value (MEV) and front-running, while providing fee-based DeFi integrated incentives to miners and stakers. This, in turn, ensures smooth consensus operation and fee conversion capabilities by integrating DeFi basket currencies directly into the consensus and cross-chain bridge protocols.\n\n**Bridge Converter Launches:**\nAnother DeFi capability offered by PBaaS chains is the launch of bridge converter liquidity pools. These pools allow for the creation of a world-class, worldwide, merge-mineable blockchain, along with a fully decentralized or centralized bridge converter. The bridge converter currencies have the same flexibility as other 100% asset-backed or partially asset-backed basket currencies, but are bound to the launch of the new blockchain. They run on the new blockchain, and all fees generated via cross-chain fee conversions or general use of the liquidity pool are earned on the new blockchain, with no rent going back to the Verus blockchain. This provides seamless connectivity and allows projects to benefit from the Verus ecosystem while maintaining control over their own blockchain.\n\nDo you have any further questions about PBaaS chains or their DeFi capabilities within the Verus ecosystem?"], "AI Assistant", "", "N/A", [["How do PBaaS chains function within the Verus ecosystem, and what DeFi capabilities do they offer?", "PBaaS chains are an integral part of the Verus ecosystem, and they offer several benefits to projects that join the Verus community. Here's how they work:\n\n**PBaaS Chains:**\nAll PBaaS chains run from the same Verus daemon, which means that projects can join the Verus community and contribute to the development of the daemon. This, in turn, provides them with a complete, multi-currency, VerusID-capable blockchain that offers DeFi capabilities. The blockchain is merge-mineable and stakeable with other blockchains in the Verus network, allowing for seamless connectivity and interaction between different chains.\n\n**DeFi Capabilities:**\nOne of the key DeFi capabilities offered by PBaaS chains is the ability to define basket currencies. Any VerusID owner can create a basket currency with one or more reserves backing it, with a fractional percentage ranging from 5% to 100% backing. This allows for the creation of complex, asset-backed currencies that can be used for various purposes.\n\nThe Verus DeFi protocol ensures that all currency conversions using a particular basket currency, and mined into one block, are solved and priced simultaneously. This addresses the problems of miner extracted value (MEV) and front-running, while providing fee-based DeFi integrated incentives to miners and stakers. This, in turn, ensures smooth consensus operation and fee conversion capabilities by integrating DeFi basket currencies directly into the consensus and cross-chain bridge protocols.\n\n**Bridge Converter Launches:**\nAnother DeFi capability offered by PBaaS chains is the launch of bridge converter liquidity pools. These pools allow for the creation of a world-class, worldwide, merge-mineable blockchain, along with a fully decentralized or centralized bridge converter. The bridge converter currencies have the same flexibility as other 100% asset-backed or partially asset-backed basket currencies, but are bound to the launch of the new blockchain. They run on the new blockchain, and all fees generated via cross-chain fee conversions or general use of the liquidity pool are earned on the new blockchain, with no rent going back to the Verus blockchain. This provides seamless connectivity and allows projects to benefit from the Verus ecosystem while maintaining control over their own blockchain.\n\nOverall, PBaaS chains within the Verus ecosystem offer a range of DeFi capabilities that enable projects to create complex, asset-backed currencies, and launch their own blockchains with seamless connectivity to the Verus network.", "All PBaaS chains run from the same daemon, and projects may choose to join the worldwide Verus community in improving the daemon. In doing so, they will start with a complete, multi-currency, VerusID-capable blockchain with DeFi capabilities that is merge-mineable and stakeable with other blockchains in the Verus network.## DeFi liquidity pools and fractional currency baskets\nAny VerusID owner may define basket currencies, with one or more reserves backing the currency, at a fractional percentage ranging from 5% to 100% backing.The Verus DeFi protocol ensures that all currency conversions that use a particular basket currency, and are mined into one block are solved and priced simultaneously, addressing the problems of miner extracted value (MEV) and front-running, while providing fee-based DeFi integrated incentives to miners and stakers, ensuring smooth consensus operation and fee conversion capabilities by integrating DeFi basket currencies directly into the consensus and cross-chain bridge protocols.## Bridge converter launches\nLaunch of a world class, worldwide, merge-mineable blockchain along with a fully decentralized or centralized \u201cbridge\u201d converter liquidity pool as part of defining a new blockchain.Bridge converter currencies have the same flexibility as other 100% asset backed or partially asset backed basket currencies, but is bound to the launch of the new blockchain, runs on the new blockchain, and all fees generated via cross-chain fee conversions or general use of the liquidity pool are earned on the new blockchain with no rent going back to the Verus blockchain, only seamless connectivity.", "./raw_text_input_docs/README_blockchains.md"]]], [["User:: Hi, I'm trying to understand how to define a currency in Verus. Can you explain the different options and parameters available, and how they affect the behavior and characteristics of the currency?", "AI Assistant:: Defining a currency in Verus can be a bit complex, but I'm happy to break it down for you.\n\nWhen defining a currency in Verus, there are several options and parameters that can be specified to customize the behavior and characteristics of the currency. These options and parameters can be combined in various ways to achieve the desired outcome.\n\nLet's start with the options. The options available when defining a currency in Verus include:\n\n* Option 1: The currency has reserves and can be converted to and from the reserves. This is a \"Basket currency\" that can be launched centralized or decentralized.\n* Option 2: Only the controlling VerusID (the namespace of the currency, the rootID) can create subIDs.\n* Option 8: Referrals and discounts are enabled for subID creation.\n* Option 16: Referrals are required for subID creation.\n* Option 32: The currency is a simple token currency without any reserves. This option is also used for Ethereum ERC-20 mapped tokens.\n* Option 2048: A single satoshi (0.00000001) NFT token is created and has tokenized control of the root VerusID.\n\nThese options can be combined in various ways to achieve the desired outcome. For example, `\"options\":33` launches a basket currency with reserves, while `\"options\":2080` launches a single satoshi token that has control of the root VerusID.\n\nIn addition to options, there are also parameters that can be specified when defining a currency in Verus. One of the most important parameters is the `\"proofprotocol\"` parameter, which defines whether the currency is centralized or decentralized. This parameter can take on values of 1, 2, or 3.\n\nThe `\"proofprotocol\"` parameter is just one example of the many parameters that can be specified when defining a currency in Verus. The specific parameters available and their effects on the currency will depend on the options chosen and the desired behavior of the currency.\n\nOverall, the options and parameters available in Verus provide a high degree of flexibility and customization when defining a currency, allowing users to create currencies that meet their specific needs and requirements.\n\nDo you have any further questions about defining a currency in Verus, or would you like more information on a specific option or parameter?"], "AI Assistant", "", "N/A", [["What are the different options and parameters available when defining a currency in Verus, and how do they affect the behavior and characteristics of the currency?", "When defining a currency in Verus, there are several options and parameters that can be specified to customize the behavior and characteristics of the currency. These options and parameters can be combined in various ways to achieve the desired outcome.\n\n**Options:**\nThe options available when defining a currency in Verus include:\n\n* Option 1: The currency has reserves and can be converted to and from the reserves. This is a \"Basket currency\" that can be launched centralized or decentralized.\n* Option 2: Only the controlling VerusID (the namespace of the currency, the rootID) can create subIDs.\n* Option 8: Referrals and discounts are enabled for subID creation.\n* Option 16: Referrals are required for subID creation.\n* Option 32: The currency is a simple token currency without any reserves. This option is also used for Ethereum ERC-20 mapped tokens.\n* Option 2048: A single satoshi (0.00000001) NFT token is created and has tokenized control of the root VerusID.\n\nThese options can be combined in various ways to achieve the desired outcome. For example, `\"options\":33` launches a basket currency with reserves, while `\"options\":2080` launches a single satoshi token that has control of the root VerusID.\n\n**Parameters:**\nIn addition to options, there are also parameters that can be specified when defining a currency in Verus. One of the most important parameters is the `\"proofprotocol\"` parameter, which defines whether the currency is centralized or decentralized. This parameter can take on values of 1, 2, or 3.\n\nThe `\"proofprotocol\"` parameter is just one example of the many parameters that can be specified when defining a currency in Verus. The specific parameters available and their effects on the currency will depend on the options chosen and the desired behavior of the currency.\n\nOverall, the options and parameters available in Verus provide a high degree of flexibility and customization when defining a currency, allowing users to create currencies that meet their specific needs and requirements.", "| Options # | Details |\n| -: |:-----|\n| 1 | The currency has reserves, and can be converted to and from the reserves (option 32 needs to be added). Can have one currency as its reserves, or multiple with up to 10 currencies. This is a \u201cBasket currency\u201d \u2014 a currency with a basket of reserves. Such a currency can be launched centralized or decentralized. |\n| 2 | Only the controlling VerusID (the namespace of the currency, the rootID) can create subIDs. |\n| 8 | Referrals and discounts are enabled for subID creation. |\n| 16 | Referrals are required for subID creation. |\n| 32 | The currency is a simple token currency without any reserves. Such a currency can be launched centralized or decentralized. This option is also used for [Ethereum ERC-20 mapped tokens](/currencies/mapping-1:1-eth). |\n| 2048 | A single satoshi (0.00000001) NFT token is created & has tokenized control of the root VerusID. Which means you can send the single satoshi token to other addresses and then they have control of the root VerusID. |Let\u2019s give some examples of combined options:\n- ``\"options\":33`` \u2014 this launches a basket currency. It is options 1 + 32 combined.\n- ``\"options\":2080`` \u2014 this launches a single satoshi token that has control of the root VerusID. It is options 32 + 2048 combined.\n- ``\"options\":35`` \u2014 this launches a basket currency, and only the rootID can create subIDs. It is options 1 + 2 + 32 combined.## Defining parameters\nNext up are the parameters. Choose the parameters wisely to launch a currency that suits any need. Not all parameters are needed or combinable. There are many to go through, so let\u2019s start.### **\"proofprotocol\"**\nThis parameter defines, among others, if the currency is centralized or decentralized. You can choose 1,2 or 3.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: Hi, I'm trying to launch a currency with a 1-to-1 mapping of an ERC-20, and I need some guidance on how to register a.vETH subID. Can you walk me through the process and provide the contract addresses involved?", "AI Assistant:: Registering a.vETH subID and launching a currency with a 1-to-1 mapping of an ERC-20 is a bit of a process, but I'd be happy to guide you through it.\n\nTo register a.vETH subID and launch a currency with a 1-to-1 mapping of an ERC-20, you need to follow these steps:\n\n**Step 1: Register a VerusID/subID**\nFirst, you need to register a VerusID/subID. This can be done by following the instructions in the VerusID creation guide.\n\n**Step 2: Pay the registration fee**\nThe cost of registering a.vETH subID is 0.01 vETH worth of Bridge.vETH. This fee needs to be paid in order to complete the registration process.\n\nNow, let's talk about the contract addresses involved in this process. There are three important ones to keep in mind:\n\n1. **Verus-Ethereum Bridge smart contract mainnet**: This is the contract address for the Verus-Ethereum Bridge smart contract on the mainnet. The address is 0x71518580f36FeCEFfE0721F06bA4703218cD7F63.\n2. **VRSC token address**: This is the contract address for the VRSC token. The address is 0xBc2738BA63882891094C99e59a02141Ca1a1C36a.\n3. **Bridge.vETH token address**: This is the contract address for the Bridge.vETH token. The address is 0xE6052Dcc60573561ECef2D9A4C0FEA6d3aC5B9A2.\n\nThese contract addresses are essential for the registration process and for interacting with the Verus-Ethereum Bridge.\n\nDo you have any further questions about the registration process or the contract addresses involved?"], "AI Assistant", "", "N/A", [["How do I register a.vETH subID to launch a currency with a 1-to-1 mapping of an ERC-20, and what are the contract addresses involved in this process?", "To register a.vETH subID and launch a currency with a 1-to-1 mapping of an ERC-20, you need to follow these steps:\n\n**Step 1: Register a VerusID/subID**\nFirst, you need to register a VerusID/subID. This can be done by following the instructions in the VerusID creation guide.\n\n**Step 2: Pay the registration fee**\nThe cost of registering a.vETH subID is 0.01 vETH worth of Bridge.vETH. This fee needs to be paid in order to complete the registration process.\n\n**Contract Addresses**\nThere are three important contract addresses involved in this process:\n\n1. **Verus-Ethereum Bridge smart contract mainnet**: This is the contract address for the Verus-Ethereum Bridge smart contract on the mainnet. The address is 0x71518580f36FeCEFfE0721F06bA4703218cD7F63.\n2. **VRSC token address**: This is the contract address for the VRSC token. The address is 0xBc2738BA63882891094C99e59a02141Ca1a1C36a.\n3. **Bridge.vETH token address**: This is the contract address for the Bridge.vETH token. The address is 0xE6052Dcc60573561ECef2D9A4C0FEA6d3aC5B9A2.\n\nThese contract addresses are essential for the registration process and for interacting with the Verus-Ethereum Bridge.", "## .vETH subID\nRegister a .vETH subID to launch a currency with a 1-to-1 mapping of an ERC-20. The cost is 0.01 vETH worth of Bridge.vETH.\n\n[Learn here how to register a VerusID / subID.](/verusid/verusid-create/)\n\n## Contract addresses\n\n| What       |     Contract address      |\n| :------------------ | :----------------------------------------- |\n| Verus-Ethereum Bridge smart contract **mainnet**| [0x71518580f36FeCEFfE0721F06bA4703218cD7F63](https://etherscan.io/address/0x71518580f36FeCEFfE0721F06bA4703218cD7F63) |\n| **VRSC** token address| [0xBc2738BA63882891094C99E59a02141Ca1A1C36a](https://etherscan.io/token/0xbc2738ba63882891094c99e59a02141ca1a1c36a) |\n| **Bridge.vETH** token address| [0xE6052Dcc60573561ECef2D9A4C0FEA6d3aC5B9A2](https://etherscan.io/token/0xE6052Dcc60573561ECef2D9A4C0FEA6d3aC5B9A2) |", "./raw_text_input_docs/README_eth-bridge.md"]]], [["User:: I'm trying to understand the Verus ecosystem a bit better. Can you explain how the fee pool mechanism works, and what its impact is on mining and staking?", "AI Assistant:: The fee pool mechanism is a crucial component of the Verus ecosystem, and it plays a significant role in incentivizing mining and staking activities.\n\nIn the Verus ecosystem, a mechanism called the \"fee pool\" collects all the fees generated by the protocol. These fees are accumulated from various transactions and activities within the Verus network. With each new block that is added to the blockchain, a percentage of the fee pool is distributed as an additional reward to miners and stakers.\n\nSpecifically, 1% of the fee pool is added on top of the block rewards, which are the standard rewards given to miners and stakers for validating transactions and creating new blocks. This means that the total reward for mining and staking a block is comprised of two components: the block reward and the fee pool reward.\n\nThe fee pool mechanism is designed to create a competitive and profitable environment for miners and stakers. By adding a portion of the fee pool to the block rewards, Verus incentivizes participants to contribute to the network's security and validation process. This, in turn, helps to increase the overall health and stability of the network.\n\nThe expectation is that fees will eventually outnumber block rewards, making mining and staking in the Verus ecosystem a lucrative endeavor. This will attract more participants to the network, which will further increase the security and decentralization of the Verus ecosystem.\n\nIn summary, the fee pool mechanism is a key component of the Verus ecosystem, as it provides an additional incentive for miners and stakers to participate in the network. By distributing a portion of the fee pool as rewards, Verus creates a competitive and profitable environment that benefits both participants and the network as a whole.\n\nDo you have any further questions about the fee pool mechanism or its impact on mining and staking in Verus?"], "AI Assistant", "", "N/A", [["How does the fee pool mechanism work in the Verus ecosystem, and what is its impact on mining and staking?", "In the Verus ecosystem, a mechanism called the \"fee pool\" plays a crucial role in incentivizing mining and staking activities. Here's how it works:\n\nThe fee pool is a collection of all the fees generated by the protocol. These fees are accumulated from various transactions and activities within the Verus network. With each new block that is added to the blockchain, a percentage of the fee pool is distributed as an additional reward to miners and stakers.\n\nSpecifically, 1% of the fee pool is added on top of the block rewards, which are the standard rewards given to miners and stakers for validating transactions and creating new blocks. This means that the total reward for mining and staking a block is comprised of two components: the block reward and the fee pool reward.\n\nThe fee pool mechanism is designed to create a competitive and profitable environment for miners and stakers. By adding a portion of the fee pool to the block rewards, Verus incentivizes participants to contribute to the network's security and validation process. This, in turn, helps to increase the overall health and stability of the network.\n\nThe expectation is that fees will eventually outnumber block rewards, making mining and staking in the Verus ecosystem a lucrative endeavor. This will attract more participants to the network, which will further increase the security and decentralization of the Verus ecosystem.\n\nIn summary, the fee pool mechanism is a key component of the Verus ecosystem, as it provides an additional incentive for miners and stakers to participate in the network. By distributing a portion of the fee pool as rewards, Verus creates a competitive and profitable environment that benefits both participants and the network as a whole.", "## Fee Pool\nAll the fees generated by the protocol are collected in the ``fee pool``. With each new block, ``1%`` of the fee pool is added on top of the block rewards. It is expected that fees outnumber block rewards, making mining and staking in the Verus ecosystem a profitable and competitive endeavor.", "./raw_text_input_docs/README_economy.md"]]], [["User:: I've been looking into Verus's decentralized currency system, and I'm curious about its benefits and characteristics. Can you explain how conversion fees work, and what makes basket currencies unique?", "AI Assistant:: Verus's decentralized currency system offers several benefits and unique characteristics that set it apart from other systems. Here are some key features:\n\nVerus's decentralized currency system is designed to be fair, transparent, and resistant to manipulation. In a centralized version of the currency, the owner of the rootID has control over minting and burning currencies, which affects the reserve ratio. They can mint new currencies into existence, automatically lowering the reserve ratio, or burn existing currencies, automatically raising the reserve ratio.\n\nNow, let's talk about conversion fees. The conversion fees in Verus are extremely low, at 0.025% when converting to and from a basket currency, and 0.05% when converting from reserve to reserve currency. These fees are distributed equally between the worldwide miners and stakers of the protocol, and the reserves of the basket currency.\n\nThe fee distribution is transparent and fair, with 0.0125% of the fee going to the block reward for miners and stakers, and 0.0125% added to the reserves of the basket currency for reserve-to-basket conversions. For reserve-to-reserve conversions, 0.025% goes to the block reward and 0.025% to the reserves.\n\nOne of the key benefits of Verus's system is that it's MEV-free, meaning it's resistant to front-running, back-running, and sandwich attacks, as all currency conversions are solved simultaneously inside a block, giving all participants the same price.\n\nVerus DeFi is designed to be fair and free from rent-seekers, unlike EVM-like account-based systems. This means that there are no unnecessary intermediaries taking fees or manipulating the system.\n\nNow, about basket currencies - they're unique currencies that can be created on the Verus network, using any currency or token as reserves. This offers an enormous amount of opportunities for value creation, as users can create customized currencies that meet specific needs or use cases.\n\nAny currency or token on the Verus network, including mapped ERC-20s, can be used as reserves for basket currencies. This flexibility and interoperability make Verus's system highly versatile and powerful.\n\nOverall, Verus's decentralized currency system offers a unique combination of low fees, fair distribution of fees, MEV-free conversions, and opportunities for value creation through basket currencies.\n\nDo you have any more questions about Verus's decentralized currency system, or how basket currencies work?"], "AI Assistant", "", "N/A", [["What are the benefits and characteristics of Verus's decentralized currency system, including how conversion fees work, and how basket currencies are unique and offer opportunities for value creation?", "Verus's decentralized currency system offers several benefits and unique characteristics that set it apart from other systems. Here are some key features:\n\n**Centralized Control:** In a centralized version of the currency, the owner of the rootID has control over minting and burning currencies, which affects the reserve ratio. They can mint new currencies into existence, automatically lowering the reserve ratio, or burn existing currencies, automatically raising the reserve ratio.\n\n**Conversion Fees:** The conversion fees in Verus are extremely low, at 0.025% when converting to and from a basket currency, and 0.05% when converting from reserve to reserve currency. These fees are distributed equally between the worldwide miners and stakers of the protocol, and the reserves of the basket currency.\n\n**Fee Distribution:** The fee distribution is transparent and fair, with 0.0125% of the fee going to the block reward for miners and stakers, and 0.0125% added to the reserves of the basket currency for reserve-to-basket conversions. For reserve-to-reserve conversions, 0.025% goes to the block reward and 0.025% to the reserves.\n\n**MEV-Free:** Verus's system is MEV-free, meaning it's resistant to front-running, back-running, and sandwich attacks, as all currency conversions are solved simultaneously inside a block, giving all participants the same price.\n\n**Fair and Rent-Seeker Free:** Verus DeFi is designed to be fair and free from rent-seekers, unlike EVM-like account-based systems. This means that there are no unnecessary intermediaries taking fees or manipulating the system.\n\n**Basket Currencies:** Basket currencies are unique currencies that can be created on the Verus network, using any currency or token as reserves. This offers an enormous amount of opportunities for value creation, as users can create customized currencies that meet specific needs or use cases.\n\n**Reserve Currencies:** Any currency or token on the Verus network, including mapped ERC-20s, can be used as reserves for basket currencies. This flexibility and interoperability make Verus's system highly versatile and powerful.\n\nOverall, Verus's decentralized currency system offers a unique combination of low fees, fair distribution of fees, MEV-free conversions, and opportunities for value creation through basket currencies.", "When a centralized version of this currency is created, the owner of the rootID can mint currencies into existence, while automatically lowering the reserve ratio. Or they can burn currencies and automatically raise the reserve ratio. Anyone can also just burn the currency at will without raising the reserve ratio.The conversion fees are incredibly low, 0.025% when converting to and from a basket currency, and 0.05% when converting from reserve to reserve currency. These fees go directly to the worldwide miners and stakers of the protocol, and/or they are accrued into the reserves making the basket currency worth more.| Conversion type | Fee | Fee goes to |\n| :-----| :------ | :-------- |\n| Basket currency \u2194\ufe0f reserve | 0.025% | 0.0125% added to reserves of the basket currency, 0.0125% to the block reward for miners and stakers | \n| Reserve \u2194\ufe0f reserve | 0.05% | 0.025% added to reserves of the basket currency, 0.025% to the block reward for miners and stakers |Because all currency conversions are solved simultaneously inside a block, giving all participants the same price, the protocol is MEV-free (no front-running, back-running, sandwich attacks etc.). The protocol doesn\u2019t have any of the problems EVM-like account-based systems have. Verus DeFi is fair, cheap and has no rent-seekers.Every(!) currency and token on the Verus network (also mapped ERC-20s!), can be used as reserves for basket currencies. As you might start to understand now \u2014 basket currencies are unique currencies that can not be found anywhere else and offer an enormous amount of opportunities for value creation.", "./raw_text_input_docs/README_currencies.md"]]], [["User:: I'd like to know more about VerusIDs and how they enable advanced identity management and communication capabilities. Can you walk me through some of the key features?", "AI Assistant:: VerusIDs are indeed a fundamental component of the Verus ecosystem, offering a range of innovative features that enable advanced identity management and communication capabilities. Let me break down some of the key features for you.\n\n**Multisig:** VerusIDs support multisignature capabilities, allowing multiple organizations or individuals to jointly manage a single VerusID. This feature enables collaborative management of digital identities, facilitating secure and decentralized decision-making processes.\n\n**Private Messaging:** VerusIDs enable the sending and receiving of completely private messages through the use of private addresses. This feature ensures that communication remains confidential and secure, protected from unwanted access or surveillance.\n\n**SSID Login:** VerusIDs support Single Sign-On (SSID) login capabilities, allowing users to access supported VerusID services without the need for passwords. This feature simplifies the login process, reducing the risk of password-related security breaches.\n\n**SubIDs:** VerusIDs also support the registration of subIDs, which are subsidiary identities that inherit the same features as VerusIDs. SubIDs can be registered under each launched currency and token, enabling the creation of a hierarchical identity structure. While subIDs cannot launch blockchains, currencies, or tokens, they offer a flexible and scalable way to manage digital identities.\n\nIn summary, VerusIDs provide a robust and flexible platform for managing digital identities, enabling advanced features such as multisignature management, private messaging, SSID login, and subID registration. These features collectively empower users to take control of their digital identities, promoting security, privacy, and decentralization in the process.\n\nDo you have any further questions about VerusIDs or their features?"], "AI Assistant", "", "N/A", [["What are some key features of VerusIDs, and how do they enable advanced identity management and communication capabilities?", "VerusIDs are a fundamental component of the Verus ecosystem, offering a range of innovative features that enable advanced identity management and communication capabilities. Some of the key features of VerusIDs include:\n\n**Multisig:** VerusIDs support multisignature capabilities, allowing multiple organizations or individuals to jointly manage a single VerusID. This feature enables collaborative management of digital identities, facilitating secure and decentralized decision-making processes.\n\n**Private Messaging:** VerusIDs enable the sending and receiving of completely private messages through the use of private addresses. This feature ensures that communication remains confidential and secure, protected from unwanted access or surveillance.\n\n**SSID Login:** VerusIDs support Single Sign-On (SSID) login capabilities, allowing users to access supported VerusID services without the need for passwords. This feature simplifies the login process, reducing the risk of password-related security breaches.\n\n**SubIDs:** VerusIDs also support the registration of subIDs, which are subsidiary identities that inherit the same features as VerusIDs. SubIDs can be registered under each launched currency and token, enabling the creation of a hierarchical identity structure. While subIDs cannot launch blockchains, currencies, or tokens, they offer a flexible and scalable way to manage digital identities.\n\nIn summary, VerusIDs provide a robust and flexible platform for managing digital identities, enabling advanced features such as multisignature management, private messaging, SSID login, and subID registration. These features collectively empower users to take control of their digital identities, promoting security, privacy, and decentralization in the process.", "les, hashes and messages. | \n| **Multisig** | Multiple organizations or people can manage a VerusID. | \n| **Messages** | Send and receive completely private messages through VerusID private addresses. | \n| [**SSID login**](/verusid/login/) | Login to supported VerusID services without ever needing a password. |\n| **SubID** | Under each launched currency and token subIDs can be registered. SubIDs have the exact same features as VerusIDs, although they can not launch blockchains, currencies or tokens. |", "./raw_text_input_docs/README_addresses.md"]]], [["User:: I'm trying to understand more about the security features of VerusID. Can you explain the features and functionalities of VerusID, specifically regarding revocation, recovery, and the Verus Vault, and how they enhance security and control over funds?", "AI Assistant:: VerusID offers advanced features to enhance security and control over funds, including revocation, recovery, and the Verus Vault. Let's break down each of these features and how they work:\n\n**Revocation and Recovery:**\nWhen creating a VerusID, users can assign a RevokeID and a RecoveryID to their VerusID. These assigned identities are also VerusIDs and must be purchased. The RevokeID and RecoveryID can be the same identities, different ones, or appointed as \"self\".\n\nWhen a VerusID is revoked, funds cannot be spent anymore. To recover a revoked VerusID, users can recover all assets to a new address, and funds and UTXOs can be spent again. However, it's essential to note that assigning a RecoveryID to \"self\" when the RevokeID is assigned to another identity can lead to a situation where the identity cannot be recovered after revocation.\n\n**Verus Vault:**\nThe Verus Vault is a unique feature that provides an extra layer of security for VerusIDs. It allows users to set locks or timelocks to safeguard funds on a VerusID. Locked identities cannot spend funds, but they can still receive, hold, and stake funds, as well as be used for signing.\n\nThe Verus Vault has three stages:\n\n1. **Locked until x blocks**: Funds cannot be spent until a predetermined number of blocks have passed.\n2. **Locked with delay**: Funds cannot be spent until an unlock has been requested, and a predetermined number of blocks have passed.\n3. **Unlocked**: Funds can be spent.\n\n**Important Notes:**\n\n* Even when a VerusID is locked or timelocked, it can still be revoked and recovered.\n* The Verus Vault does not affect the ability to receive, hold, and stake funds, or use the VerusID for signing.\n\nThe Verus Vault provides an additional layer of security and control over funds, allowing users to set specific conditions for fund accessibility. This feature can be particularly useful in scenarios where users want to ensure that their funds are protected from unauthorized access or unintended spending.\n\nDo you have any further questions about revocation, recovery, or the Verus Vault? How about their implications for security and control over funds?"], "AI Assistant", "", "N/A", [["What are the features and functionalities of VerusID, specifically regarding revocation, recovery, and the Verus Vault, and how do they enhance security and control over funds?", "VerusID offers advanced features to enhance security and control over funds, including revocation, recovery, and the Verus Vault. Let's break down each of these features and how they work:\n\n**Revocation and Recovery:**\nWhen creating a VerusID, users can assign a RevokeID and a RecoveryID to their VerusID. These assigned identities are also VerusIDs and must be purchased. The RevokeID and RecoveryID can be the same identities, different ones, or appointed as \"self\". \n\nWhen a VerusID is revoked, funds cannot be spent anymore. To recover a revoked VerusID, users can recover all assets to a new address, and funds and UTXOs can be spent again. However, it's essential to note that assigning a RecoveryID to \"self\" when the RevokeID is assigned to another identity can lead to a situation where the identity cannot be recovered after revocation.\n\n**Verus Vault:**\nThe Verus Vault is a unique feature that provides an extra layer of security for VerusIDs. It allows users to set locks or timelocks to safeguard funds on a VerusID. Locked identities cannot spend funds, but they can still receive, hold, and stake funds, as well as be used for signing.\n\nThe Verus Vault has three stages:\n\n1. **Locked until x blocks**: Funds cannot be spent until a predetermined number of blocks have passed.\n2. **Locked with delay**: Funds cannot be spent until an unlock has been requested, and a predetermined number of blocks have passed.\n3. **Unlocked**: Funds can be spent.\n\n**Important Notes:**\n\n* Even when a VerusID is locked or timelocked, it can still be revoked and recovered.\n* The Verus Vault does not affect the ability to receive, hold, and stake funds, or use the VerusID for signing.\n\nThe Verus Vault provides an additional layer of security and control over funds, allowing users to set specific conditions for fund accessibility. This feature can be particularly useful in scenarios where users want to ensure that their funds are protected from unauthorized access or unintended spending.", "When creating a VerusID users can assign a ``RevokeID`` and a ``RecoveryID`` to their VerusID. They can be the same identities, different ones or appointed ``self``. These assigned identities are also VerusIDs and thus must be purchased.| Action | Outcome |\n| :----------------------- | :-- | \n| Revoking | Funds can not be spent anymore | \n| Recovering | Recover all assets to a new address. Funds and UTXOs can be spent again |::: danger Be Careful\nDon't assign a ``RecoveryID`` to ``self`` when the ``RevokeID`` is assigned to another identity. This way when you revoke an identity, you can not recover it anymore.\n:::## Verus Vault\nThe Verus Vault for identities is a unique feature to create extra security. Set locks or timelocks to safeguard funds on a VerusID. Locked identities can not spend funds.### How it Works\nThere are three stages the Vault can be set to. When the vault is locked it can not spend funds.| Action | Outcome |\n| :----------------------- | :-- | \n| Locked until x blocks | Funds can not be spent, until a predetermined number of blocks have passed | \n| Locked with delay | Funds can not be spent, until an unlock has been requested + predetermined number of blocks have passed | \n| Unlocked | Funds can be spent |When a VerusID is locked or timelocked, it can still receive, hold and stake funds. It can also still be used for signing.[Learn here how to set up Verus Vault in Verus Desktop](/guides/setup-vault-v2/)::: warning Revoking Locked VerusID\nEven when a VerusID is locked, it can still be [revoked and recovered](/verusid/specifications#revoke-recover/). \n:::### Vault Use Case Examples", "./raw_text_input_docs/README_addresses.md"]]], [["User:: I've been learning about VerusIDs, and I'm curious about multisig VerusIDs. Can you explain what they are and how they work in terms of setting up a wallet that requires multiple signatures to send a transaction?", "AI Assistant:: Multisig VerusIDs are a fascinating topic, and I'd be happy to dive into the details.\n\nA multisig VerusID is a type of VerusID that allows you to set up a wallet that requires multiple signatures to send a transaction. This means that instead of a single signature being sufficient to authorize a transaction, multiple signatures are required to validate and send the transaction.\n\nIn a multisig VerusID, you can specify the number of signatures required to send a transaction, out of a total possible number of signatures. For example, you could set up a wallet that requires two out of three possible signatures before a transaction can be sent. This adds an extra layer of security and flexibility to your wallet, as multiple parties can be involved in authorizing transactions.\n\nThe flexibility of multisig VerusIDs is further illustrated by the fact that they can be set up in various configurations, such as 13 of 25 signatures, 13 of 13 signatures, 1 of 25 signatures, or even 1 of 1 signature, which is equivalent to a standard single-signature VerusID.\n\nOverall, multisig VerusIDs provide a powerful tool for managing and securing transactions on the Verus network, and can be particularly useful in scenarios where multiple parties need to be involved in authorizing transactions.\n\nDo you have any more questions about multisig VerusIDs, or how they can be used in different scenarios?"], "AI Assistant", "", "N/A", [["What is a multisig VerusID, and how does it work in terms of setting up a wallet that requires multiple signatures to send a transaction?", "A multisig VerusID is a type of VerusID that allows you to set up a wallet that requires multiple signatures to send a transaction. This means that instead of a single signature being sufficient to authorize a transaction, multiple signatures are required to validate and send the transaction.\n\nIn a multisig VerusID, you can specify the number of signatures required to send a transaction, out of a total possible number of signatures. For example, you could set up a wallet that requires two out of three possible signatures before a transaction can be sent. This adds an extra layer of security and flexibility to your wallet, as multiple parties can be involved in authorizing transactions.\n\nThe flexibility of multisig VerusIDs is further illustrated by the fact that they can be set up in various configurations, such as 13 of 25 signatures, 13 of 13 signatures, 1 of 25 signatures, or even 1 of 1 signature, which is equivalent to a standard single-signature VerusID.\n\nOverall, multisig VerusIDs provide a powerful tool for managing and securing transactions on the Verus network, and can be particularly useful in scenarios where multiple parties need to be involved in authorizing transactions.", "# Set up multisig for VerusID\nWith multisig, you can set up a wallet that requires multiple signatures to send a transaction.\n\nFor example, you could set up a wallet that requires two out of three possible signatures before a transaction can be sent.\n\nA multisig VerusID can be up to **13 of 25 signatures**. It can also be 13 of 13; 1 of 25; and of course 1 of 1.", "./raw_text_input_docs/multisig-tutorial.md"]]], [["User:: Hey, I'm having a bit of trouble understanding the VDXF object format. Could you please explain the main components of a VDXF object, and how are they serialized and deserialized?", "AI Assistant:: I'd be happy to help clarify the VDXF object format for you.\n\nA VDXF object is a structured data format used in the Verus ecosystem. It consists of three main components: the VDXF Key, Version, and Data.\n\n**VDXF Key:** The VDXF Key is a unique, 20-byte identifier that represents the type of data stored in the VDXF object. It can be represented as a human-readable string and is essential for identifying the type of data the VDXF object represents.\n\n**Version:** The Version component indicates the version of the VDXF object. This is important for ensuring that the serialized data can be correctly interpreted by systems aware of different versioning.\n\n**Data:** The Data component is the actual content stored within the VDXF object. This can be any form of data, structured or unstructured, that needs to be serialized.\n\nNow, let's talk about serialization and deserialization.\n\n**Serialization Process:**\nThe serialization process involves converting the structured data within the VDXF object into a byte stream. This includes encoding the VDXF Key, Version, and actual Data into bytes. The VDXF Key is encoded using Base58Check, the Version is serialized using variable integer encoding to optimize space, and the Data is serialized into a byte buffer. The format and encoding of the Data can vary widely depending on the type of data being serialized and the intended use case.\n\n**Deserialization Process:**\nDeserialization is the reverse of serialization, where the byte stream is converted back into structured data according to the VDXF format specification. This process involves reading the byte stream, extracting and decoding the VDXF Key, Version, and Data components, and reconstructing the original structured data.\n\nIn summary, VDXF objects are a way to store and transmit structured data in the Verus ecosystem, and the serialization and deserialization processes allow for efficient and flexible data storage and transfer.\n\nDo you have any more questions about VDXF objects, or would you like more information on how they're used in the Verus ecosystem?"], "AI Assistant", "", "N/A", [["What are the main components of a VDXF object, and how are they serialized and deserialized?", "A VDXF object is a structured data format used in the Verus ecosystem. It consists of three main components: the VDXF Key, Version, and Data.\n\n**VDXF Key:** The VDXF Key is a unique, 20-byte identifier that represents the type of data stored in the VDXF object. It can be represented as a human-readable string and is essential for identifying the type of data the VDXF object represents.\n\n**Version:** The Version component indicates the version of the VDXF object. This is important for ensuring that the serialized data can be correctly interpreted by systems aware of different versioning.\n\n**Data:** The Data component is the actual content stored within the VDXF object. This can be any form of data, structured or unstructured, that needs to be serialized.\n\n**Serialization Process:**\nThe serialization process involves converting the structured data within the VDXF object into a byte stream. This includes encoding the VDXF Key, Version, and actual Data into bytes. The VDXF Key is encoded using Base58Check, the Version is serialized using variable integer encoding to optimize space, and the Data is serialized into a byte buffer. The format and encoding of the Data can vary widely depending on the type of data being serialized and the intended use case.\n\n**Deserialization Process:**\nDeserialization is the reverse of serialization, where the byte stream is converted back into structured data according to the VDXF format specification. This process involves reading the byte stream, extracting and decoding the VDXF Key, Version, and Data components, and reconstructing the original structured data.\n\nIn summary, VDXF objects are a way to store and transmit structured data in the Verus ecosystem, and the serialization and deserialization processes allow for efficient and flexible data storage and transfer.", "- **VDXF Key**: A unique, 20 byte identifier for the VDXF object, that can be represented as a human readable string. This key is essential for identifying the type of data the VDXF object represents.\n- **Version**: Indicates the version of the VDXF object.\n- **Data**: The actual content stored within the VDXF object. This can be any form of data, structured or unstructured, that needs to be serialized.\n\n### Serialization Process\n\n![image-verusid-login](/images/vdxf-bytes.svg)\n\nThe serialization process involves converting the structured data within the VDXF object into a byte stream. This includes encoding the VDXF key, version, and actual data into bytes.\n\n#### Components Encoding\n\n- **VDXF Key**: 20 byte fixed length slice encoded using Base58Check\n- **Version**: Serialized using variable integer encoding to optimize space. The version ensures that the serialized data can be correctly interpreted by systems aware of different versioning.\n- **Data**: The actual data is serialized into a byte buffer. The format and encoding of this data can vary widely depending on the type of data being serialized and the intended use case.\n\n### Deserialization Process\n\nDeserialization is the reverse of serialization, where the byte stream is converted back into structured data according to the VDXF format specification. This process involves reading the byte stream, extracting and decoding the VDXF key, version, and data components, and reconstructing the original structured data.\n\n::: tip VDXF in Action\nLearn how the CHIPS project (decentralized poker) uses [VerusID](https://github.com/chips-blockchain/bet/blob/verus_test/docs/verus_migration/id_creation_process.md) and [VDXF](https://github.com/chips-blockchain/bet/blob/verus_test/docs/verus_migration/ids_keys_data.md)", "./raw_text_input_docs/README_vdxf.md"]]], [["User:: I'm really interested in learning more about Verus and its capabilities. Can you tell me about the key features and benefits of launching a blockchain using Verus, and how can users create their own tokens or blockchains without needing to program?", "AI Assistant:: Launching a blockchain using Verus is a powerful way to create a customizable, interoperable, and independent blockchain with a range of features. Here are some of the key benefits and features of launching a blockchain using Verus:\n\n**L1 Features:**\nVerus blockchains come with a range of L1 features, including:\n\n* **L1 Multi-currency**: Consensus layer basket currencies, simple token currencies, and decentralized crowdfund mechanisms.\n* **L1 DeFi**: Consensus layer Automated Market Makers (AMMs), MEV-free, no front/back-running, and fully decentralized marketplace.\n* **L1 VerusID**: Consensus layer self-sovereign identities, namespace for currencies, tokens, and PBaaS-blockchains, friendly-name addresses, revocable, recoverable, NFTs, profiles, and binding to any type of data.\n* **L1 Privacy**: Consensus layer zk-SNARKs privacy technology.\n\n**Security and Performance:**\nVerus blockchains are designed to be secure and high-performance, with:\n\n* **51% hash attack resistance**: 50% proof-of-work, 50% proof-of-stake, making them resistant to 51% hash attacks.\n* **High performance**: 75-800 transactions per second (TPS), with adjustable block times from 10 seconds to 2 minutes.\n\n**Scalability:**\nVerus blockchains can scale out by deploying more interoperable, interconnected PBaaS-chains.\n\n**Launch without Programming:**\nOne of the key benefits of Verus is that users can launch their own tokens or blockchains without needing to program. This is made possible by the VerusID system, which enables any user to create their own token currency or full-fledged blockchain. The cost of launching a PBaaS-chain is 10,000 VRSC, which is split between the Verus block producers and the block producers of the newly launched chain.\n\nOverall, Verus provides a powerful and flexible platform for launching customizable, interoperable, and independent blockchains, with a range of features and benefits that make it an attractive option for users.\n\nDo you have any further questions about launching a blockchain using Verus, or about creating your own tokens or blockchains without programming?"], "AI Assistant", "", "N/A", [["What are the key features and benefits of launching a blockchain using Verus, and how can users create their own tokens or blockchains without needing to program?", "Verus is a powerful platform that enables users to launch fully interoperable, customizable, and independent blockchains with a range of features. Here are some of the key benefits and features of launching a blockchain using Verus:\n\n**L1 Features:**\nVerus blockchains come with a range of L1 features, including:\n\n* **L1 Multi-currency**: Consensus layer basket currencies, simple token currencies, and decentralized crowdfund mechanisms.\n* **L1 DeFi**: Consensus layer Automated Market Makers (AMMs), MEV-free, no front/back-running, and fully decentralized marketplace.\n* **L1 VerusID**: Consensus layer self-sovereign identities, namespace for currencies, tokens, and PBaaS-blockchains, friendly-name addresses, revocable, recoverable, NFTs, profiles, and binding to any type of data.\n* **L1 Privacy**: Consensus layer zk-SNARKs privacy technology.\n\n**Security and Performance:**\nVerus blockchains are designed to be secure and high-performance, with:\n\n* **51% hash attack resistance**: 50% proof-of-work, 50% proof-of-stake, making them resistant to 51% hash attacks.\n* **High performance**: 75-800 transactions per second (TPS), with adjustable block times from 10 seconds to 2 minutes.\n\n**Scalability:**\nVerus blockchains can scale out by deploying more interoperable, interconnected PBaaS-chains.\n\n**Launch without Programming:**\nOne of the key benefits of Verus is that users can launch their own tokens or blockchains without needing to program. This is made possible by the VerusID system, which enables any user to create their own token currency or full-fledged blockchain. The cost of launching a PBaaS-chain is 10,000 VRSC, which is split between the Verus block producers and the block producers of the newly launched chain.\n\nOverall, Verus provides a powerful and flexible platform for launching customizable, interoperable, and independent blockchains, with a range of features and benefits that make it an attractive option for users.", "# Introduction\nLaunch blockchains that are \u2705 **fully interoperable**, \u2705 **customizable** and \u2705 **independent**. Each blockchain launched has the following L1 features.| Feature | Details | \n| :-----| :------ | \n| [L1 Multi-currency](/currencies/) | Consensus layer basket currencies (e.g. liquidity pools) & simple token currencies, decentralized crowdfund mechanisms |\n| [L1 DeFi](/sendcurrency/) | Consensus layer AMMs, MEV-free, no front/back-running, solving all conversions simultaneously within a block & fully decentralized marketplace | \n| [L1 VerusID](/verusid/) | Consensus layer self-sovereign identities, namespace for currencies, tokens & PBaaS-blockchains, friendly-name addresses, revocable, recoverable, NFTs, profiles, can be bound to any type of data | \n| L1 Privacy | Consensus layer zk-SNARKs privacy technology |\n| 51% hash attack resistant | 50% proof-of-work, 50% proof-of-stake. [Read the paper here.](https://verus.io/papers/VerusPoP.pdf) |\n| 75 - 800 TPS | High performance blockchain, adjustable block times 10 secs - 2 mins |\n| Scaling | Scale out by deploying more interoperable, interconnected PBaaS-chains |It costs 10,000 VRSC to launch a PBaaS-chain. 5000 goes to the Verus block producers, 5000 goes to the block producers of the newly launched chain.## Launch without programming needed\nEnables any user with VerusID to create their own token currency or even full fledged, multi-currency, VerusID-issuing 50% PoW/50% PoS, [51% hash attack resistant](https://verus.io/papers/VerusPoP.pdf) blockchain that can send and receive from the Verus chain which launched it.", "./raw_text_input_docs/README_blockchains.md"]]], [["User:: I'm curious about the Verus-Ethereum Bridge. Can you tell me about its main features and security mechanisms, and how it facilitates cross-chain transactions?", "AI Assistant:: The Verus-Ethereum Bridge is a decentralized bridge that enables seamless transactions between the Verus and Ethereum networks. I'd be happy to walk you through its key features and security mechanisms.\n\nThe bridge offers several key features that make it a powerful tool for users:\n\n**Conversions:** The bridge allows for conversions between VRSC, ETH, DAI, and MKR in any direction, on both the Verus and Ethereum networks. Additionally, it enables conversions to and from the Bridge.vETH currency.\n\n**Launch Mapped Currencies:** Users can launch currencies on Verus that are 1:1 mapped to any ERC-20 token.\n\n**Export Currencies as ERC-20:** Any launched currency on Verus can be exported as an ERC-20 token on Ethereum.\n\n**Cross-Chain Sends:** The bridge enables sending of tokens, basket currencies, and mapped currencies across the bridge.\n\n**Export Tokenized ID Control:** Users can export a tokenized VerusID to Ethereum as an ERC-721 token.\n\n**Map VerusID to Ethereum NFT:** It is possible to launch a tokenized ID with a mapping of an Ethereum ERC-721 or ERC-1155 token.\n\nThe Bridge.vETH currency is a 100% backed currency that makes bridging assets simple, with fees converted seamlessly.\n\nNow, about security: the Verus-Ethereum Bridge is secure due to its decentralized architecture, which ensures that assets are never in anyone's custody. The bridge operates through the cooperation of block producers, community notary witnesses, the Bridgekeeper software, and an Ethereum smart contract. At each step of cross-chain transactions, assets are verified and proven by consensus rules, with safeguards in place to prevent hacks. This ensures that transactions are secure, trustless, and censorship-resistant.\n\nDo you have any further questions about the Verus-Ethereum Bridge or its features?"], "AI Assistant", "", "N/A", [["What are the main features and security mechanisms of the Verus-Ethereum Bridge, and how does it facilitate cross-chain transactions?", "The Verus-Ethereum Bridge is a decentralized bridge that enables seamless transactions between the Verus and Ethereum networks. The bridge offers several key features that make it a powerful tool for users:\n\n**Conversions:** The bridge allows for conversions between VRSC, ETH, DAI, and MKR in any direction, on both the Verus and Ethereum networks. Additionally, it enables conversions to and from the Bridge.vETH currency.\n\n**Launch Mapped Currencies:** Users can launch currencies on Verus that are 1:1 mapped to any ERC-20 token.\n\n**Export Currencies as ERC-20:** Any launched currency on Verus can be exported as an ERC-20 token on Ethereum.\n\n**Cross-Chain Sends:** The bridge enables sending of tokens, basket currencies, and mapped currencies across the bridge.\n\n**Export Tokenized ID Control:** Users can export a tokenized VerusID to Ethereum as an ERC-721 token.\n\n**Map VerusID to Ethereum NFT:** It is possible to launch a tokenized ID with a mapping of an Ethereum ERC-721 or ERC-1155 token.\n\nThe Bridge.vETH currency is a 100% backed currency that makes bridging assets simple, with fees converted seamlessly.\n\nThe Verus-Ethereum Bridge is secure due to its decentralized architecture, which ensures that assets are never in anyone's custody. The bridge operates through the cooperation of block producers, community notary witnesses, the Bridgekeeper software, and an Ethereum smart contract. At each step of cross-chain transactions, assets are verified and proven by consensus rules, with safeguards in place to prevent hacks. This ensures that transactions are secure, trustless, and censorship-resistant.", "| What       |     Details      |\n| :------------------ | :----------------------------------------- |\n| **Conversions**| Convert VRSC, ETH (vETH), DAI (DAI.vETH) & MKR (MKR.vETH) with each other into any direction (on/to Verus & Ethereum), or to and from the Bridge.vETH currency.|\n| **Launch mapped currencies**| Launch currencies on Verus that are 1:1 mapped to any ERC-20. [Learn how](/currencies/mapping-1:1-eth.html)|\n| **Export currencies as ERC-20**| Export any launched currency (simple tokens, basket currencies) on Verus as an ERC-20. [Learn how](/currencies/export-to-eth.html)|\n| **Cross-chain sends**| Send any tokens, basket currencies (e.g. liquidity pools), mapped currencies etc. that are exported to Ethereum across the bridge.|\n| **Export tokenized ID control**| Export a tokenized VerusID to Ethereum as ERC-721.|\n| **Map VerusID to Ethereum NFT**| Launch a tokenized ID with a mapping of an Ethereum ERC-721 or ERC-1155.|Then there is the bridge currency Bridge.vETH, a 100% backed currency with 4 currencies in its reserves (VRSC, ETH, DAI, MKR). The Bridge.vETH currency function is to make the bridging of assets simple. From wherever you send it converts the fees that you need seamlessly. [More on Bridge.vETH below.](/eth-bridge/#bridge-veth-currency)## What makes the Verus-Ethereum Bridge secure\nThe Verus-Ethereum Bridge is different because the assets are never in anyone\u2019s custody. This is done through the seamless cooperation between the block producers (worldwide miners and stakers), community notary witnesses, [the Bridgekeeper software](https://github.com/VerusCoin/Verusbridgekeeper) and the [Ethereum smart contract](https://etherscan.io/address/0x71518580f36FeCEFfE0721F06bA4703218cD7F63). At each step during cross-chain transactions the assets are verified and proven by consensus rules, with safeguards in place to prevent hacks.", "./raw_text_input_docs/README_eth-bridge.md"]]], [["User:: Hey, I'm trying to register a VerusID or subID on the Verus network, but I'm not sure how to do it. Can you walk me through the process?", "AI Assistant:: Registering a VerusID or subID on the Verus network involves a series of steps. I'd be happy to guide you through it.\n\nTo register a VerusID or subID, you need to follow a series of steps. The process involves committing a name, waiting for a block to pass, and then registering the VerusID or subID. Here's a detailed breakdown of the steps:\n\n**Step 1: Commit a Name**\nThe first step is to commit a name for your VerusID or subID. This involves using the `registernamecommitment` command, which costs a transaction fee of 0.0001. The command format is:\n```\n./verus -chain=VRSCTEST registernamecommitment \"YOUR_ID_NAME\" \"YOUR_R_ADDRESS\" \"REFERRAL_ID[OPTIONAL]\" \"CURRENCY_NAME[OPTIONAL]\"\n```\nNote that the `CURRENCY_NAME` parameter is only required for subID registrations.\n\n**Step 2: Wait for a Block to Pass**\nAfter committing the name, you need to wait for at least one block to pass on the Verus network. This is necessary to ensure that the name commitment is confirmed and registered on the network.\n\n**Step 3: Register the VerusID or subID**\nOnce the block has passed, you can register the VerusID or subID using the `registeridentity` command. The command format is:\n```\n./verus -chain=VRSCTEST registeridentity '{\n\"txid\": \"TX_ID_FROM_NAME_COMMITMENT\",\n\"namereservation\": {\n\"version\": 1,\n\"name\": \"YOUR_ID_NAME\",\n\"parent\": \"PARENT_ID\",\n\"salt\": \"SALT_VALUE\",\n\"referral\": \"REFERRAL_ID\",\n\"nameid\": \"NAME_ID\"\n},\n\"identity\":{\n\"name\":\"YOUR_ID_NAME\",\n\"primaryaddresses\":[\"R_ADDRESS_CHOSEN_WITH_NAME_COMMITMENT\"],\n\"minimumsignatures\":1,\n\"revocationauthority\":[\"CHOOSE_I_ADDRESS\"],\n\"recoveryauthority\":[\"CHOOSE_I_ADDRESS\"]\n}\n}'\n```\nYou'll need to replace the placeholders with the actual values from your name commitment output.\n\n**Key Concepts**\n\n* **VerusID**: A unique identity on the Verus network that can be used for various purposes, such as sending and receiving funds.\n* **subID**: A sub-identity that is tied to a specific currency and can be used for more granular control over identity management.\n* **Name Commitment**: A transaction that commits a name to the Verus network, which is necessary before registering a VerusID or subID.\n* **Referral ID**: An optional parameter that allows you to specify a referral ID for the name commitment.\n\nBy following these steps, you can successfully register a VerusID or subID on the Verus network.\n\nDo you have any further questions about this process, or would you like some clarification on any of the steps?"], "AI Assistant", "", "N/A", [["How do I register a VerusID or subID on the Verus network, and what are the steps involved in this process?", "To register a VerusID or subID on the Verus network, you need to follow a series of steps. The process involves committing a name, waiting for a block to pass, and then registering the VerusID or subID. Here's a detailed breakdown of the steps:\n\n**Step 1: Commit a Name**\nThe first step is to commit a name for your VerusID or subID. This involves using the `registernamecommitment` command, which costs a transaction fee of 0.0001. The command format is:\n```\n./verus -chain=VRSCTEST registernamecommitment \"YOUR_ID_NAME\" \"YOUR_R_ADDRESS\" \"REFERRAL_ID[OPTIONAL]\" \"CURRENCY_NAME[OPTIONAL]\"\n```\nNote that the `CURRENCY_NAME` parameter is only required for subID registrations.\n\n**Step 2: Wait for a Block to Pass**\nAfter committing the name, you need to wait for at least one block to pass on the Verus network. This is necessary to ensure that the name commitment is confirmed and registered on the network.\n\n**Step 3: Register the VerusID or subID**\nOnce the block has passed, you can register the VerusID or subID using the `registeridentity` command. The command format is:\n```\n./verus -chain=VRSCTEST registeridentity '{\n  \"txid\": \"TX_ID_FROM_NAME_COMMITMENT\",\n  \"namereservation\": {\n    \"version\": 1,\n    \"name\": \"YOUR_ID_NAME\",\n    \"parent\": \"PARENT_ID\",\n    \"salt\": \"SALT_VALUE\",\n    \"referral\": \"REFERRAL_ID\",\n    \"nameid\": \"NAME_ID\"\n  },\n  \"identity\":{\n    \"name\":\"YOUR_ID_NAME\",\n    \"primaryaddresses\":[\"R_ADDRESS_CHOSEN_WITH_NAME_COMMITMENT\"],\n    \"minimumsignatures\":1,\n    \"revocationauthority\":[\"CHOOSE_I_ADDRESS\"],\n    \"recoveryauthority\":[\"CHOOSE_I_ADDRESS\"]\n  }\n}'\n```\nYou'll need to replace the placeholders with the actual values from your name commitment output.\n\n**Key Concepts**\n\n* **VerusID**: A unique identity on the Verus network that can be used for various purposes, such as sending and receiving funds.\n* **subID**: A sub-identity that is tied to a specific currency and can be used for more granular control over identity management.\n* **Name Commitment**: A transaction that commits a name to the Verus network, which is necessary before registering a VerusID or subID.\n* **Referral ID**: An optional parameter that allows you to specify a referral ID for the name commitment.\n\nBy following these steps, you can successfully register a VerusID or subID on the Verus network.", "# Register VerusID / subID\n\nRegister a VerusID or subID. First a name needs to be committed, this costs a transaction fee (0.0001), after a block has passed the VerusID or subID can be registered.\n\n### VerusID name commitment\nCommit a VerusID name by using the following command below. If no referral is available leave it empty.\n\n``` json\n./verus -chain=VRSCTEST registernamecommitment \"YOUR_ID_NAME\" \"YOUR_R_ADDRESS\" \"REFERRAL_ID[OPTIONAL]\"\n```\n\nUsing the command above gives an output. Take that output and add the highlighted lines from below:\n\n### VerusID registration\n\n``` json{11-16}\n./verus -chain=VRSCTEST registeridentity '{\n \"txid\": \"2a614ae147a8abcb870eb45d5ddbfc1e1d283b942a5e77340d0d268c7fd47260\",\n \"namereservation\": {\n  \"version\": 1,\n  \"name\": \"test-id\",\n  \"parent\": \"iJhCezBExJHvtyH3fGhNnt2NhU4Ztkf2yq\",\n  \"salt\": \"bf5b76bb38cefd2bec266bdcc2f2f37cb321c9aab103e4aa802fdef90224a2f7\",\n  \"referral\": \"\",\n  \"nameid\": \"iMGMwQhtnaVwdrzev9uMspuNyQbYhCJEmU\"\n }, \n  \"identity\":{\n    \"name\":\"YOUR_ID_NAME\",\n    \"primaryaddresses\":[\"R_ADDRESS_CHOSEN_WITH_NAME_COMMITMENT\"],\n    \"minimumsignatures\":1,\n    \"revocationauthority\":[\"CHOOSE_I_ADDRESS\"],\n    \"recoveryauthority\":[\"CHOOSE_I_ADDRESS\"]}\n}'\n```\n\n### SubID name commitment\nCommit a subID name by using the following command below (it is almost the same as doing a VerusID name commitment, except currency name is added.)\n\n``` json\n./verus -chain=VRSCTEST registernamecommitment \"YOUR_ID_NAME\" \"YOUR_R_ADDRESS\" \"REFERRAL_ID[OPTIONAL]\" \"CURRENCY_NAME\"\n```\n\n### SubID registration\nThe same as with VerusID registration.", "./raw_text_input_docs/verusid-create.md"]]], [["User:: Hey, I'm interested in moving some assets from the Verus blockchain to the Ethereum blockchain. Can you tell me how to do that, and what I should keep in mind when doing so?", "AI Assistant:: Bridging assets from the Verus blockchain to the Ethereum blockchain allows you to move assets between the two chains. To do this, you need to use a bridge, which is a smart contract on the Ethereum side that enables the transfer of assets. When bridging, you need to pay gas fees on the Ethereum side to use the smart contract.\n\nTo get started, you'll want to estimate the bridging costs. You can do this using Verus Mobile or by running a command on your computer using the Verus CLI. The command is:\n```json\nrun sendcurrency \"*\" '[{\n\"currency\":\"veth\",\n\"exportto\":\"veth\",\n\"address\":\"0x71518580f36FeCEFfE0721F06bA4703218cD7F63\",\n\"amount\":1,\n\"refundto\":\"john doe@\"\n}]' 1 0.0001 1\n```\nAlternatively, you can use a `curl` command to estimate the bridging costs.\n\nWhen running the command, make sure to keep the `1` at the end, or you will send the actual amount. The response will contain the fee you need to pay in VRSC to bridge from Verus to Ethereum.\n\nThe bridging process can take 30-60 minutes to complete. You can use Verus Mobile, Verus Desktop, or the Verus CLI to bridge your assets from Verus to Ethereum.\n\nIt's essential to consider a few things when bridging your assets. Firstly, gas fees on the Ethereum side can be expensive, so make sure you're prepared for that. Additionally, you should ensure you have sufficient VRSC to pay for the bridging fee.\n\nOnce you have estimated the bridging costs, you can proceed with the bridging process using Verus Mobile, Verus Desktop, or the Verus CLI.\n\nDo you have any further questions about bridging assets from Verus to Ethereum, or would you like more information on any of the steps I mentioned?"], "AI Assistant", "", "N/A", [["How can I bridge assets from the Verus blockchain to the Ethereum blockchain, and what should I consider when doing so?", "Bridging assets from the Verus blockchain to the Ethereum blockchain allows you to move assets between the two chains. To do this, you need to use a bridge, which is a smart contract on the Ethereum side that enables the transfer of assets. When bridging, you need to pay gas fees on the Ethereum side to use the smart contract.\n\nTo estimate the bridging costs, you can use Verus Mobile or run a command on your computer using the Verus CLI. The command is:\n```json\nrun sendcurrency \"*\" '[{\n  \"currency\":\"veth\",\n  \"exportto\":\"veth\",\n  \"address\":\"0x71518580f36FeCEFfE0721F06bA4703218cD7F63\",\n  \"amount\":1,\n  \"refundto\":\"john doe@\"\n}]' 1 0.0001 1\n```\nAlternatively, you can use a `curl` command to estimate the bridging costs.\n\nWhen running the command, make sure to keep the `1` at the end, or you will send the actual amount. The response will contain the fee you need to pay in VRSC to bridge from Verus to Ethereum.\n\nThe bridging process can take 30-60 minutes to complete. You can use Verus Mobile, Verus Desktop, or the Verus CLI to bridge your assets from Verus to Ethereum.\n\nIt's essential to consider the gas fees on the Ethereum side, as they can be expensive. Additionally, you should ensure you have sufficient VRSC to pay for the bridging fee.\n\nOnce you have estimated the bridging costs, you can proceed with the bridging process using Verus Mobile, Verus Desktop, or the Verus CLI.", "# How to bridge from Verus to Ethereum\nBridge VRSC, ETH, DAI, MKR, Bridge.vETH and any other bridged assets from the Verus blockchain to the Ethereum blockchain.To bridge from Verus to Ethereum gas fees have to be paid to use the smart contract on the Ethereum side. It can be very expensive.You can estimate the bridging costs through Verus Mobile or if you are on a computer use the following command: (\u26a0\ufe0f KEEP THE `1` AT THE END OR YOU WILL SEND THE ACTUAL AMOUNT)``` json\nrun sendcurrency \"*\" '[{\n  \"currency\":\"veth\",\n  \"exportto\":\"veth\",\n  \"address\":\"0x71518580f36FeCEFfE0721F06bA4703218cD7F63\",\n  \"amount\":1,\n  \"refundto\":\"john doe@\"\n}]' 1 0.0001 1\n```Or use:``` json\ncurl --location 'https://YOUR-API-SERVER' \\\n--header 'content-type: text/plain;' \\\n--data-raw '{\n  \"jsonrpc\": \"1.0\",\n  \"id\": \"curltext\",\n  \"method\": \"sendcurrency\",\n  \"params\": [\n    \"*\",\n    [\n      {\n        \"currency\": \"veth\",\n        \"exportto\": \"veth\",\n        \"address\": \"0x71518580f36FeCEFfE0721F06bA4703218cD7F63\",\n        \"amount\": 1,\n        \"refundto\": \"john doe@\"\n      }\n    ],\n    1,\n    0.0001,\n    true\n  ]\n}'\n```Then you look for the number after ``i5w5MuNik5NtLcYmNzcvaoixooEebB6MGV``, it is the fee you have to pay in VRSC to cross from Verus to Ethereum.\u23f1\ufe0f The bridging from Verus to Ethereum can take 30 - 60 mins.Learn how to go from Verus to Ethereum with [Verus Mobile](/eth-bridge/verus-to-ethereum.html#verus-mobile), [Verus Desktop](/eth-bridge/verus-to-ethereum.html#verus-desktop) or [CLI](/eth-bridge/verus-to-ethereum.html#cli).## Verus Mobile\nTo bridge over from Verus to Ethereum using Verus Mobile you can go to vETH (or DAI.vETH, MKR.vETH, VRSC or other bridged assets). Then click on \"Send\", then \"Convert or Cross-chain\", then \"Send off-chain\".", "./raw_text_input_docs/verus-to-ethereum.md"]]], [["User:: I've been hearing a lot about Verus DeFi, but I'm not entirely sure what it's all about. Can you walk me through the key features and benefits of Verus DeFi, and how it differs from other DeFi solutions in terms of security, fees, and architecture?", "AI Assistant:: Verus DeFi is a decentralized finance (DeFi) platform that offers a unique set of features and benefits. Here are some of the key advantages of Verus DeFi:\n\n**MEV-Resistance:** Verus DeFi is designed to be MEV-resistant, which means that there is no front-running or back-running of transactions. All participants receive the same, fair conversion rate in one or more blocks.\n\n**Protocol-Level Security:** Verus DeFi operates at the protocol level, which means that all DeFi operations are verified by miners and stakers. This eliminates the risk of smart contract exploits and ensures a high level of security.\n\n**Low Fees:** Verus DeFi has very low fees, with protocol conversion fees ranging from 0.025% to 0.05%. These fees are distributed between the reserves of the basket currency and the block reward for miners and stakers.\n\n**Two Conversion Types:** Verus DeFi supports two types of conversions: basket currency to reserve, and reserve to reserve. The fees for these conversions are 0.025% and 0.05%, respectively.\n\n**L1 DeFi:** Verus is a UTXO-based blockchain with smart transactions, which means that all smart capabilities are implemented at the protocol level. This architecture provides several advantages over layer two solutions, including increased security, simplicity, and low fees.\n\n**Advantages of DeFi at the Protocol Level:** By implementing DeFi at the protocol level, Verus eliminates the risk of smart contract exploits and ensures a high level of security. This approach also simplifies the DeFi process and reduces fees, making it more accessible to users. Additionally, Verus DeFi is not dependent on multiple smart contract authors, which reduces the risk of unintended \"cracks\" in the system.\n\nOverall, Verus DeFi offers a unique combination of security, simplicity, and low fees, making it an attractive option for users looking to participate in decentralized finance.\n\nDo you have any further questions about Verus DeFi, or would you like me to elaborate on any of these points?"], "AI Assistant", "", "N/A", [["What are the key features and benefits of Verus DeFi, and how does it differ from other DeFi solutions in terms of security, fees, and architecture?", "Verus DeFi is a decentralized finance (DeFi) platform that offers a unique set of features and benefits. Here are some of the key advantages of Verus DeFi:\n\n**MEV-Resistance:** Verus DeFi is designed to be MEV-resistant, which means that there is no front-running or back-running of transactions. All participants receive the same, fair conversion rate in one or more blocks.\n\n**Protocol-Level Security:** Verus DeFi operates at the protocol level, which means that all DeFi operations are verified by miners and stakers. This eliminates the risk of smart contract exploits and ensures a high level of security.\n\n**Low Fees:** Verus DeFi has very low fees, with protocol conversion fees ranging from 0.025% to 0.05%. These fees are distributed between the reserves of the basket currency and the block reward for miners and stakers.\n\n**Two Conversion Types:** Verus DeFi supports two types of conversions: basket currency to reserve, and reserve to reserve. The fees for these conversions are 0.025% and 0.05%, respectively.\n\n**L1 DeFi:** Verus is a UTXO-based blockchain with smart transactions, which means that all smart capabilities are implemented at the protocol level. This architecture provides several advantages over layer two solutions, including increased security, simplicity, and low fees.\n\n**Advantages of DeFi at the Protocol Level:** By implementing DeFi at the protocol level, Verus eliminates the risk of smart contract exploits and ensures a high level of security. This approach also simplifies the DeFi process and reduces fees, making it more accessible to users. Additionally, Verus DeFi is not dependent on multiple smart contract authors, which reduces the risk of unintended \"cracks\" in the system.\n\nOverall, Verus DeFi offers a unique combination of security, simplicity, and low fees, making it an attractive option for users looking to participate in decentralized finance.", "# Introduction\nVerus DeFi is incredibly simple, low-cost, MEV-resistant and without any middleman. You can convert into a currency that has reserves (you are now \"providing liquidity\"), and you can convert out of the currency again, back into its reserves. Furthermore you can convert from reserve to reserve. [Learn more about basket currencies (DeFi AMMs).](/currencies/#basket-currencies)| Verus DeFi | Details | \n| :-----| :------ | \n| \u2705 **MEV-resistant** | Because of protocol design there is no front/back running. Every participant gets the same, fair conversion rate in one or more blocks. | \n| \u2705 **Protocol level security** | All DeFi operations take place on the consensus layer of the protocol, and are verified by miners and stakers. There is no smart contract risk. | \n| \u2705 **Low fees** | Protocol conversion fees are as low as 0.025%, or as high as 0.05%. |Two conversion types:| Conversion type | Fee | Fee goes to |\n| :-----| :------ | :-------- |\n| Basket currency \u2194\ufe0f reserve | 0.025% | 0.0125% added to reserves of the basket currency, 0.0125% to the block reward for miners and stakers | \n| Reserve \u2194\ufe0f reserve | 0.05% | 0.025% added to reserves of the basket currency, 0.025% to the block reward for miners and stakers |## L1 DeFi\nVerus is a ``UTXO-based`` blockchain with ``smart transactions``. All smart capabilities are implemented on the protocol level. This has many advantages over blockchain projects that use layer two solutions. [Read \"Smart Transactions vs. Smart Contracts\"](https://medium.com/veruscoin/verus-smart-transactions-vs-smart-contracts-f98079c00ed0)Advantages of DeFi at the protocol level:* Increased security at the application level - Verus DeFi is not implemented by having many smart contract authors creating smart contracts on top of the protocol, so there can be no exploits by searching for unintended \"cracks\" in the seams between contracts.", "./raw_text_input_docs/README_sendcurrency.md"]]], [["User:: Hi, I'm interested in learning more about VerusIDs on the Verus blockchain. Specifically, I'd like to know what the costs and structure of a VerusID are.", "AI Assistant:: On the Verus blockchain, a VerusID costs 100 VRSC, which is the base cost. However, this cost can be discounted with referrals. All costs paid are distributed to the miners and stakers of the ecosystem and to the referrals if used.\n\nWhen a referral is used, the cost of a VerusID decreases to 80 VRSC. The referral system is designed to reward users with identities. For each VerusID a user creates, the referral identity receives 20 VRSC. The referral system goes three levels down, allowing users to receive up to 60 VRSC with each VerusID creation, reducing the cost of a VerusID to just 20 VRSC.\n\nNow, let me break down the structure of a VerusID for you:\n\n1. **VerusID Name**: A unique namespace and human-readable cryptocurrency address.\n2. **Primary Address**: The owner of the VerusID, containing the private key. It can contain more than one VerusID.\n3. **Identity Address**: The identifier of the VerusID, along with the name.\n4. **Private Address**: An optional attached private z-address.\n5. **Revocation Authority**: The identity address that can revoke the VerusID.\n6. **Recovery Authority**: The identity address that can recover the VerusID.\n7. **Contentmap**: VDXF key/value data.\n\nAlso, it's worth noting that when creating a VerusID on the Verus blockchain, users can support the Verus vision by using ``Verus Coin Foundation@`` as their referral, with all proceeds going towards further development of the Verus vision.\n\nDo you have any further questions about VerusIDs, their costs, or their structure?"], "AI Assistant", "", "N/A", [["What are the costs and structure of a VerusID on the Verus blockchain?", "On the Verus blockchain, a VerusID costs 100 VRSC, which is the base cost. However, this cost can be discounted with referrals. All costs paid are distributed to the miners and stakers of the ecosystem and to the referrals if used. \n\nWhen a referral is used, the cost of a VerusID decreases to 80 VRSC. The referral system is designed to reward users with identities. For each VerusID a user creates, the referral identity receives 20 VRSC. The referral system goes three levels down, allowing users to receive up to 60 VRSC with each VerusID creation, reducing the cost of a VerusID to just 20 VRSC.\n\nAs for the structure of a VerusID, it consists of several components:\n\n1. **VerusID Name**: A unique namespace and human-readable cryptocurrency address.\n2. **Primary Address**: The owner of the VerusID, containing the private key. It can contain more than one VerusID.\n3. **Identity Address**: The identifier of the VerusID, along with the name.\n4. **Private Address**: An optional attached private z-address.\n5. **Revocation Authority**: The identity address that can revoke the VerusID.\n6. **Recovery Authority**: The identity address that can recover the VerusID.\n7. **Contentmap**: VDXF key/value data.\n\nAdditionally, when creating a VerusID on the Verus blockchain, users can support the Verus vision by using ``Verus Coin Foundation@`` as their referral, with all proceeds going towards further development of the Verus vision.", "## Costs\n**On the Verus blockchain** a VerusID costs 100 VRSC. These costs can be discounted with referrals. All costs paid are going to the [miners and stakers of the ecosystem](/economy/) and to the referrals if used.| | VerusID Cost |\n| :----------------------- | --: | \n| **Base cost** | 100 VRSC | \n| **Cost with referral used** | 80 VRSC |### Referrals\nA referral system is implemented to reward users with identities. For each VerusID a user creates, the referral identity receives 20 VRSC. The referral system goes three levels down.If one owns three identities that are stringed together through its referrals, one can receive 60 VRSC with each VerusID creation. This way an identity only has to cost 20 VRSC.::: tip Support the Verus Vision\nUse ``Verus Coin Foundation@`` when creating a VerusID on the Verus blockchain. All proceeds will go to the further development of the Verus vision.\n:::## Structure\nAn example of a VerusID:\n| Structure | Information |\n| :----------------------- | :--------------------- | \n| **VerusID Name** | The name is a unique namespace and human readable cryptocurrency address. | \n| **Primary Address** | The primary address is the owner of the VerusID, as it contains the private key. It can contain more than one VerusID. | \n| **Identity Address** | The identity address is, next to the name, the identifier of the VerusID. | \n| **Private Address** | An optional attached private z-address | \n| **Revocation Authority** | The identity address that can revoke the VerusID | \n| **Recovery Authority** | The identity address that can recover the VerusID | \n| **Contentmap** | VDXF key/value data |", "./raw_text_input_docs/README_addresses.md"]]], [["User:: I'm interested in creating a new currency using Verus, but I'm not entirely sure about the parameters involved. Specifically, I'd love to know more about \"conversions\" and \"minpreconversion\". Can you explain what they are and how they affect the currency's launch and distribution?", "AI Assistant:: When defining a new currency using Verus, there are several key concepts and parameters to consider. Two important parameters are indeed \"conversions\" and \"minpreconversion\".\n\n**Conversions:**\nThe \"conversions\" parameter is used when launching a simple token currency. It sets the preconversion price, which determines how many units of the new currency will be received for each unit of the underlying currency (e.g. VRSCTEST) preconverted. For example, if \"conversions\" is set to `[0.1]`, then for every 1 VRSCTEST preconverted, 10 units of the new currency will be received after launch. The converted VRSCTEST goes into the rootID.\n\n**Minpreconversion:**\nThe \"minpreconversion\" parameter sets a minimum amount of preconversions required for the currency to launch. If this minimum amount is not met within the preconversion time frame (which can be set using the \"startblock\" parameter, or defaults to a minimum of 20 blocks), the currency will not launch, and all preconverters will have their funds returned, minus transaction and conversion fees.\n\n**Example Usage:**\nHere are two examples of defining a new currency using Verus, demonstrating the use of \"conversions\" and \"minpreconversion\" parameters:\n\n1. **Basket Currency:**\nA basket currency called CommunityX can be defined with a minimum preconversion requirement of 10 VRSCTEST, 50 MyBrand, and 10 InfluencerCoin. If this minimum amount is not met within the preconversion time frame, the currency will not launch.\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"CommunityX\",\n\"options\":33,\n\"currencies\":[\"vrsctest\",\"MyBrand\",\"InfluencerCoin\"],\n\"minpreconversion\":[10,50,10],\n\"initialsupply\":100\n}'\n```\n2. **Simple Token Currency:**\nA simple token currency called CoolBrand can be defined with a preconversion price of 0.1, meaning 10 CoolBrand will be received for every 1 VRSCTEST preconverted. The currency requires a minimum of 1000 VRSCTEST to be preconverted within the preconversion time frame, or it will not launch.\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"CoolBrand\",\n\"options\":32,\n\"currencies\":[\"vrsctest\"],\n\"conversions\":[0.1],\n\"minpreconversion\":[1000]\n}'\n```\nIn summary, \"conversions\" sets the preconversion price, while \"minpreconversion\" sets a minimum amount of preconversions required for the currency to launch. Both parameters are essential when defining a new currency using Verus.\n\nDo you have any more questions about these parameters or the process of creating a new currency with Verus? I'm here to help!"], "AI Assistant", "", "N/A", [["What are the key concepts and parameters involved in defining a new currency using Verus, specifically the \"conversions\" and \"minpreconversion\" parameters, and how do they affect the currency's launch and distribution?", "When defining a new currency using Verus, there are several key concepts and parameters to consider. Two important parameters are \"conversions\" and \"minpreconversion\". \n\n**Conversions:**\nThe \"conversions\" parameter is used when launching a simple token currency. It sets the preconversion price, which determines how many units of the new currency will be received for each unit of the underlying currency (e.g. VRSCTEST) preconverted. For example, if \"conversions\" is set to `[0.1]`, then for every 1 VRSCTEST preconverted, 10 units of the new currency will be received after launch. The converted VRSCTEST goes into the rootID.\n\n**Minpreconversion:**\nThe \"minpreconversion\" parameter sets a minimum amount of preconversions required for the currency to launch. If this minimum amount is not met within the preconversion time frame (which can be set using the \"startblock\" parameter, or defaults to a minimum of 20 blocks), the currency will not launch, and all preconverters will have their funds returned, minus transaction and conversion fees.\n\n**Example Usage:**\nHere are two examples of defining a new currency using Verus, demonstrating the use of \"conversions\" and \"minpreconversion\" parameters:\n\n1. **Basket Currency:**\nA basket currency called CommunityX can be defined with a minimum preconversion requirement of 10 VRSCTEST, 50 MyBrand, and 10 InfluencerCoin. If this minimum amount is not met within the preconversion time frame, the currency will not launch.\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CommunityX\", \n \"options\":33, \n \"currencies\":[\"vrsctest\",\"MyBrand\",\"InfluencerCoin\"], \n \"minpreconversion\":[10,50,10],\n \"initialsupply\":100\n}'\n```\n2. **Simple Token Currency:**\nA simple token currency called CoolBrand can be defined with a preconversion price of 0.1, meaning 10 CoolBrand will be received for every 1 VRSCTEST preconverted. The currency requires a minimum of 1000 VRSCTEST to be preconverted within the preconversion time frame, or it will not launch.\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CoolBrand\",\n \"options\":32,\n \"currencies\":[\"vrsctest\"],\n \"conversions\":[0.1],\n \"minpreconversion\":[1000]\n}'\n```\nIn summary, \"conversions\" sets the preconversion price, while \"minpreconversion\" sets a minimum amount of preconversions required for the currency to launch. Both parameters are essential when defining a new currency using Verus.", "Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CommunityX\", \n \"options\":33, \n \"currencies\":[\"vrsctest\",\"MyBrand\",\"InfluencerCoin\"], \n \"minpreconversion\":[10,50,10],\n \"initialsupply\":100\n}'\n```\n\u261d\ufe0f A basket currency called CommunityX. It needs to get a minimum of 10 VRSCTEST, 50 MyBrand and 10 InfluencerCoin into its reserves within the preconversion time frame to be launched. The initial supply of 100 CommunityX will be distributed among the preconverters.### **\"conversions\"**\nUse this parameter when launching a simple token currency. Together with `\"currencies\"`, it can be used as a funding mechanism for the rootID. This parameter is for the preconversion price. So when doing `\"conversions\":[0.1]`, it means that for every VRSC the preconverter receives 10 CURRENCY after launch. The converted VRSC goes into the rootID.People can preconvert to this currency within the preconversion time frame. Define a `\"startblock\"`, or let the default and minimum time frame play out, which is 20 blocks.Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"CoolBrand\",\n \"options\":32,\n \"currencies\":[\"vrsctest\"],\n \"conversions\":[0.1],\n \"minpreconversion\":[1000]\n}'\n```\n\u261d\ufe0f This simple token currency is called CoolBrand. During the preconversion time frame people need to convert 1000 VRSCTEST to the rootID. In exchange for that they receive 10.000 CoolBrand. If this minimum amount is not met, the currency will not launch, and everyone who did a preconvert will get their funds back.### **\"minpreconversion\"**\nUse this parameter to set a minimum amount of preconversions. The minimum amount of preconversions needs to be met or the currency will not launch and everyone gets their conversions returned, minus the transaction and conversion fees. It works both with basket currencies and simple token currencies.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I'm really interested in understanding how Verus creates a decentralized economy. Can you explain that to me, and also tell me about the key features of its mining and staking ecosystems?", "AI Assistant:: Verus is designed to create a decentralized economy where costs for services are distributed to miners and stakers, eliminating developer fees and rent-seeking profiteers. This is achieved through a unique mining and staking ecosystem.\n\nLet me break it down for you.\n\n**Mining Ecosystem:**\nVerus has a decentralized miner ecosystem that utilizes the VerusHash 2.2 mining algorithm, which ensures fairness across hardware classes. This means that anyone can start mining with consumer-grade hardware, without the need for specialized equipment. In fact, mining can be started directly from within Verus Desktop, making it easy for new miners to get started.\n\n**Merge Mining:**\nAdditionally, when PBaaS (Public Blockchain as a Service) goes live, miners can choose to mine up to 22 PBaaS-chains simultaneously, without losing any of their original hashing power. This allows miners to diversify their mining efforts and increase their potential earnings.\n\n**Staking Ecosystem:**\nAnyone can start staking Verus, regardless of the amount they hold, even if it's a tiny amount like 0.00000001 VRSC. Verus has a powerful and fair staking system that does not require a threshold or registration. This means that anyone can participate in staking and contribute to the security of the network.\n\n**Block Rewards:**\nMiners and stakers are rewarded for their efforts to keep the network secure through block rewards. The Verus block reward emission schedule ensures that rewards are distributed fairly and transparently to miners and stakers. This incentivizes participants to continue contributing to the network's security and growth.\n\nOverall, Verus's decentralized economy, mining, and staking ecosystems work together to create a fair and inclusive environment where anyone can participate and contribute to the network's success.\n\nDo you have any more questions about Verus's decentralized economy, mining, or staking ecosystems?"], "AI Assistant", "", "N/A", [["How does Verus create a decentralized economy, and what are the key features of its mining and staking ecosystems?", "Verus is designed to create a decentralized economy where costs for services are distributed to miners and stakers, eliminating developer fees and rent-seeking profiteers. This is achieved through a unique mining and staking ecosystem.\n\n**Mining Ecosystem:**\nVerus has a decentralized miner ecosystem that utilizes the VerusHash 2.2 mining algorithm, which ensures fairness across hardware classes. This means that anyone can start mining with consumer-grade hardware, without the need for specialized equipment. In fact, mining can be started directly from within Verus Desktop, making it easy for new miners to get started.\n\n**Merge Mining:**\nAdditionally, when PBaaS (Public Blockchain as a Service) goes live, miners can choose to mine up to 22 PBaaS-chains simultaneously, without losing any of their original hashing power. This allows miners to diversify their mining efforts and increase their potential earnings.\n\n**Staking Ecosystem:**\nAnyone can start staking Verus, regardless of the amount they hold, even if it's a tiny amount like 0.00000001 VRSC. Verus has a powerful and fair staking system that does not require a threshold or registration. This means that anyone can participate in staking and contribute to the security of the network.\n\n**Block Rewards:**\nMiners and stakers are rewarded for their efforts to keep the network secure through block rewards. The Verus block reward emission schedule ensures that rewards are distributed fairly and transparently to miners and stakers. This incentivizes participants to continue contributing to the network's security and growth.\n\nOverall, Verus's decentralized economy, mining, and staking ecosystems work together to create a fair and inclusive environment where anyone can participate and contribute to the network's success.", "# Network Economy\nVerus is a rent-free blockchain protocol that has a decentralized economy. Costs for services paid to the protocol are distributed to the miners and stakers. There are no developer fees, and no rent-seeking profiteers.## Mining Ecosystem\nVerus has a naturally decentralized miner ecosystem. VerusHash 2.2 is the mining algorithm that is specifically developed for Verus. The algorithm equalizes mining fairness across hardware classes.To mine Verus no specialized mining equipment is necessary. Anyone can start mining with consumer-grade hardware. Mining is made especially easy for starters, since they can start directly from within Verus Desktop, without any additional software requirements. [Start mining](/economy/start-mining.html).### Merge Mining\nAdditionally, when PBaaS goes live on mainnet, miners can choose to mine up to 22 PBaaS-chains simultaneously, without losing any of their original hashing power.## Staking Ecosystem\nAnyone can start staking Verus, even with the smallest amount possible, e.g. `0.00000001 VRSC`. Although it could take many years before you win a block with such a tiny amount.Verus has a powerful and fair staking system. No threshold required and no registrations necessary. [Start staking](/economy/start-staking.html).## Block Rewards\nMiners and stakers are rewarded for their efforts to keep the network secure. They earn block rewards. The Verus block reward emission schedule:", "./raw_text_input_docs/README_economy.md"]]], [["User:: Hey, I've been curious about the decentralized crowdfund mechanisms in Verus. Can you explain how they work, and what features are available to customize the launch of a new currency or token?", "AI Assistant:: I'd be happy to explain how decentralized crowdfund mechanisms work in Verus and the features available for customizing a new currency or token launch.\n\nIn Verus, decentralized crowdfund mechanisms allow currencies to be launched through a community-driven process. This process involves setting required minimum levels of worldwide participation in one or more preferred currencies. If the minimum participation levels are not met by the start time of the currency or token, all participants will automatically receive a refund of their preconversions, minus network fees.\n\nNow, when it comes to customizing the launch of a new currency or token, Verus provides a range of features to help creators tailor their launch strategy to their specific needs and goals. These features include:\n\n* **Maximum participation**: Setting a maximum limit on participation in one or more currencies to prevent oversubscription.\n* **Pre-launch discounts**: Offering discounts to early participants to incentivize early adoption.\n* **Pre-allocations**: Allocating a portion of the currency or token to select VerusIDs, which can help increase the reserve ratio and issue currencies. These pre-allocations can also include vesting schedules to ensure a gradual release of the allocated funds.\n* **Carve-outs of proceeds**: Setting aside a portion of the launch proceeds for specific purposes, such as funding future development or community initiatives.\n\nThese features provide a high degree of flexibility and customization for currency and token launches on the Verus platform, allowing creators to tailor their launch strategy to their specific needs and goals. By using VerusIDs, launches can also utilize decentralized and transparent mechanisms to ensure a fair and community-driven process.\n\nDo you have any more questions about decentralized crowdfund mechanisms in Verus or the customization options for launching a new currency or token?"], "AI Assistant", "", "N/A", [["How do decentralized crowdfund mechanisms work in Verus, and what features are available to customize the launch of a new currency or token?", "In Verus, decentralized crowdfund mechanisms allow currencies to be launched through a community-driven process. This process involves setting required minimum levels of worldwide participation in one or more preferred currencies. If the minimum participation levels are not met by the start time of the currency or token, all participants will automatically receive a refund of their preconversions, minus network fees.\n\nThe launch options in Verus provide a range of features to customize the launch of a new currency or token. These features include:\n\n* **Maximum participation**: Setting a maximum limit on participation in one or more currencies to prevent oversubscription.\n* **Pre-launch discounts**: Offering discounts to early participants to incentivize early adoption.\n* **Pre-allocations**: Allocating a portion of the currency or token to select VerusIDs, which can help increase the reserve ratio and issue currencies. These pre-allocations can also include vesting schedules to ensure a gradual release of the allocated funds.\n* **Carve-outs of proceeds**: Setting aside a portion of the launch proceeds for specific purposes, such as funding future development or community initiatives.\n\nThese features provide a high degree of flexibility and customization for currency and token launches on the Verus platform, allowing creators to tailor their launch strategy to their specific needs and goals. By using VerusIDs, launches can also utilize decentralized and transparent mechanisms to ensure a fair and community-driven process.", "## Crowdfund mechanisms\nAll currencies can be launched through decentralized crowdfund mechanisms. [Set required minimum levels](/currencies/launch-currency.html#minpreconversion) of worldwide participation in your preferred currencies. If by the start time of your currency or token, minimums are not met, all participants will automatically get a refund of all of their preconversions, less the network fees.\n\nThe launch options also provide for maximum participation in one or more currencies, pre-launch discounts, price neutral [pre-allocations](launch-currency.html#preallocations) to select VerusIDs that increase the reserve ratio to issue currencies, similarly price neutral [carve-outs of proceeds](launch-currency.html#prelaunchcarveout), and [pre-launch discounts](launch-currency.html#prelaunchdiscount) for early participants. Using VerusIDs, launches can also include vesting schedules in the pre-allocations as well.\n\n#", "./raw_text_input_docs/README_currencies.md"]]], [["User:: Hi, I'm interested in creating a basket currency using Verus. Can you walk me through the process and explain some of the options I can use to customize its behavior, such as `prelaunchcarveout`, `prelaunchdiscount`, and `weights`?", "AI Assistant:: Creating a basket currency using Verus is a great way to create a unique financial instrument. I'd be happy to guide you through the process.\n\nTo create a basket currency, you can use the `definecurrency` command with specific options. A basket currency is a type of currency that holds reserves of other currencies, and allows users to preconvert their funds into the new currency before it launches.\n\nHere's an example of how to create a simple basket currency called `BusinessBrand`:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"BusinessBrand\",\n\"options\":33,\n\"currencies\":[\"vrsctest\"],\n\"initialsupply\":100,\n\"prelaunchcarveout\":0.1\n}'\n```\nIn this example, `options`:33 specifies that this is a basket currency. The `currencies` field specifies that the reserves of `BusinessBrand` will be composed of `vrsctest`. The `initialsupply` field sets the initial supply of `BusinessBrand` to 100 units.\n\nThe `prelaunchcarveout` field is used to specify a percentage of the reserves that will be taken out of the reserves and given to the rootID (the creator of the currency) when the currency is launched. In this case, 10% of the reserves will be taken out, which will lower the reserve ratio by 10%.\n\nAnother option you can use when creating a basket currency is `prelaunchdiscount`. This option allows you to give users a discount during the preconversion time frame. After the currency is launched, the conversion price will be higher, depending on the percentage of the discount. For example:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"DiscountBrand\",\n\"options\":33,\n\"currencies\":[\"vrsctest\"],\n\"initialsupply\":100,\n\"prelaunchdiscount\":0.5\n}'\n```\nIn this example, users who preconvert their `vrsctest` into `DiscountBrand` will receive a 50% discount. After the currency is launched, the conversion price will be 50% higher, and the reserve ratio will be 50% lower due to the discount.\n\nFinally, you can use the `weights` option to customize the respective weights of the reserves in a basket currency. The total of all weights must equal 1, and each weight must be at least 0.1, since there can't be more than 10 reserve currencies in a basket currency.\n\nThese options allow you to customize the behavior of your basket currency and create a unique experience for your users.\n\nDo you have any further questions about creating a basket currency, or any of these options in particular?"], "AI Assistant", "", "N/A", [["How can I create a basket currency using Verus, and what are some of the options I can use to customize its behavior, such as `prelaunchcarveout`, `prelaunchdiscount`, and `weights`?", "To create a basket currency using Verus, you can use the `definecurrency` command with specific options. A basket currency is a type of currency that holds reserves of other currencies, and allows users to preconvert their funds into the new currency before it launches.\n\nHere's an example of how to create a simple basket currency called `BusinessBrand`:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"BusinessBrand\", \n \"options\":33, \n \"currencies\":[\"vrsctest\"], \n \"initialsupply\":100, \n \"prelaunchcarveout\":0.1\n}'\n```\nIn this example, `options`:33 specifies that this is a basket currency. The `currencies` field specifies that the reserves of `BusinessBrand` will be composed of `vrsctest`. The `initialsupply` field sets the initial supply of `BusinessBrand` to 100 units.\n\nThe `prelaunchcarveout` field is used to specify a percentage of the reserves that will be taken out of the reserves and given to the rootID (the creator of the currency) when the currency is launched. In this case, 10% of the reserves will be taken out, which will lower the reserve ratio by 10%.\n\nAnother option you can use when creating a basket currency is `prelaunchdiscount`. This option allows you to give users a discount during the preconversion time frame. After the currency is launched, the conversion price will be higher, depending on the percentage of the discount. For example:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"DiscountBrand\", \n \"options\":33, \n \"currencies\":[\"vrsctest\"], \n \"initialsupply\":100, \n \"prelaunchdiscount\":0.5\n}'\n```\nIn this example, users who preconvert their `vrsctest` into `DiscountBrand` will receive a 50% discount. After the currency is launched, the conversion price will be 50% higher, and the reserve ratio will be 50% lower due to the discount.\n\nFinally, you can use the `weights` option to customize the respective weights of the reserves in a basket currency. The total of all weights must equal 1, and each weight must be at least 0.1, since there can't be more than 10 reserve currencies in a basket currency.\n\nThese options allow you to customize the behavior of your basket currency and create a unique experience for your users.", "Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"BusinessBrand\", \n \"options\":33, \n \"currencies\":[\"vrsctest\"], \n \"initialsupply\":100, \n \"prelaunchcarveout\":0.1\n}'\n```\n\u261d\ufe0f This is a basket currency called BusinessBrand. People can preconvert VRSCTEST into its reserves in return for 100 BusinessBrand distributed among them. When the currency is launched, 10% VRSCTEST is taken out of the reserves, into the rootID. This lowers the reserve ratio by 10%.### **\"prelaunchdiscount\"**\nOnly works with basket currencies (`options:33`). Use this to give people a discount during the preconversion time frame. After the preconversion time frame and the currency is launched, the conversion price will be higher, depending on what percentage the discount was.When using this parameter, after the currency is launched, the reserve ratio will be lowered by the discounted percentage.Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"DiscountBrand\", \n \"options\":33, \n \"currencies\":[\"vrsctest\"], \n \"initialsupply\":100, \n \"prelaunchdiscount\":0.5\n}'\n```\n\u261d\ufe0f This is a basket currency called DiscountBrand. People can preconvert VRSCTEST into its reserves in return for 100 DiscountBrand distributed among them. Immediately after the launch of the currency, when people want to convert, the price is 50% higher. Also, the reserve ratio is 50% lower because of the prelaunchdiscount.### **\"weights\"**\nOnly works with basket currencies (`options:33`). Use this to change the respective weights of the reserves in a basket currency. The total of all weights must equal 1. With a minimum of 0.1, since there can\u2019t be more than 10 reserve currencies in a basket currency.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: Hey, I've been trying to understand the Verus blockchain network, and I'm not quite clear on the Transfer Destination construct. Can you explain what it is, and how it supports various blockchain transactions and cross-chain interactions?", "AI Assistant:: The Transfer Destination construct is a fundamental component in the Verus blockchain network, and it's great that you're interested in learning more about it.\n\nThe Transfer Destination construct is designed to define destinations within blockchain operations comprehensively. This construct plays a crucial role in specifying the end points in a variety of blockchain transactions, supporting a wide array of destination types to accommodate diverse blockchain functionalities and cross-chain interactions.\n\nAt its core, the Transfer Destination construct encapsulates key information necessary for blockchain transactions. This includes the destination type, destination-specific bytes, gateway information, and associated fees. This comprehensive encapsulation enables the Transfer Destination to support a flexible architecture for defining complex transaction paths, which in turn enhances the blockchain's capability to handle sophisticated and multi-layered operations.\n\nOne of the key aspects of the Transfer Destination construct is its support for various destination types, each serving specific purposes. These destination types can be used to define different end points for blockchain transactions, allowing for a high degree of flexibility and customization. By supporting a range of destination types, the Transfer Destination construct enables the Verus blockchain network to accommodate a wide range of use cases and applications, from simple transactions to complex, multi-layered operations.\n\nIn summary, the Transfer Destination construct is a critical component of the Verus blockchain network, providing a flexible and comprehensive way to define destinations within blockchain operations. Its support for various destination types and its ability to encapsulate key information necessary for blockchain transactions make it an essential element in the Verus ecosystem.\n\nDo you have any further questions about the Transfer Destination construct, or how it supports various blockchain transactions and cross-chain interactions?"], "AI Assistant", "", "N/A", [["What is the Transfer Destination construct in the Verus blockchain network, and how does it support various blockchain transactions and cross-chain interactions?", "The Transfer Destination construct is a fundamental component in the Verus blockchain network, designed to define destinations within blockchain operations comprehensively. This construct plays a crucial role in specifying the end points in a variety of blockchain transactions, supporting a wide array of destination types to accommodate diverse blockchain functionalities and cross-chain interactions.\n\nAt its core, the Transfer Destination construct encapsulates key information necessary for blockchain transactions. This includes the destination type, destination-specific bytes, gateway information, and associated fees. This comprehensive encapsulation enables the Transfer Destination to support a flexible architecture for defining complex transaction paths, which in turn enhances the blockchain's capability to handle sophisticated and multi-layered operations.\n\nOne of the key aspects of the Transfer Destination construct is its support for various destination types, each serving specific purposes. These destination types can be used to define different end points for blockchain transactions, allowing for a high degree of flexibility and customization. By supporting a range of destination types, the Transfer Destination construct enables the Verus blockchain network to accommodate a wide range of use cases and applications, from simple transactions to complex, multi-layered operations.\n\nIn summary, the Transfer Destination construct is a critical component of the Verus blockchain network, providing a flexible and comprehensive way to define destinations within blockchain operations. Its support for various destination types and its ability to encapsulate key information necessary for blockchain transactions make it an essential element in the Verus ecosystem.", "# Transfer DestinationThe Transfer Destination construct is a universal component used within the Verus blockchain network, designed to define destinations within blockchain operations comprehensively. This construct is crucial for specifying the end points in a variety of blockchain transactions, supporting a wide array of destination types to accommodate diverse blockchain functionalities and cross-chain interactions.## Core ConceptsTransfer Destination encapsulates key information necessary for blockchain transactions, including the destination type, destination-specific bytes, gateway information, and associated fees. It supports a flexible architecture for defining complex transaction paths, enhancing the blockchain's capability to handle sophisticated and multi-layered operations.### Destination TypesThe Transfer Destination construct supports various destination types, each serving specific purposes:", "./raw_text_input_docs/transfer-destination.md"]]], [["User:: Hey, I'm having some trouble with my VerusID and I need some help. How do I request an unlock on my VerusID using the `setidentitytimelock` command, and what does the `unlockatblock` parameter do?", "AI Assistant:: The `setidentitytimelock` command can be a bit tricky, but I'm here to help you out.\n\nTo request an unlock on your VerusID, you can use the `setidentitytimelock` command in the Verus Desktop command-line interface. This command allows you to set a time lock on your identity, which can be useful for various purposes.\n\nThe `unlockatblock` parameter is an important part of this command. It specifies the block height at which the time lock should be removed, allowing you to regain access to your identity. To request an unlock, you need to know the current block height of the blockchain.\n\nHere's how it works: if the current block height is, for example, 1,000,000, you can set `unlockatblock` to 999,999 or simply 0. Setting it to 0 is recommended, as it will immediately request an unlock.\n\nHere's an example of the command you would use:\n```json\nrun setidentitytimelock \"myid@\"\n'{\n\"unlockatblock\":0\n}'\n```\nJust replace \"myid@\" with your actual VerusID, and you're good to go! This command will request an unlock on your identity, and once the specified block height is reached, the time lock will be removed, and you'll regain access to your identity.\n\nRemember to always be careful when using the `setidentitytimelock` command, as it can have significant consequences for your identity and its associated assets. Make sure you understand the implications of using this command before proceeding.\n\nDo you have any other questions about using the `setidentitytimelock` command or working with VerusIDs in general?"], "AI Assistant", "", "N/A", [["How do I request an unlock on my VerusID using the `setidentitytimelock` command, and what does the `unlockatblock` parameter do?", "To request an unlock on your VerusID, you can use the `setidentitytimelock` command in the Verus Desktop command-line interface. This command allows you to set a time lock on your identity, which can be useful for various purposes.\n\nThe `unlockatblock` parameter is an important part of this command. It specifies the block height at which the time lock should be removed, allowing you to regain access to your identity. To request an unlock, you need to know the current block height of the blockchain.\n\nHere's how it works: if the current block height is, for example, 1,000,000, you can set `unlockatblock` to 999,999 or simply 0. Setting it to 0 is recommended, as it will immediately request an unlock.\n\nHere's an example of the command you would use:\n```json\nrun setidentitytimelock \"myid@\" \n'{\n  \"unlockatblock\":0\n}'\n```\nJust replace \"myid@\" with your actual VerusID, and you're good to go! This command will request an unlock on your identity, and once the specified block height is reached, the time lock will be removed, and you'll regain access to your identity.\n\nRemember to always be careful when using the `setidentitytimelock` command, as it can have significant consequences for your identity and its associated assets. Make sure you understand the implications of using this command before proceeding.", "To request an unlock you need to know the blockheight of the blockchain. Under ``unlockatblock`` you can fill in whatever the current blockheight is minus 1. So if the blockheight is at 1,000,000 you can fill in ``999999`` or just ``0`` (recommended) to immediately request an unlock.\n\n``` json\nrun setidentitytimelock \"myid@\" \n'{\n  \"unlockatblock\":0\n}'\n```\n\nYou can copy and paste this code snippet into the commandline interface of Verus Desktop and edit the necessary inputs for your needs.", "./raw_text_input_docs/setup-vault-v2.md"]]], [["User:: I'm interested in staking on the Verus blockchain, but I'm not sure how it works or what the requirements are. Can you explain the requirements and options for staking on the Verus blockchain?", "AI Assistant:: Staking is a great way to secure the Verus network and earn rewards by using your Verus holdings. Anyone can participate in staking, regardless of the amount of VRSC they hold, as there are no minimum requirements to start staking.\n\nTo help you understand staking on the Verus blockchain, let me break it down for you. On the Verus blockchain, it's not the balance that's staking, but rather the Unspent Transaction Outputs (UTXOs). A larger UTXO has a higher chance of winning a block than a smaller one. To clarify, a UTXO is an unspent transaction output that is available to be used as input for a new transaction.\n\nThere are two main ways to stake on the Verus network: solo staking and pool staking.\n\n**Solo Staking:**\nTo start solo staking, you need to meet the following requirements:\n\n1. Your wallet must be running.\n2. You need a full node, which can be achieved by running Verus Desktop in native mode.\n3. Staking must be enabled.\n4. Your UTXO must be eligible, which happens after 150 blocks.\n5. You need a minimum of 0.00000001 VRSC in your wallet.\n\nIn solo staking, you either win a full block or you win nothing. If you need help with solo staking, you can join the Verus Discord #staking channel, where the community is happy to assist.\n\n**Pool Staking:**\nPool staking offers two options:\n\n1. Non-custodial staking pool: This option allows you to keep control over your funds in combination with VerusID. An example of a non-custodial staking pool is Synergy Pool.\n2. Custodial staking pool: This option involves sending your coins to a pool operator and trusting them with your funds.\n\nIn both cases, pool staking allows you to combine your resources with others to increase your chances of winning blocks and earning rewards.\n\nDo you have any further questions about staking on the Verus blockchain, or would you like more information on solo staking or pool staking?"], "AI Assistant", "", "N/A", [["What are the requirements and options for staking on the Verus blockchain, and how does it work?", "Staking is a way to secure the Verus network and earn rewards by using your Verus holdings. Anyone can participate in staking, regardless of the amount of VRSC they hold, as there are no minimum requirements to start staking.\n\nOn the Verus blockchain, it's not the balance that's staking, but rather the Unspent Transaction Outputs (UTXOs). A larger UTXO has a higher chance of winning a block than a smaller one. To clarify, a UTXO is an unspent transaction output that is available to be used as input for a new transaction.\n\nThere are two main ways to stake on the Verus network: solo staking and pool staking.\n\n**Solo Staking:**\nTo start solo staking, you need to meet the following requirements:\n\n1. Your wallet must be running.\n2. You need a full node, which can be achieved by running Verus Desktop in native mode.\n3. Staking must be enabled.\n4. Your UTXO must be eligible, which happens after 150 blocks.\n5. You need a minimum of 0.00000001 VRSC in your wallet.\n\nIn solo staking, you either win a full block or you win nothing. If you need help with solo staking, you can join the Verus Discord #staking channel, where the community is happy to assist.\n\n**Pool Staking:**\nPool staking offers two options:\n\n1. Non-custodial staking pool: This option allows you to keep control over your funds in combination with VerusID. An example of a non-custodial staking pool is Synergy Pool.\n2. Custodial staking pool: This option involves sending your coins to a pool operator and trusting them with your funds.\n\nIn both cases, pool staking allows you to combine your resources with others to increase your chances of winning blocks and earning rewards.", "# Staking\n\nStaking is accessible for everyone. Use Verus holdings to secure the network. It does not matter how much $VRSC you have, there are no minimum requirements to start staking.\n\nOn the Verus blockchain UTXOs (unspent transaction outputs) are staking, not balances. A large UTXO has more chances of winning a block than a small UTXO. [What is a UTXO?](https://www.youtube.com/watch?v=xJ0UYZ9hDos)\n\n## Solo staking\nThere are a few rules you need to know before you can start staking.\n\n| Rules | \n| :-----|\n| Wallet Running | \n| Full Node Required (native mode in Verus Desktop) | \n| Staking Enabled | \n| UTXO Eligible After 150 Blocks | \n| Minimum of 0.00000001 VRSC in Wallet |\n\nWith solo staking you either win a full block or you win nothing.\n\n::: warning Need help with staking? \ud83d\udcb0\n[Join the Verus Discord #staking channel. The community is happy to assist!](https://www.verus.io/discord). \n:::\n\n## Pool staking\nThere are two ways to do pool staking with Verus. One is keeping control over your funds in combination with VerusID, the other is sending your coins to a pool operator and trusting your funds with them.\n\nA non-custodial staking pool: [Synergy Pool](https://synergopool.io)", "./raw_text_input_docs/start-staking.md"]]], [["User:: I've been trying to wrap my head around currencies in Verus. Can you explain the different options for defining a currency in Verus, and how they affect the behavior of the currency?", "AI Assistant:: Defining a currency in Verus can be a bit complex, but I'd be happy to break it down for you.\n\nWhen defining a currency in Verus, you can specify an `options` parameter that determines the type of currency and its behavior. There are three main options:\n\n**Option 1: Decentralized Currency**\nOption `1` is the default and launches a decentralized currency. When subIDs are created with this option, the registration fees are burned. This means that the currency is not controlled by a central authority and operates independently.\n\n**Option 2: Centralized Currency**\nOption `2` is for a centralized currency. In this case, the rootID can mint and burn supply, and anyone can burn supply without lowering the reserve ratio. If it's a basket currency, the rootID can also automatically lower and raise the reserve ratio. The subID registration fees go to the rootID. This means that the currency is controlled by a central authority, which has the power to manage the supply of the currency.\n\n**Option 3: Ethereum ERC-20 Mapped Tokens**\nOption `3` is for Ethereum ERC-20 mapped tokens. This option allows for the creation of tokens that are mapped to Ethereum ERC-20 tokens.\n\nIn addition to the `options` parameter, you can also specify other parameters when defining a currency. For example, you can specify `currencies` which lists the names of the currencies that will be in the reserves when it's a basket currency. You can also specify `preallocations` which allocates a certain amount of tokens to a specific address. You can also use `conversions` to determine the preconversion price when it's a simple token currency.\n\nLet me give you an example to make it more concrete. Here's an example of how to define a simple token currency called MyBrand, which is centralized and has a preallocation of 100 tokens to Klaus@:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n\"name\":\"MyBrand\",\n\"options\":32,\n\"proofprotocol\":2,\n\"preallocations\":[{\"Klaus@\":100}]\n}'\n```\nIn this example, the `options` parameter is set to `32`, which means it's a simple token currency. The `proofprotocol` is set to `2`, which means it's a centralized currency. The `preallocations` parameter allocates 100 tokens to Klaus@.\n\nDo you have any further questions about defining currencies in Verus or how these options affect the behavior of the currency?"], "AI Assistant", "", "N/A", [["What are the different options for defining a currency in Verus, and how do they affect the behavior of the currency?", "When defining a currency in Verus, you can specify an `options` parameter that determines the type of currency and its behavior. There are three main options:\n\n**Option 1: Decentralized Currency**\nOption `1` is the default and launches a decentralized currency. When subIDs are created with this option, the registration fees are burned. This means that the currency is not controlled by a central authority and operates independently.\n\n**Option 2: Centralized Currency**\nOption `2` is for a centralized currency. In this case, the rootID can mint and burn supply, and anyone can burn supply without lowering the reserve ratio. If it's a basket currency, the rootID can also automatically lower and raise the reserve ratio. The subID registration fees go to the rootID. This means that the currency is controlled by a central authority, which has the power to manage the supply of the currency.\n\n**Option 3: Ethereum ERC-20 Mapped Tokens**\nOption `3` is for Ethereum ERC-20 mapped tokens. This option allows for the creation of tokens that are mapped to Ethereum ERC-20 tokens.\n\n**Additional Parameters**\nIn addition to the `options` parameter, you can also specify other parameters when defining a currency. For example, you can specify `currencies` which lists the names of the currencies that will be in the reserves when it's a basket currency. You can also specify `preallocations` which allocates a certain amount of tokens to a specific address. You can also use `conversions` to determine the preconversion price when it's a simple token currency.\n\n**Example**\nHere's an example of how to define a simple token currency called MyBrand, which is centralized and has a preallocation of 100 tokens to Klaus@:\n```json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBrand\", \n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Klaus@\":100}]\n}'\n```\nIn this example, the `options` parameter is set to `32`, which means it's a simple token currency. The `proofprotocol` is set to `2`, which means it's a centralized currency. The `preallocations` parameter allocates 100 tokens to Klaus@.", "``1`` is default, which launches a decentralized currency (no need to include this parameter when defining such a currency). When subIDs are created with this option, the registration fees are burned.``2`` is for a centralized currency. If it\u2019s a basket currency the rootID can mint and burn supply while automatically lowering and raising the reserve ratio (also anyone can burn supply without lowering the reserve ratio). Or when it\u2019s a simple token currency they can just mint and burn supply. The subID registration fees go to the rootID.``3`` is for Ethereum ERC-20 mapped tokens. [Read more](/currencies/mapping-1:1-eth)Example currency:\n``` json\n./verus -chain=VRSCTEST definecurrency '{\n \"name\":\"MyBrand\", \n \"options\":32, \n \"proofprotocol\":2, \n \"preallocations\":[{\"Klaus@\":100}]\n}'\n```\n\u261d\ufe0f A simple token currency called MyBrand, centralized (the controller of the rootID can mint and burn), and has a preallocation of 100 tokens to Klaus@.### **\"currencies\"**\nHere you put the names of the currencies (or just one \u2014 it must have VRSC when launched on Verus) that will be in the reserves when it\u2019s a basket currency (`options:33`).Or when it\u2019s a simple token currency (`options:32`), what people convert during the preconversion timeframe will go to the rootID of the currency, as a funding mechanism. In the case of a simple token currency, combine it with `\"conversions\"` to determine the preconversion price.Use up to 10 currencies for this parameter.", "./raw_text_input_docs/launch-currency.md"]]], [["User:: I'm trying to understand how VerusPay makes it possible to share invoices across different systems and languages. Can you explain how it enables efficient transmission and storage of invoices, and how these invoices can be packaged into deeplinks and QR codes readable by wallets like Verus Mobile?", "AI Assistant:: VerusPay has a clever solution for this. To enable efficient transmission and storage of invoices across different systems and languages, VerusPay uses a standardized approach to serialize and deserialize VerusPay Invoices and VerusPay InvoiceDetails into a binary format. This serialization process ensures that invoices can be shared, processed, and stored consistently across various platforms without losing any fidelity or meaning.\n\nNow, to package a VerusPay Invoice into a deeplink or QR code readable by wallets like Verus Mobile, the invoice must first be serialized using the standardized method, excluding its 20-byte VDXF key. The resulting bytes are then formatted into a base64url string. Next, a deeplink URL can be created by combining the following components:\n\n* The prefix `[vrsc::applications.wallet VDXF ID]://x-callback-url/`\n* The VerusPay invoice bytes in base64url format\n* The suffix `[veruspay.vrsc::invoice VDXF ID]`\n\nThis creates a deeplink URL, such as `i5jtwbp6zymeay9llnraglgjqgdrffsau4://x-callback-url/iEETy7La3FTN2Sd2hNRgepek5S8x8eeUeQ/AzABpJ-uxwACFAAtMxHDi_0hkJLSrvRJgEvos77-pu-eojVjXjKBJP80KdufnpG2Ti0`, which can then be packaged into a QR code. This QR code can be scanned by a VerusPay supporting wallet application, or linked to by an application or service to trigger an invoice request.\n\nDo you have any further questions about VerusPay, or how it enables the efficient transmission and storage of invoices?"], "AI Assistant", "", "N/A", [["How does VerusPay enable efficient transmission and storage of invoices across different systems and languages, and how can these invoices be packaged into deeplinks and QR codes readable by wallets like Verus Mobile?", "VerusPay uses a standardized approach to serialize and deserialize VerusPay Invoices and VerusPay InvoiceDetails into a binary format, allowing for efficient transmission and storage of invoices across different systems and languages without loss of fidelity or meaning. This serialization process ensures that invoices can be shared, processed, and stored consistently across various platforms.\n\nTo package a VerusPay Invoice into a deeplink or QR code readable by wallets like Verus Mobile, the invoice must first be serialized using the standardized method, excluding its 20-byte VDXF key. The resulting bytes are then formatted into a base64url string. Next, a deeplink URL can be created by combining the following components:\n\n* The prefix `[vrsc::applications.wallet VDXF ID]://x-callback-url/`\n* The VerusPay invoice bytes in base64url format\n* The suffix `[veruspay.vrsc::invoice VDXF ID]`\n\nThis creates a deeplink URL, such as `i5jtwbp6zymeay9llnraglgjqgdrffsau4://x-callback-url/iEETy7La3FTN2Sd2hNRgepek5S8x8eeUeQ/AzABpJ-uxwACFAAtMxHDi_0hkJLSrvRJgEvos77-pu-eojVjXjKBJP80KdufnpG2Ti0`, which can then be packaged into a QR code. This QR code can be scanned by a VerusPay supporting wallet application, or linked to by an application or service to trigger an invoice request.", "The specification emphasizes a standardized approach to converting the VerusPay Invoice and VerusPay InvoiceDetails into a binary format (serialization) and back (deserialization) to enable efficient transmission and storage. This process ensures that invoices can be shared, processed, and stored across different systems and languages without loss of fidelity or meaning.\n\n### Packaging into Deeplinks and QR Codes\n\nTo package a VerusPay Invoice into a deeplink or QR code readable by wallets like [Verus Mobile](https://github.com/VerusCoin/Verus-Mobile), the invoice must be serialized using the method described above, without its 20-byte [VDXF](/vdxf/) key included, and then its bytes formatted into a base64url string. Then, a deeplink URL can be created as follows:\n\n```[vrsc::applications.wallet VDXF ID]://x-callback-url/[veruspay.vrsc::invoice VDXF ID]/[VerusPay invoice bytes in base64url format]```\n\nIn practice, this creates URLs such as `i5jtwbp6zymeay9llnraglgjqgdrffsau4://x-callback-url/iEETy7La3FTN2Sd2hNRgepek5S8x8eeUeQ/AzABpJ-uxwACFAAtMxHDi_0hkJLSrvRJgEvos77-pu-eojVjXjKBJP80KdufnpG2Ti0`, which can then be packaged into a QR code and scanned by a VerusPay supporting wallet application, or linked to by an application or service to trigger an invoice request.", "./raw_text_input_docs/invoices.md"]]], [["User:: I'm trying to export a currency from Verus to Ethereum as an ERC-20 using the Verus-Ethereum Bridge. Can you walk me through the process and explain the key components of the command to do so?", "AI Assistant:: Exporting a currency from Verus to Ethereum as an ERC-20 is a straightforward process using the Verus-Ethereum Bridge. This bridge enables seamless transfer of funds between Verus and Ethereum, allowing you to utilize your currency in the larger Ethereum ecosystem.\n\nTo export a currency, you'll need to use the `sendcurrency` command with specific parameters. Here's a breakdown of the command:\n\n```json\n./verus -chain=VRSCTEST sendcurrency \"myVerusID@\" '[{\n\"address\":\"0x85a7dE2278E52327471e174AeeB280cdFdC6A68a\",\n\"currency\":\"myCurrency\",\n\"amount\":0,\n\"exportto\":\"veth\",\n\"exportcurrency\":true,\n\"feecurrency\":\"veth\"\n}]'\n```\n\nLet's examine the key components of this command:\n\n* `myVerusID@` is the from- and change-address, which can be a VerusID, R-address, or i-address. The fee for the export will be deducted from this address, and any excess fees will be refunded to this address.\n* `address` is an Ethereum address, which can be any valid ETH address. Note that the specific address used here is not crucial.\n* `currency` is the name of the currency you wish to export as an ERC-20, such as `MyCurrency` or `MyCurrency.vETH`.\n* `amount` is set to 0, as you're not sending a specific amount of the currency, but rather exporting the currency itself as an ERC-20.\n* `exportto` specifies the target chain, which in this case is `veth` (Verus-Ethereum).\n* `exportcurrency` is a boolean flag indicating that you want to export the currency as an ERC-20.\n* `feecurrency` specifies the currency to be used for paying the fees, which in this case is also `veth`.\n\nAfter executing this command, you'll need to wait for the bridge to be notarized to the block height where you exported the currency. Once notarized, you can select your exported ERC-20 currency from the token dropdown on the Verus-Ethereum Bridge website (either mainnet or Goerli testnet, depending on your setup).\n\nBy following these steps, you can successfully export a currency from Verus to Ethereum as an ERC-20, opening up new possibilities for using your currency in the Ethereum ecosystem.\n\nDo you have any questions about this process or the command parameters?"], "AI Assistant", "", "N/A", [["How can I export a currency from Verus to Ethereum as an ERC-20 using the Verus-Ethereum Bridge, and what are the key components of the command to do so?", "Exporting a currency from Verus to Ethereum as an ERC-20 is a straightforward process using the Verus-Ethereum Bridge. This bridge enables seamless transfer of funds between Verus and Ethereum, allowing you to utilize your currency in the larger Ethereum ecosystem.\n\nTo export a currency, you'll need to use the `sendcurrency` command with specific parameters. Here's a breakdown of the command:\n\n```json\n./verus -chain=VRSCTEST sendcurrency \"myVerusID@\" '[{\n  \"address\":\"0x85a7dE2278E52327471e174AeeB280cdFdC6A68a\", \n  \"currency\":\"myCurrency\", \n  \"amount\":0, \n  \"exportto\":\"veth\", \n  \"exportcurrency\":true, \n  \"feecurrency\":\"veth\"\n}]'\n```\n\nLet's examine the key components of this command:\n\n* `myVerusID@` is the from- and change-address, which can be a VerusID, R-address, or i-address. The fee for the export will be deducted from this address, and any excess fees will be refunded to this address.\n* `address` is an Ethereum address, which can be any valid ETH address. Note that the specific address used here is not crucial.\n* `currency` is the name of the currency you wish to export as an ERC-20, such as `MyCurrency` or `MyCurrency.vETH`.\n* `amount` is set to 0, as you're not sending a specific amount of the currency, but rather exporting the currency itself as an ERC-20.\n* `exportto` specifies the target chain, which in this case is `veth` (Verus-Ethereum).\n* `exportcurrency` is a boolean flag indicating that you want to export the currency as an ERC-20.\n* `feecurrency` specifies the currency to be used for paying the fees, which in this case is also `veth`.\n\nAfter executing this command, you'll need to wait for the bridge to be notarized to the block height where you exported the currency. Once notarized, you can select your exported ERC-20 currency from the token dropdown on the Verus-Ethereum Bridge website (either mainnet or Goerli testnet, depending on your setup).\n\nBy following these steps, you can successfully export a currency from Verus to Ethereum as an ERC-20, opening up new possibilities for using your currency in the Ethereum ecosystem.", "# Export currency to Ethereum (as ERC-20)\n\nAny currency on Verus can be exported to Ethereum as an ERC-20. The currency can then be used in the complete Ethereum ecosystem, and on the Verus network. Sending to and from Verus and Ethereum couldn't be easier. [More on the Verus-Ethereum Bridge.](/eth-bridge/)\n\n::: tip \u2194\ufe0f Verus-Ethereum Bridge \ud83d\udc68\u200d\ud83d\udd27 For Testnet!\n[\ud83d\udc49 Access the Verus-Ethereum Testnet Bridge](https://ethbridge.verustest.net/) (\u26a0\ufe0f Goerli testnet)\n:::\n\n::: tip \u2194\ufe0f Verus-Ethereum Bridge \u2705 For Mainnet!\n[\ud83d\udc49 Access the Verus-Ethereum Mainnet Bridge](https://eth.verusbridge.io)\n:::\n\n### Exporting the currency\nNow, let\u2019s export a currency from Verus to Ethereum as an ERC-20 over the non-custodial bridge. We must have enough funds to pay for the export.\n\nThe command to export a currency to Ethereum as an ERC-20:\n\n``` json\n./verus -chain=VRSCTEST sendcurrency \"myVerusID@\" '[{\n  \"address\":\"0x85a7dE2278E52327471e174AeeB280cdFdC6A68a\", \n  \"currency\":\"myCurrency\", \n  \"amount\":0, \n  \"exportto\":\"veth\", \n  \"exportcurrency\":true, \n  \"feecurrency\":\"veth\"\n}]'\n```\n\nLet's break the command down with what you can change.\n\n**``myVerusID@``** is the from- and change-address. Can be a VerusID, R-address or i-address. The fee to pay for the export comes from here, and if you paid too much fees the rest will be returned here.\n\n**``address``** You can fill in any ETH-address here, it is actually not important what is here.\n\n**``currency``** is the name of the currency you wish to export as an ERC-20. E.g. `MyCurrency`, `MyCurrency.vETH`.\n\n### Wait for notarization\n\nAfter the bridge has been notarized to the blockheight where you have exported the currency, you can choose it from the token dropdown on the [Bridge website mainnet](https://eth.verusbridge.io) or [Bridge website Goerli testnet](https://ethbridge.verustest.net/)", "./raw_text_input_docs/export-to-eth.md"]]], [["User:: Hi, I'm trying to understand the economics behind Verus. Can you explain the block reward and coin emission schedule of Verus, as well as the fees associated with different activities on the platform?", "AI Assistant:: The block reward and coin emission schedule of Verus are designed to incentivize miners and stakers to secure the network and validate transactions.\n\nThe schedule is divided into several phases, each with a decreasing block reward. The block reward starts at 384 VRSC and halves approximately every 6 months, with the last phase having a block reward of 0.00292968 VRSC.\n\nThe total maximum circulating supply of all coins is capped at 83,540,184 VRSC. In addition to the block reward, Verus also generates fees from various activities on the platform, such as:\n\n* VerusID registration: 20-100 VRSC\n* PBaaS-chain launch: 10,000 VRSC (with half going to the miners and stakers of the newly launched PBaaS-chain)\n* Currency/Token launch: 200 VRSC\n* Conversion fee: 0.025% or 0.05%\n* Transaction fee: 0.0001 VRSC\n\nThese fees are earned by miners and stakers and are an additional incentive for them to participate in the network. The fees are also used to compensate for the resources required to process transactions and maintain the network.\n\nIt's worth noting that the block rewards of 384 and 192 VRSC were timelocked and then unlocked at random block heights, with the last of those rewards being unlocked at block height 1,181,520.\n\nDo you have any further questions about the block reward and coin emission schedule, or the fees associated with different activities on the platform?"], "AI Assistant", "", "N/A", [["Can you explain the block reward and coin emission schedule of Verus, as well as the fees associated with different activities on the platform?", "In Verus, the block reward and coin emission schedule are designed to incentivize miners and stakers to secure the network and validate transactions. The schedule is divided into several phases, each with a decreasing block reward. The block reward starts at 384 VRSC and halves approximately every 6 months, with the last phase having a block reward of 0.00292968 VRSC.\n\nThe total maximum circulating supply of all coins is capped at 83,540,184 VRSC. In addition to the block reward, Verus also generates fees from various activities on the platform, such as:\n\n* VerusID registration: 20-100 VRSC\n* PBaaS-chain launch: 10,000 VRSC (with half going to the miners and stakers of the newly launched PBaaS-chain)\n* Currency/Token launch: 200 VRSC\n* Conversion fee: 0.025% or 0.05%\n* Transaction fee: 0.0001 VRSC\n\nThese fees are earned by miners and stakers and are an additional incentive for them to participate in the network. The fees are also used to compensate for the resources required to process transactions and maintain the network.\n\nIt's worth noting that the block rewards of 384 and 192 VRSC were timelocked and then unlocked at random block heights, with the last of those rewards being unlocked at block height 1,181,520.", "| Block Height (& Start Date) | Block Rewards | Coin Emission | \n| -------------: | ----------:| --------------:| \n| 1 (5.21.2018) | 0 - 384 | 485,000 VRSC| \n| 10,080 (5.28.2018)| 384* | 16,589,000 VRSC| \n| 53,280 (6.28.2018)| 192* | 8,294,000 VRSC| \n| 96,480 (7.28.2018)| 96 | 4,147,200 VRSC|\n| 139,680 (8.28.2018)| 48 | 2,073,600 VRSC|\n| 226,080 (9.28.2018) | 24 | 25,282,880 VRSC|\n| 1,278,000 (11.22.2020)| 12 | 12,623,040 VRSC|\n| 2,329,920 (12.17.2022)| 6 | 6,311,520 VRSC|\n| 3,381,840 (~1.9.2025)| 3 | 3,155,760 VRSC|\n| 4,433,760 (~ 2027)| 1.5 | 1,577,880 VRSC|\n| 5,485,680 (~ 2029)| 0.75 | 788,940 VRSC|\n| 6,537,600 (~ 2031) | 0.375 | 394,470 VRSC|\n| 7,589,520 (~ 2033) | 0.1875 | 197,235 VRSC|\n| 8,641,440 (~ 2035) | 0.09375 | 98,618 VRSC|\n| 9,693,360 (~ 2037) | 0.0486875 | 49,309 VRSC|\n| 10,745,280 (~ 2039) | 0.0234375 | 24,655 VRSC|\n| 11,797,200 (~ 2041) | 0.01171875 | 12,327 VRSC|\n| 12,849,120 (~ 2043) | 0.00585937 | 6,164 VRSC|\n| 13,901,040 (~ 2045) | 0.00292968 | 3,082 VRSC|\n| etc. | ... | ... | ... |The maximum circulating supply of all coins is 83,540,184 VRSC.\n::: tip * 384, 192 Block Rewards \u23f2\ufe0f\nFrom block height 10,080 on, all block rewards of 384 and 192 VRSC were timelocked and then unlocked at random block heights. The last of those rewards were unlocked at block height 1,181,520.\n:::## Block Fees\n Fees are generated from users paying for services and interacting with the protocol. These fees are processed in the blocks and earned by miners and stakers.| Protocol Activity | Fees | \n| :------------- | -------------:| \n| VerusID Registration | 20 - 100 VRSC |\n| PBaaS-chain Launch| 10,000 VRSC** |\n| Currency/Token Launch | 200 VRSC |\n| Conversion Fee | 0.025%, 0.05% |\n| Transaction Fee | 0.0001 VRSC  |_**Half the fee (5000) goes to the miners and stakers of the newly launched PBaaS-chain._", "./raw_text_input_docs/README_economy.md"]]]]