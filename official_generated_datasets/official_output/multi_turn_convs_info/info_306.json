[
    [
        [
            "How do I sign transactions from multi-signature IDs on both testnet and mainnet using Verus?",
            "To sign transactions from multi-signature IDs on both testnet and mainnet using Verus, you need to:\n\n1. Create a transaction and get the raw transaction data using `sendcurrency` and `z_getoperationstatus`.\n2. Take the raw hex transaction data to each additional wallet containing the additional signing addresses/IDs and sign it using `signrawtransaction`.\n3. After the last necessary signature is applied, broadcast the transaction on the network using `sendrawtransaction`.\n\nThis process ensures that the transaction is properly signed by all required parties before it is broadcast to the network.",
            "#### Defining a PBaaS blockchain ```json  {  \"name\": \"PBaaSChain\",  \"options\": 264,  \"currencies\": [   \"VRSCTEST\"  ],  \"conversions\": [   1  ],  \"eras\": [   {    \"reward\": 1200000000,    \"decay\": 0,    \"halving\": 0,    \"eraend\": 0   }  ],  \"notaries\": [   \"Notary1@\",   \"Notary2@\",   \"Notary3@\"  ],  \"minnotariesconfirm\": 2,  \"nodes\": [   {    \"networkaddress\": \"111.111.111.111:10000\",    \"nodeidentity\": \"Node1@\"   },   {    \"networkaddress\": \"111.111.111.112:10000\",    \"nodeidentity\": \"Node2@\"   }  ],  \"gatewayconvertername\": \"Bridge\",  \"gatewayconverterissuance\": 1000000 } ``` The bridge definition has overridable defaults ```json  {  \"currencies\": [   \"VRSCTEST\",   \"PBaaSChain\",   \"USD\"  ],  \"initialcontributions\": [   380228.12033701,   0,   1000000  ],  \"initialsupply\": 3000000 } ```Now pass those definitions to `definecurrency` ```shell ./verus -chain=vrsctest definecurrency '{\"name\":\"PBaaSChain\",\"options\":264,\"currencies\":[\"VRSCTEST\"],\"conversions\":[1],\"eras\":[{\"reward\":1200000000,\"decay\":0,\"halving\":0,\"eraend\":0}],\"notaries\":[\"Notary1@\",\"Notary2@\",\"Notary3@\"],\"minnotariesconfirm\":2,\"nodes\":[{\"networkaddress\":\"111.111.111.111:10000\",\"nodeidentity\":\"Node1@\"},{\"networkaddress\":\"111.111.111.112:10000\",\"nodeidentity\":\"Node2@\"}],\"gatewayconvertername\":\"Bridge\",\"gatewayconverterissuance\":1000000}' '{\"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\"initialcontributions\":[371747.20398827,0,1000000],\"initialsupply\":3000000}' ``` #### Exporting an ID to a PBaaS chain ``` verus -chain=VRSCTEST sendcurrency \"*\" '[{\"address\":\"IDNAME@\",\"exportto\":\"PBaaSChainName\",\"exportid\":\"true\",\"amount\":100,\"currency\":\"vrsctest\"}]' ```### Signing transactions from multi-signature IDs (testnet and mainnet) Create transaction, get raw transaction data:  ``` verus sendcurrency <multi-signature-ID>@ '[{\"address\":\"<destination_address>\",\"amount\":<transaction_amount>}]' verus z_getoperationstatus <operation_id_returned_by_sendcurrency> ``` Take the raw hex transaction data provided by z_getoperationstatus to each additional wallet(s) containing the additional signing addresses/IDs:  ``` verus signrawtransaction <raw_hex_transaction> ``` After the last necessary signature is applied, broadcast on the network using:  ``` verus sendrawtransaction <raw_hex_signed_transaction> ```",
            "./raw_txt_input/release_notes.md"
        ],
        [
            "How do I export an ID to a PBaaS chain using Verus?",
            "To export an ID to a PBaaS chain using Verus, you can use the `sendcurrency` command with the following format:\n\n```\nverus -chain=VRSCTEST sendcurrency \"*\" '[{\"address\":\"IDNAME@\",\"exportto\":\"PBaaSChainName\",\"exportid\":\"true\",\"amount\":100,\"currency\":\"vrsctest\"}]'\n```",
            "#### Defining a PBaaS blockchain ```json  {  \"name\": \"PBaaSChain\",  \"options\": 264,  \"currencies\": [   \"VRSCTEST\"  ],  \"conversions\": [   1  ],  \"eras\": [   {    \"reward\": 1200000000,    \"decay\": 0,    \"halving\": 0,    \"eraend\": 0   }  ],  \"notaries\": [   \"Notary1@\",   \"Notary2@\",   \"Notary3@\"  ],  \"minnotariesconfirm\": 2,  \"nodes\": [   {    \"networkaddress\": \"111.111.111.111:10000\",    \"nodeidentity\": \"Node1@\"   },   {    \"networkaddress\": \"111.111.111.112:10000\",    \"nodeidentity\": \"Node2@\"   }  ],  \"gatewayconvertername\": \"Bridge\",  \"gatewayconverterissuance\": 1000000 } ``` The bridge definition has overridable defaults ```json  {  \"currencies\": [   \"VRSCTEST\",   \"PBaaSChain\",   \"USD\"  ],  \"initialcontributions\": [   380228.12033701,   0,   1000000  ],  \"initialsupply\": 3000000 } ```Now pass those definitions to `definecurrency` ```shell ./verus -chain=vrsctest definecurrency '{\"name\":\"PBaaSChain\",\"options\":264,\"currencies\":[\"VRSCTEST\"],\"conversions\":[1],\"eras\":[{\"reward\":1200000000,\"decay\":0,\"halving\":0,\"eraend\":0}],\"notaries\":[\"Notary1@\",\"Notary2@\",\"Notary3@\"],\"minnotariesconfirm\":2,\"nodes\":[{\"networkaddress\":\"111.111.111.111:10000\",\"nodeidentity\":\"Node1@\"},{\"networkaddress\":\"111.111.111.112:10000\",\"nodeidentity\":\"Node2@\"}],\"gatewayconvertername\":\"Bridge\",\"gatewayconverterissuance\":1000000}' '{\"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\"initialcontributions\":[371747.20398827,0,1000000],\"initialsupply\":3000000}' ``` #### Exporting an ID to a PBaaS chain ``` verus -chain=VRSCTEST sendcurrency \"*\" '[{\"address\":\"IDNAME@\",\"exportto\":\"PBaaSChainName\",\"exportid\":\"true\",\"amount\":100,\"currency\":\"vrsctest\"}]' ```### Signing transactions from multi-signature IDs (testnet and mainnet) Create transaction, get raw transaction data:  ``` verus sendcurrency <multi-signature-ID>@ '[{\"address\":\"<destination_address>\",\"amount\":<transaction_amount>}]' verus z_getoperationstatus <operation_id_returned_by_sendcurrency> ``` Take the raw hex transaction data provided by z_getoperationstatus to each additional wallet(s) containing the additional signing addresses/IDs:  ``` verus signrawtransaction <raw_hex_transaction> ``` After the last necessary signature is applied, broadcast on the network using:  ``` verus sendrawtransaction <raw_hex_signed_transaction> ```",
            "./raw_txt_input/release_notes.md"
        ],
        [
            "What are the overridable defaults in a PBaaS bridge definition?",
            "The overridable defaults in a PBaaS bridge definition are:\n\n1. `currencies`: An array of currency tickers that the bridge supports, including the native coins of the chains being bridged.\n2. `initialcontributions`: An array specifying the initial liquidity for each currency in the bridge.\n3. `initialsupply`: The initial supply for the bridge's native token.",
            "#### Defining a PBaaS blockchain ```json  {  \"name\": \"PBaaSChain\",  \"options\": 264,  \"currencies\": [   \"VRSCTEST\"  ],  \"conversions\": [   1  ],  \"eras\": [   {    \"reward\": 1200000000,    \"decay\": 0,    \"halving\": 0,    \"eraend\": 0   }  ],  \"notaries\": [   \"Notary1@\",   \"Notary2@\",   \"Notary3@\"  ],  \"minnotariesconfirm\": 2,  \"nodes\": [   {    \"networkaddress\": \"111.111.111.111:10000\",    \"nodeidentity\": \"Node1@\"   },   {    \"networkaddress\": \"111.111.111.112:10000\",    \"nodeidentity\": \"Node2@\"   }  ],  \"gatewayconvertername\": \"Bridge\",  \"gatewayconverterissuance\": 1000000 } ``` The bridge definition has overridable defaults ```json  {  \"currencies\": [   \"VRSCTEST\",   \"PBaaSChain\",   \"USD\"  ],  \"initialcontributions\": [   380228.12033701,   0,   1000000  ],  \"initialsupply\": 3000000 } ```Now pass those definitions to `definecurrency` ```shell ./verus -chain=vrsctest definecurrency '{\"name\":\"PBaaSChain\",\"options\":264,\"currencies\":[\"VRSCTEST\"],\"conversions\":[1],\"eras\":[{\"reward\":1200000000,\"decay\":0,\"halving\":0,\"eraend\":0}],\"notaries\":[\"Notary1@\",\"Notary2@\",\"Notary3@\"],\"minnotariesconfirm\":2,\"nodes\":[{\"networkaddress\":\"111.111.111.111:10000\",\"nodeidentity\":\"Node1@\"},{\"networkaddress\":\"111.111.111.112:10000\",\"nodeidentity\":\"Node2@\"}],\"gatewayconvertername\":\"Bridge\",\"gatewayconverterissuance\":1000000}' '{\"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\"initialcontributions\":[371747.20398827,0,1000000],\"initialsupply\":3000000}' ``` #### Exporting an ID to a PBaaS chain ``` verus -chain=VRSCTEST sendcurrency \"*\" '[{\"address\":\"IDNAME@\",\"exportto\":\"PBaaSChainName\",\"exportid\":\"true\",\"amount\":100,\"currency\":\"vrsctest\"}]' ```### Signing transactions from multi-signature IDs (testnet and mainnet) Create transaction, get raw transaction data:  ``` verus sendcurrency <multi-signature-ID>@ '[{\"address\":\"<destination_address>\",\"amount\":<transaction_amount>}]' verus z_getoperationstatus <operation_id_returned_by_sendcurrency> ``` Take the raw hex transaction data provided by z_getoperationstatus to each additional wallet(s) containing the additional signing addresses/IDs:  ``` verus signrawtransaction <raw_hex_transaction> ``` After the last necessary signature is applied, broadcast on the network using:  ``` verus sendrawtransaction <raw_hex_signed_transaction> ```",
            "./raw_txt_input/release_notes.md"
        ],
        [
            "What are the essential components of a PBaaS blockchain definition using Verus?",
            "When defining a PBaaS blockchain using Verus, the essential components are:\n\n1. `name`: The name of the chain.\n2. `options`: An integer, in this case set to 264.\n3. `currencies`: An array of currencies that the chain's native currency can be converted into.\n4. `conversions`: An array defining the conversion ratios between the chain's native currency and each currency on the chain.\n5. `eras`: An array defining the block reward, reward decay, halving, and end of each \"era\" in the chain's lifecycle.\n6. `notaries`: An array of VerusIDs that will serve as notaries on the chain.\n7. `minnotariesconfirm`: An integer for the minimum number of notaries needed to confirm a block.\n8. `nodes`: An array describing the network addresses of the nodes on the chain, as well as their IDs.\n9. `gatewayconvertername`: The name of the bridge converter.\n10. `gatewayconverterissuance`: The initial supply of the bridge's native token.",
            "#### Defining a PBaaS blockchain ```json  {  \"name\": \"PBaaSChain\",  \"options\": 264,  \"currencies\": [   \"VRSCTEST\"  ],  \"conversions\": [   1  ],  \"eras\": [   {    \"reward\": 1200000000,    \"decay\": 0,    \"halving\": 0,    \"eraend\": 0   }  ],  \"notaries\": [   \"Notary1@\",   \"Notary2@\",   \"Notary3@\"  ],  \"minnotariesconfirm\": 2,  \"nodes\": [   {    \"networkaddress\": \"111.111.111.111:10000\",    \"nodeidentity\": \"Node1@\"   },   {    \"networkaddress\": \"111.111.111.112:10000\",    \"nodeidentity\": \"Node2@\"   }  ],  \"gatewayconvertername\": \"Bridge\",  \"gatewayconverterissuance\": 1000000 } ``` The bridge definition has overridable defaults ```json  {  \"currencies\": [   \"VRSCTEST\",   \"PBaaSChain\",   \"USD\"  ],  \"initialcontributions\": [   380228.12033701,   0,   1000000  ],  \"initialsupply\": 3000000 } ```Now pass those definitions to `definecurrency` ```shell ./verus -chain=vrsctest definecurrency '{\"name\":\"PBaaSChain\",\"options\":264,\"currencies\":[\"VRSCTEST\"],\"conversions\":[1],\"eras\":[{\"reward\":1200000000,\"decay\":0,\"halving\":0,\"eraend\":0}],\"notaries\":[\"Notary1@\",\"Notary2@\",\"Notary3@\"],\"minnotariesconfirm\":2,\"nodes\":[{\"networkaddress\":\"111.111.111.111:10000\",\"nodeidentity\":\"Node1@\"},{\"networkaddress\":\"111.111.111.112:10000\",\"nodeidentity\":\"Node2@\"}],\"gatewayconvertername\":\"Bridge\",\"gatewayconverterissuance\":1000000}' '{\"currencies\":[\"VRSCTEST\",\"PBaaSChain\",\"USD\"],\"initialcontributions\":[371747.20398827,0,1000000],\"initialsupply\":3000000}' ``` #### Exporting an ID to a PBaaS chain ``` verus -chain=VRSCTEST sendcurrency \"*\" '[{\"address\":\"IDNAME@\",\"exportto\":\"PBaaSChainName\",\"exportid\":\"true\",\"amount\":100,\"currency\":\"vrsctest\"}]' ```### Signing transactions from multi-signature IDs (testnet and mainnet) Create transaction, get raw transaction data:  ``` verus sendcurrency <multi-signature-ID>@ '[{\"address\":\"<destination_address>\",\"amount\":<transaction_amount>}]' verus z_getoperationstatus <operation_id_returned_by_sendcurrency> ``` Take the raw hex transaction data provided by z_getoperationstatus to each additional wallet(s) containing the additional signing addresses/IDs:  ``` verus signrawtransaction <raw_hex_transaction> ``` After the last necessary signature is applied, broadcast on the network using:  ``` verus sendrawtransaction <raw_hex_signed_transaction> ```",
            "./raw_txt_input/release_notes.md"
        ]
    ],
    "will",
    "be",
    "replaced",
    "8d2a11bd-bb53-4404-b77c-8f29be0b049c"
]